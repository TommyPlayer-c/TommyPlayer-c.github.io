{"pages":[{"title":"archives","text":"","link":"/archives/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"about","text":"就读于SYSU的CS","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"My friends wuhlan3: https://wuhlan3.gitee.io/wuhlan3/ wzc: http://www.yuko.buzz/","link":"/friends/index.html"}],"posts":[{"title":"\\*a++ 和 \\*++a","text":"*a++ 和 *++a++ 的优先级高于 *。*a++ 等价于 *(a++)；*++a 等价于 *(++a); 123456789101112#include &lt;iostream&gt;using namespace std;int main(){ int test[] = {1, 2, 3, 4, 5}; int *a = test; cout &lt;&lt; *a++ &lt;&lt; endl; // 输出1 cout &lt;&lt; *a &lt;&lt; endl; // 输出2 cout &lt;&lt; *++a &lt;&lt; endl; // 输出3 cout &lt;&lt; *a &lt;&lt; endl; // 输出3}","link":"/2021/03/28/C%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95-a-%E5%92%8C-a/"},{"title":"Vscode ssh 连接失败：Resolver error","text":"Vscode ssh 连接失败：Resolver error: Error: Connecting was canceled at Function.Canceled 由于之前 ssh 连接的电脑没有设置静态 IP，导致连接时选择的系统不匹配（有些是 windows，有些是 linux），可以在设置的 json 文件里修改。","link":"/2021/07/29/Vscode-ssh-%E8%BF%9E%E6%8E%A5%E5%A4%B1%E8%B4%A5%EF%BC%9AResolver-error-Error-Connecting-was-canceled-at-Function-Canceled/"},{"title":"fgets和fscanf对换行符的处理","text":"fgets 和 fscanf 对换行符的处理fscanf1int fscanf ( FILE * stream, const char * format, ... ); fscanf 将读取并忽略在下一个非空白字符之前遇到的任何空白字符（空白字符包括空格、换行符和制表符）。 fscanf 读取字符串时，读取任意数量的非空白字符，在找到的第一个空白字符处停止。在存储序列的末尾自动添加终止空字符。 fgets1char * fgets ( char * str, int num, FILE * stream ); 换行符使 fgets 停止读取，但它被函数视为有效字符并包含在复制到 str 的字符串中。 fgets 只能读取 num - 1 个字符，包括最后的换行符，在复制到 str 的字符后自动附加终止空字符。 验证实例总之，fscanf 不会读取换行符，读取之前会跳过所有换行符，读到换行符停止（流中的换行符还在）。 fgets 读取一行，读到换行符为止，但会读掉换行符（流中的换行符没有了）。 因此，如果使用了 fscanf 读取一行的内容，流中会剩余一个换行符，再使用 fgets 只会读到这个剩余的换行符，不会读取下一行。需要再使用 fgets 才能读取下一行。 12345678910111213141516#include &lt;stdio.h&gt;int main() { FILE *fp = fopen(&quot;test.txt&quot;, &quot;r&quot;); char line[20]; int a, b, c; fscanf(fp, &quot;%d %d %s&quot;, &amp;a, &amp;b, line); fprintf(stdout, &quot;%s&quot;, line); // String1 fgets(line, 20, fp); fprintf(stdout, &quot;%s\\n&quot;, line); // '\\n' fgets(line, 20, fp); fprintf(stdout, &quot;%s&quot;, line); // String2} 12345678[qhn@Tommy C_Prog]$ ./aString1String2Breakpoint 1, main () at test.c:1212 printf(&quot;%s&quot;, line); // '\\n'(gdb) print(line)$1 = &quot;\\n\\000ring1\\000@\\005@\\000\\000\\000\\000\\000\\340\\340\\377\\377&quot; 12 行不打印任何字符的原因参考 C编程中printf不加’\\n’不输出。","link":"/2021/10/08/C%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95-fgets%E5%92%8Cfscanf%E5%AF%B9%E6%8D%A2%E8%A1%8C%E7%AC%A6%E7%9A%84%E5%A4%84%E7%90%86/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/07/01/hello-world/"},{"title":"ubuntu 18.04 配置静态IP","text":"ubuntu 18.04 配置静态IP 使用命令 ipconfig 查看网卡名字 进入目录 cd /etc/netplan 使用 vim 修改/创建文件：sudo vim 50-cloud-init.yaml 按以下格式配置文件： 12345678910network: ethernets: wlp7s0: #第1步得到的网卡名称 addresses: [192.168.10.3/24] #IP地址 dhcp4: no #关闭DHCP服务，使用静态IP dhcp6: no gateway4: 192.168.10.1 #网关 nameservers: addresses: [192.168.10.1] #DNS地址 version: 2 使用 sudo netplan apply 命令 使用 service networking restart 命令","link":"/2021/08/13/Linux-ubuntu-18-04-%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/"},{"title":"二级页表、倒排页表","text":"二级页表、倒排页表 1. 分页机制的基本概念 分页的原因：固定分区会产生内部碎片，动态分区会产生外部碎片，这两种技术在内存上的使用都是低效的。 分页的基本思想：内存被划分成大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程也以同样大小的块为单位进行划分。 这样，进程只有在为最后一个不完整的块申请一个主存块空间时，才产生主存碎片（内部碎片），这种碎片相对于进程来说很小。每个进程平均只产生半个块大小的内部碎片。 分页不会产生外部碎片。 分页的几个基本概念 页和页大小 页（page）：进程中的块称为页。 页框（page frame，也称为页帧）：内存中的块称为页框。 进程在执行时需要申请主存，即要为每个页分配主存中的可用页框，这就产生了页和页框的一一对应。 页大小应该适中。页太小会导致进程的页数过多，页表过长，占用大量内存。页太大会导致内部碎片增多，降低内存利用率。 规定页和页框大小必须是 2 的幂，方便划分页号和偏移量。 页表（page table） 操作系统为每个进程维护一个页表，页表给出了该进程每页所对应的页框位置。 给出逻辑地址 &lt;页号，偏移量&gt; 后，处理器使用页表得到物理地址 &lt;页框号，偏移量&gt; 。 2. 二级页表 目的：克服页表占用过大内存空间的问题，压缩页表。 例如，对于 64 位的 CPU，若页面大小为 4 KB，则页表有 2^52 个表项，如果每个页表项占 8 字节，则整个页表需要占用 8 * 2^52 Bytes = 32 PB 存储空间！实际中不可能把那么大的页表放入连续的内存中。若不把这些页表放入连续的内存空间中，则需要一张索引表来告诉我们第几张页表该上哪里去找，这能解决页表的查询问题，且不用把所有的页表都调入内存，只在需要它时才调入。 建立多级页表的目的在于建立索引，以便不用浪费主存空间去存储无用的页表项，也不用盲目地顺序式查找页表项。 采用多级页表时，最高级页表不能超出一页大小。 若采用二级页表（如 32 位的 x86 CPU），则页号被划分成两个域：PT1 和 PT2 顶级页表（内存中）以 PT1 为索引，其表项指向二级页表，二级页表以 PT2 为索引 除顶级页表外的其他页表可以在内外存间交换 对 64 位处理器，一般采用三级页表 Linux 为了通用，采用的也是支持 64 位处理器的三级页表结构，对 32 位CPU，可以通过设中间页表的表项个数为 1 来解决。 具体实例 操作系统使用 32 位地址，虚拟地址空间大小为 4 GB (2^32)，页大小为 4 KB (2^12)，则虚拟地址空间由 2^20 页组成，每个页表项映射的大小为 4 B。 那么，一个用户页表有 2^20 页表项，大小为 2^20 * 4B(页表项大小) = 4 MB。由于在二级页表机制中，页表和其他页都服从分页管理，因此用户页表由 4 MB(用户页表内存大小) / 4 KB(页大小) = 2^10 页组成。 由于用户页表有 2^10 页，我们再用一个页表（根页表）来映射用户页表，就需要 2^10 个页表项映射。根页表大小为 2^10 * 4 B = 4 KB (2^12) 。 那么，一个 4B 的根页表项究竟能对应多大的用户内存呢？ 1 个根页表项可以映射到 1 页的用户页表。 而 1 页的用户页表又包含了 4 KB（页大小） / 4 B（页表项大小）= 1k 项页表项映射。 每个页表项可以映射到 1 页的用户内存。 所以，1 个根页表项可以映射到 1k * 4 KB = 4 MB 用户内存。可以看到使用二级页表，每个页表项可以映射到更多的内存空间了（从 4 KB 扩大为到 4 MB）。 对于上述提到的方案，虚拟地址的前 10 位用于检索根页表，查找关于用户页表的页的页表项。 若该页不在内存中，则发生一次缺页中断。 若该页在内存中，则用虚拟地址中接下来的 10 位检索用户页表项页。 3. 倒排页表前述页表设计的一个重要缺陷是，页表的大小与虚拟地址空间的大小成正比。 页表结构称为倒排的原因是，它使用页框号而非虚拟页号来索引页表项。 实际内存的每个页框对应一个页表项（而不是每个虚拟内存的页有一个页表项） 页表项的内容为（进程ID，页号）= (n, p)，记录定位于该占用页框的进程号和页号 优点——当物理内存较小时，反向页表可大量节省空间 缺点——从虚拟地址转换到物理地址变得非常困难（不能使用CPU所提供的页框号映射机制，得自己搜索整个反向页表，查找对应于页表项 (n, p) 的页框号） 具体请看书 P218 4. 转换检测缓冲区（Translation Lookaside Buffer，TLB）原则上，每次虚存访问都可能会引起两次物理访问：一次取相应的页表项，另一次取需要的数据。 为克服这个问题，使用一个高速缓存，通常称为转换检测缓冲区（Translation Lookaside Buffer，TLB） 使用TLB的地址转换工作原理： ​ 1. 给定一个逻辑地址，CPU首先到TLB去检查，判断页号在不在其中。 ​ 2. 若在（命中，hit），则直接从 TLB 中提取页框号并形成物理地址。 ​ 3. 若不在（不中/未命中，miss），则按普通访问页表方式工作，形成物理地址，并更新TLB（用新找到的页表表项替换一个TLB表项）。 不使用TLB的址转换工作原理： ​ 1. 由页号去页表检查该页在不在内存（P位）。 ​ 2. 若在，则形成物理地址。 ​ 3. 若不在，则产生**页错误(Page Fault)**并发出缺页中断，由OS将页调入内存并更新页表，进而形成物理地址。","link":"/2021/06/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%92%8C%E5%80%92%E6%8E%92%E9%A1%B5%E8%A1%A8/"},{"title":"SQL必知必会第四版——linux下创建书中用的数据表","text":"本人使用的是虚拟机 Centos7.6，MySQL； 步骤： 终端下登录 mysql：mysql -u root -p 创建数据表（名为 crashcourse）：create database crashcourse; 选择刚刚创建的数据库 crashcourse：use crashcourse; 使用官方提供的脚本生成表格：source /home/tom/rashcourse/create.sql source /home/tom/rashcourse/populate.sqlcreate.sql 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990-- ------------------------------------------- Sams Teach Yourself SQL in 10 Minutes-- http://forta.com/books/0672336073/-- Example table creation scripts for MySQL.-- ------------------------------------------- ------------------------ Create Customers table-- ----------------------CREATE TABLE Customers( cust_id char(10) NOT NULL , cust_name char(50) NOT NULL , cust_address char(50) NULL , cust_city char(50) NULL , cust_state char(5) NULL , cust_zip char(10) NULL , cust_country char(50) NULL , cust_contact char(50) NULL , cust_email char(255) NULL );-- ------------------------- Create OrderItems table-- -----------------------CREATE TABLE OrderItems( order_num int NOT NULL , order_item int NOT NULL , prod_id char(10) NOT NULL , quantity int NOT NULL , item_price decimal(8,2) NOT NULL );-- --------------------- Create Orders table-- -------------------CREATE TABLE Orders( order_num int NOT NULL , order_date datetime NOT NULL , cust_id char(10) NOT NULL );-- ----------------------- Create Products table-- ---------------------CREATE TABLE Products( prod_id char(10) NOT NULL , vend_id char(10) NOT NULL , prod_name char(255) NOT NULL , prod_price decimal(8,2) NOT NULL , prod_desc text NULL );-- ---------------------- Create Vendors table-- --------------------CREATE TABLE Vendors( vend_id char(10) NOT NULL , vend_name char(50) NOT NULL , vend_address char(50) NULL , vend_city char(50) NULL , vend_state char(5) NULL , vend_zip char(10) NULL , vend_country char(50) NULL );-- --------------------- Define primary keys-- -------------------ALTER TABLE Customers ADD PRIMARY KEY (cust_id);ALTER TABLE OrderItems ADD PRIMARY KEY (order_num, order_item);ALTER TABLE Orders ADD PRIMARY KEY (order_num);ALTER TABLE Products ADD PRIMARY KEY (prod_id);ALTER TABLE Vendors ADD PRIMARY KEY (vend_id);-- --------------------- Define foreign keys-- -------------------ALTER TABLE OrderItems ADD CONSTRAINT FK_OrderItems_Orders FOREIGN KEY (order_num) REFERENCES Orders (order_num);ALTER TABLE OrderItems ADD CONSTRAINT FK_OrderItems_Products FOREIGN KEY (prod_id) REFERENCES Products (prod_id);ALTER TABLE Orders ADD CONSTRAINT FK_Orders_Customers FOREIGN KEY (cust_id) REFERENCES Customers (cust_id);ALTER TABLE Products ADD CONSTRAINT FK_Products_Vendors FOREIGN KEY (vend_id) REFERENCES Vendors (vend_id); populate.sql 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112-- --------------------------------------------- Sams Teach Yourself SQL in 10 Minutes-- http://forta.com/books/0672336073/-- Example table population scripts for MySQL.-- --------------------------------------------- -------------------------- Populate Customers table-- ------------------------INSERT INTO Customers(cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email)VALUES('1000000001', 'Village Toys', '200 Maple Lane', 'Detroit', 'MI', '44444', 'USA', 'John Smith', 'sales@villagetoys.com');INSERT INTO Customers(cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact)VALUES('1000000002', 'Kids Place', '333 South Lake Drive', 'Columbus', 'OH', '43333', 'USA', 'Michelle Green');INSERT INTO Customers(cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email)VALUES('1000000003', 'Fun4All', '1 Sunny Place', 'Muncie', 'IN', '42222', 'USA', 'Jim Jones', 'jjones@fun4all.com');INSERT INTO Customers(cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email)VALUES('1000000004', 'Fun4All', '829 Riverside Drive', 'Phoenix', 'AZ', '88888', 'USA', 'Denise L. Stephens', 'dstephens@fun4all.com');INSERT INTO Customers(cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact)VALUES('1000000005', 'The Toy Store', '4545 53rd Street', 'Chicago', 'IL', '54545', 'USA', 'Kim Howard');-- ------------------------ Populate Vendors table-- ----------------------INSERT INTO Vendors(vend_id, vend_name, vend_address, vend_city, vend_state, vend_zip, vend_country)VALUES('BRS01','Bears R Us','123 Main Street','Bear Town','MI','44444', 'USA');INSERT INTO Vendors(vend_id, vend_name, vend_address, vend_city, vend_state, vend_zip, vend_country)VALUES('BRE02','Bear Emporium','500 Park Street','Anytown','OH','44333', 'USA');INSERT INTO Vendors(vend_id, vend_name, vend_address, vend_city, vend_state, vend_zip, vend_country)VALUES('DLL01','Doll House Inc.','555 High Street','Dollsville','CA','99999', 'USA');INSERT INTO Vendors(vend_id, vend_name, vend_address, vend_city, vend_state, vend_zip, vend_country)VALUES('FRB01','Furball Inc.','1000 5th Avenue','New York','NY','11111', 'USA');INSERT INTO Vendors(vend_id, vend_name, vend_address, vend_city, vend_state, vend_zip, vend_country)VALUES('FNG01','Fun and Games','42 Galaxy Road','London', NULL,'N16 6PS', 'England');INSERT INTO Vendors(vend_id, vend_name, vend_address, vend_city, vend_state, vend_zip, vend_country)VALUES('JTS01','Jouets et ours','1 Rue Amusement','Paris', NULL,'45678', 'France');-- ------------------------- Populate Products table-- -----------------------INSERT INTO Products(prod_id, vend_id, prod_name, prod_price, prod_desc)VALUES('BR01', 'BRS01', '8 inch teddy bear', 5.99, '8 inch teddy bear, comes with cap and jacket');INSERT INTO Products(prod_id, vend_id, prod_name, prod_price, prod_desc)VALUES('BR02', 'BRS01', '12 inch teddy bear', 8.99, '12 inch teddy bear, comes with cap and jacket');INSERT INTO Products(prod_id, vend_id, prod_name, prod_price, prod_desc)VALUES('BR03', 'BRS01', '18 inch teddy bear', 11.99, '18 inch teddy bear, comes with cap and jacket');INSERT INTO Products(prod_id, vend_id, prod_name, prod_price, prod_desc)VALUES('BNBG01', 'DLL01', 'Fish bean bag toy', 3.49, 'Fish bean bag toy, complete with bean bag worms with which to feed it');INSERT INTO Products(prod_id, vend_id, prod_name, prod_price, prod_desc)VALUES('BNBG02', 'DLL01', 'Bird bean bag toy', 3.49, 'Bird bean bag toy, eggs are not included');INSERT INTO Products(prod_id, vend_id, prod_name, prod_price, prod_desc)VALUES('BNBG03', 'DLL01', 'Rabbit bean bag toy', 3.49, 'Rabbit bean bag toy, comes with bean bag carrots');INSERT INTO Products(prod_id, vend_id, prod_name, prod_price, prod_desc)VALUES('RGAN01', 'DLL01', 'Raggedy Ann', 4.99, '18 inch Raggedy Ann doll');INSERT INTO Products(prod_id, vend_id, prod_name, prod_price, prod_desc)VALUES('RYL01', 'FNG01', 'King doll', 9.49, '12 inch king doll with royal garments and crown');INSERT INTO Products(prod_id, vend_id, prod_name, prod_price, prod_desc)VALUES('RYL02', 'FNG01', 'Queen doll', 9.49, '12 inch queen doll with royal garments and crown');-- ----------------------- Populate Orders table-- ---------------------INSERT INTO Orders(order_num, order_date, cust_id)VALUES(20005, '2012-05-01', '1000000001');INSERT INTO Orders(order_num, order_date, cust_id)VALUES(20006, '2012-01-12', '1000000003');INSERT INTO Orders(order_num, order_date, cust_id)VALUES(20007, '2012-01-30', '1000000004');INSERT INTO Orders(order_num, order_date, cust_id)VALUES(20008, '2012-02-03', '1000000005');INSERT INTO Orders(order_num, order_date, cust_id)VALUES(20009, '2012-02-08', '1000000001');-- --------------------------- Populate OrderItems table-- -------------------------INSERT INTO OrderItems(order_num, order_item, prod_id, quantity, item_price)VALUES(20005, 1, 'BR01', 100, 5.49);INSERT INTO OrderItems(order_num, order_item, prod_id, quantity, item_price)VALUES(20005, 2, 'BR03', 100, 10.99);INSERT INTO OrderItems(order_num, order_item, prod_id, quantity, item_price)VALUES(20006, 1, 'BR01', 20, 5.99);INSERT INTO OrderItems(order_num, order_item, prod_id, quantity, item_price)VALUES(20006, 2, 'BR02', 10, 8.99);INSERT INTO OrderItems(order_num, order_item, prod_id, quantity, item_price)VALUES(20006, 3, 'BR03', 10, 11.99);INSERT INTO OrderItems(order_num, order_item, prod_id, quantity, item_price)VALUES(20007, 1, 'BR03', 50, 11.49);INSERT INTO OrderItems(order_num, order_item, prod_id, quantity, item_price)VALUES(20007, 2, 'BNBG01', 100, 2.99);INSERT INTO OrderItems(order_num, order_item, prod_id, quantity, item_price)VALUES(20007, 3, 'BNBG02', 100, 2.99);INSERT INTO OrderItems(order_num, order_item, prod_id, quantity, item_price)VALUES(20007, 4, 'BNBG03', 100, 2.99);INSERT INTO OrderItems(order_num, order_item, prod_id, quantity, item_price)VALUES(20007, 5, 'RGAN01', 50, 4.49);INSERT INTO OrderItems(order_num, order_item, prod_id, quantity, item_price)VALUES(20008, 1, 'RGAN01', 5, 4.99);INSERT INTO OrderItems(order_num, order_item, prod_id, quantity, item_price)VALUES(20008, 2, 'BR03', 5, 11.99);INSERT INTO OrderItems(order_num, order_item, prod_id, quantity, item_price)VALUES(20008, 3, 'BNBG01', 10, 3.49);INSERT INTO OrderItems(order_num, order_item, prod_id, quantity, item_price)VALUES(20008, 4, 'BNBG02', 10, 3.49);INSERT INTO OrderItems(order_num, order_item, prod_id, quantity, item_price)VALUES(20008, 5, 'BNBG03', 10, 3.49);INSERT INTO OrderItems(order_num, order_item, prod_id, quantity, item_price)VALUES(20009, 1, 'BNBG01', 250, 2.49);INSERT INTO OrderItems(order_num, order_item, prod_id, quantity, item_price)VALUES(20009, 2, 'BNBG02', 250, 2.49);INSERT INTO OrderItems(order_num, order_item, prod_id, quantity, item_price)VALUES(20009, 3, 'BNBG03', 250, 2.49); 注意，这两个文件最好在 linux 下创建，并且编码必须为 UTF-8。如果不是 UTF-8，使用 more 查看该文件时会乱码，并且这一步操作会失败（本人折腾了一个晚上也找不出原因）。 最后发现是 windows 下载的 create.sql 编码格式是 UTF-16！在 vscode 中转为 UTF-8 就可以正常生成数据库的数据了。","link":"/2021/08/01/%E6%95%B0%E6%8D%AE%E5%BA%93-SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%AC%AC%E5%9B%9B%E7%89%88%E2%80%94%E2%80%94linux%E4%B8%8B%E5%88%9B%E5%BB%BA%E4%B9%A6%E4%B8%AD%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A1%A8/"},{"title":"Effective STL 笔记-第1章 容器","text":"1 容器 第 1 条：慎重选择容器类型。STL 容器不是简单的好，而是确实很好。 容器类型如下： 标准 STL 序列容器：vector、string、deque、list。 标准 STL 关联容器：set、multiset、map、multimap。 非标准序列容器 slist 和 rope。slist 是一个单向链表，rope 本质上是一个 “重型” string。 非标准的关联容器：hash_set、hash_multiset、hash_map、hash_multimap。 vector 作为 string 的替代。 vector 作为标准关联容器的替代：有时 vector 在运行时间和空间上都要优于标准关联容器。 几种标准的非 STL 容器：数组、bitset、valarray、stack、queue、priority_queue。 选择标准： vector 应该是默认使用的序列类型；需要频繁地在序列中间做插入和删除操作时，使用 list；大多数插入和删除的操作发生在序列的头部和尾部时，使用 deque。 连续内存容器：也称为基于数组的容器（array-based container），特点是会把它的元素存放在一块或多块动态分配的内存中，每块内存中有多个元素。 插入或删除元素时，同一内存块中的所有元素要向前或向后移动，这样会影响效率和异常安全性。 连续内存容器有 vector、string、deque、rope。 基于节点的容器：每一个动态分配的内存块中只存放一个元素。元素的插入和删除只影响到指向节点的指针，而不影响节点本身的内容。所以插入或删除操作时元素的值不需要移动。 基于节点的容器有 list 和 slist。 如果容器内部使用了引用计数技术（reference counting），你是否介意？如果是，就要避免使用 string 和 rope（都使用了引用计数技术）。可以考虑 vector 你需要使迭代器、指针、引用变为无效的次数最少吗？基于节点的容器没有这个问题，针对连续内存容器的插入和删除操作一般会导致指向该容器的迭代器、指针和引用变为无效。 如果在容器上使用 swap，使得迭代器、指针或引用变为无效了，你会在意吗？如果在意，你要避免使用 string，因为 string 是 STL 中在 swap 过程中会导致迭代器、指针和引用变为无效的唯一容器。 第 2 条：不要试图编写独立于容器类型的代码。容器类型被泛化为序列容器和关联容器，类似的容器被赋予相似的功能： 标准的连续内存容器提供随机访问迭代器，而标准的基于节点的容器提供了双向迭代器。 序列容器支持 push_front 和/或 push_back 操作，而关联容器则不然。 关联容器提供了对数时间的 lower_bound、upper_bound、equal_range 成员函数，但序列容器却没有提供。 所以，试图编写对序列容器和关联容器都适用的代码是毫无意义的，因为很多成员函数仅当其容器为某一类型时才存在。这种限制的根源在于，对不同类型的序列容器，使迭代器、指针和引用无效（invalidate）的规则是不同的。不同的容器是不同的，它们有非常明显的优缺点。它们并不是被设计来交换使用的。 一种容器类型转换为另一种容器类型：typedef 123456class Widget{...};typedef vector&lt;Widget&gt; WidgetContainer;WidgetContainer cw;Widget bestWidget;...WidgetContainer::iterator i = find(cw.begin(), cw.end(), bestWidget); 这样就使得改变容器类型要容易得多，尤其当这种改变仅仅是增加一个自定义得分配子时，就显得更为方便（这一改变不影响使迭代器/指针/引用无效的规则）。 第 3 条：确保容器中的对象拷贝正确而高效。 存在继承关系的情况下，拷贝动作会导致剥离（slicing）：如果创建了一个存放基类对象的容器，却向其中插入派生类对象，那么在派生类对象（通过基类的拷贝构造函数）被拷贝进容器时，它所特有的部分（即派生类中的信息）将会丢失。 123456vector&lt;Widget&gt; vw;class SpecialWidget: // SpecialWidget 继承于上面的 Widget public Widget{...};SpecialWidget sw;vw.push_back(); // sw 作为基类对象被拷贝进 vw 中 // 它的派生类特有部分在拷贝时被丢掉了 剥离意味着向基类对象中的容器中插入派生类对象几乎总是错误的。 解决剥离问题的简单方法：使容器包含指针而不是对象。 第 4 条：调用 empty 而不是检查 size()是否为0。 empty 通常被实现为内联函数（inline function），并且它做的仅仅是返回 size 是否为 0. empty 对所有标准容器都是常数时间操作，而对于一些 list 实现，size 耗费线性时间。 第 5 条：区间成员函数优先于与之对应的单元素成员函数。小测验：给定 v1 和 v2 两个向量，使 v1 的内容和 v2 后半部分相同的最简单操作是什么？ ​ v1.assign(v2.begin() + v2.size() / 2, v2.end()); TIP：assign 存在于所有的标准序列容器（vector，string，deque，list）中，当你需要完全替换一个容器的内容时，应该想到赋值（assignment）。 使用区间成员函数的原因：少写一些代码；得到意图清晰和更加直接的代码；更高的效率。 把一个 int 数组拷贝到一个 vector 的前端（P22）： 1234int data[numValues];vector&lt;int&gt; v;...v.insert(v.begin(), data, data + numValues); // 使用区间形式的 insert C++标准要求区间 insert 函数把现有容器中的元素直接移动到它们最终的位置上，即只需付出每个元素移动一次的代价。 支持区间的成员函数： 区间创建：所有的标准容器都提供以下形式的构造函数： 12container::container(InputIterator begin, // 区间开始 InputIterator end) // 区间结束 区间插入：所有的标准序列容器都提供以下形式的 insert： 123void container::insert(iterator position, // 在何处插入区间 InputIterator begin, // 区间开始 InputIterator end) // 区间结束 关联容器：void container::insert(InputIterator begin, InputIterator end); 区间删除：所有的标准容器都提供了区间形式的删除（erase）操作。 序列容器：iterator container::erase(iterator begin, iterator end); 关联容器：void container::erase(iterator begin, iterator end); 第 6 条：当心 C++ 编译器最烦人的分析机制。围绕参数名的括号会被忽略，而独立的括号则表明参数列表的存在（存在一个函数指针参数）。 C++中一条普遍规律：尽可能地解释为函数声明。 12345// 将一个含有整数的文件复制到一个list中。ifstream dataFile(&quot;ints.dat&quot;);list&lt;int&gt; data(istream_iterator&lt;int&gt;(dataFile), // dataFile两边的括号会被忽略 istream_iterator&lt;int&gt;()); // 函数指针 // 上式声明了一个函数，而不是初始化对象！ 第 7 条：如果容器中包含了通过 new 操作创建的指针，切记在容器对象析构前将指针 delete 掉。1234567void doSomething(){ vector&lt;Widget*&gt; vwp; for (int i = 0; i &lt; SOME_MAGIC_NUMBER; ++i) vwp.push_back(new Widget); ... // 使用 vwp } // 这里发生 Widget 泄露 当你使用指针的容器，而其中的指针应该被删除时，为了避免资源泄露，你必须或者用引用计数形式的智能指针对象（比如 Boost 的 shared_ptr）代替指针，或者当容器被析构时手工删除其中的每个指针。 使用 for_each 和 delete 函数对象来解决这个问题。 1234567891011121314struct DeleteObject{ // 这里去掉了模板化和基类 template&lt;typename T&gt; // 在这里加入模板化 void operator()(const T* ptr) const { delete ptr; }}void doSomething(){ deque&lt;SpecialString*&gt; dssp; for_each(dssp.begin(), dssp.end(), DeletObject()); // 确定的行为，但不是异常安全的} 使用智能指针来解决这个问题。 123456789void doSomething(){ typedef boost::shared_ptr&lt;Widget&gt; SPW; // SPW = 指向 Widget 的 shared_ptr vector&lt;SPW&gt; vwp; for (int i = 0; i &lt; SOME_MAGIC_NUMBER; ++i) vwp.push_back(SPW(new Widget)); ... // 使用vwp } // 这里不会有Widget泄露，即使上面的代码 有异常被抛出。 第 8 条：请勿创建包含 auto_ptr 的容器对象auto_ptr 的容器（COAP）是被禁止的，试图使用它们的代码不会被编译通过。 复制一个 auto_ptr 时，它所指向的对象的所有权被移交到复制的 auto_ptr 上，而它自身被置为 NULL。复制一个 auto_ptr 意味着改变它的值。 123vector&lt;auto_ptr&lt;Widget&gt; &gt; widgets;sort(widgets.begin(), widgets.end(), widgetAPcompare()); // 对vector所做的排序操作可能会改变它的内容！ 第 9 条：慎重选择删除元素的方法删除容器中有特定值的所有对象对标准容器 Container&lt;int&gt;c; 删除其中所有值为 1963 的元素的方法。 erase-remove 习惯用法（连续内存容器 vector，deque，string）： 1c.erase(remove(c.begin(), c.end(), 1963), c.end()); list：c.remove(1963); 关联容器：c.erase(1963); 对数时间开销，基于等价而不是相等。注意关联容器没有名为 remove 的成员函数，使用任何名为 remove 的操作都是完全错误的。 删除容器中满足特定判别式（条件）的所有对象删除使下面的判别式返回 true 的每一个对象 1234567bool badValue(int );// 序列容器(vector,string,deque,list)c.erase(remove_if(c.begin(), c.end(), badValue), c.end());// listc.remove_if(badValue); 对于标准关联容器，则没有这么直截了当。 简单但效率稍低的办法：利用 remove_copy_if 把我们需要的值复制到一个新容器中，然后把原来容器的内和新容器的内容相互交换： 12345AssocContainer&lt;int&gt; c;...AssocContainer&lt;int&gt; goodValues; // 保持不被删除的值的临时容器remove_copy_if(c.begin(), c.end(), inserter(goodValues, goodValues.end()), badValue);c.swap(goodValues); 高效方法：写一个循环遍历容器中的元素，并在遍历过程中删除元素。注意，对于关联容器（map，set，multimap，multiset），删除当前的 iterator，只会使当前的 iterator 失效。 原因：关联容器的底层使用红黑树实现，插入、删除一个结点不会对其他结点造成影响。erase 只会使被删除元素的迭代器失效。关联容器的 erase 返回值为 void，可以使用 erase(iter++) 的方式删除迭代器。 123456789101112AssocContainer&lt;int&gt; c;ofstream logFile;...for (AssocContainer&lt;int&gt;::iterator i = c.begin(); i != c.end(); /*什么也不做*/){ if (badValue(*i)) { logFile &lt;&lt; &quot;Erasing &quot; &lt;&lt; *i &lt;&lt; '\\n'; // 写日志文件 c.erase(i++); // 使用后缀递增删除元素，避免迭代器无效。 } else ++i;} 对于序列式容器（vector，string，deque），删除当前的 iterator 会使后面所有元素的 iterator 都失效。 原因： vector、string、deque 使用了连续分配的内存，删除一个元素会导致后面的所有元素都向前移动一个位置。所以不能使用 erase(iter++) 的方式，但可以使用 erase 方法，序列容器的 erase 可以返回下一个有效的 iterator。 123456789for (SeqContainer&lt;int&gt;::iterator i = c.begin(); i != c.end(); ){ if (badValue(*i)) { logFile &lt;&lt; &quot;Erasing &quot; &lt;&lt; *i &lt;&lt; '\\n'; i = c.erase(i); // 把erase的返回值赋给i，使i的值保持有效。 } else ++i;} 第 10 条：了解分配子（allocator）的约定和限制分配子最初是作为内存模型的抽象而产生的。 编写自定义的分配子，需要记住哪些内容： 分配子是一个模板，模板参数 T 代表你为它分配内存的对象类型。 提供类型定义 pointer 和 reference，但是始终让 pointer 为 T*，reference 为 T&amp;。 千万别让你的分配子拥有随对象而不同的状态（per-object state）。通常，分配子不应该有非静态的数据成员。 传给分配子的 allocate 成员函数的是那些要求内存的对象的个数，而不是所需的字节数。同时要记住，这些函数返回 T* 指针（通过 pointer 类型定义），即使尚未有 T 对象被构造出来。 一定要提供嵌套的 rebind 模板，因为标准容器依赖该模板。（P42） 第 11 条：理解自定义分配子的合理用法。第 12 条：切勿对 STL 容器的线程安全性有不切实际的依赖。STL 只支持以下多线程标准： 多个线程读是安全的。 多个线程对不同的容器做写入操作是安全的。 你不能指望 STL 库会把你从手工同步控制中解脱出来，而且你不能依赖于任何线程支持。","link":"/2021/07/15/Effective-STL-1-%E5%AE%B9%E5%99%A8/"},{"title":"Effective STL 笔记-第4章 迭代器","text":"4 迭代器 第 26 条：iterator 优先于 const_interator、reverse_interator 及 const_reverse_interator。不同类型的迭代器之间的关系： 尽量使用 iterator 而不是 const 或 reverse 型的迭代器，可以使得容器的使用更为简单而有效，并且可以避免潜在的问题。 有些版本的 insert 和 erase 函数要求使用 iterator。如果你需要调用这些函数，必须使用 iterator，const 和 reverse 型的迭代器不能满足这些函数的要求。 要想隐式地将一个 const_interator 转换成 iterator 是不可能的。 从 reverse_interator 转换而来的 iterator 在使用之前可能需要相应的调整。 尽量不要混合使用 iterator 和 const_interator，有可能通过不了编译。 第 27 条：使用 distance 和 advance 将容器的 const_interator 转换成 iterator。包含显式类型转换的代码不能通过编译的原因：对于这些容器类型（deque，list，set，multiset，map，multimap），iterator 和 const_interator 是完全不同的类。 1234567typedef intDeque::const_interator ConstIter;ConstIter ci;...Iter i(ci); // 编译错误！从const_interator到 // iterator没有隐式转换途径。Iter i(const_caset&lt;Iter&gt;(ci)); // 仍然是编译错误！不能将 // const_iterator强制转换为iterator 不过，对于 vector 和 string 而言，以上代码也许能通过编译。 vector：const T* 变为 const * string：char * 变为 const char * 将 const_interator 转换为 iterator 可能需要线性时间的代价（双向迭代器），安全、可移植不需要线性时间（随机访问迭代器）的代价。 将 advance 那一行改为 12advance(i, distance&lt;ConstIter&gt;(i, ci)); // 将i和ci都当做const_interator, // 计算出它们之间的距离，然后将i移动这段距离 第 28 条：正确理解由 reverse_interator 的 base() 成员函数所产生的 iterator 的用法。 删除 ri 所指的元素：v.erase((++ri).base() ); 不能对 base 的结果做递减操作，先递增 ri，再调用 base() 函数。 第 29 条：对于逐个字符的输入请考虑使用 istreambuf_iterator。如果你需要从一个输入流中逐个读取字符，那么就不必使用格式化输入，使用 istreambuf_interator 可获得明显的性能改善：直接从流的缓冲区读取下一个字符。 复制文本文件的内容到 string： 123ifstream inputFile(&quot;interestingData.txt&quot;);string fileData((istreambuf_iterator&lt;char&gt;(inputFile)), istreambuf_iterator&lt;char&gt;());","link":"/2021/07/18/Effective-STL-4-%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"title":"Effective STL 笔记-第2章 vector 和 string","text":"2 vector 和 string 第 13 条：vector 和 string 优先于动态分配的数组。使用 new 动态分配内存时必须承担的责任： 确保以后用 delete 删除所分配的内存。 确保使用正确的 delete 形式。 确保只 delete 了一次。 普通数组的缺点： 没有提供 begin、end、size 这样的成员函数。 没有 iterator、reverse_iterator、value_type 这样的嵌套类型定义。 使用 vector 和 string 可以减轻自己的负担。 第 14 条：使用 reserve 来避免不必要的重新分配。vector 和 string 的自动增长机制： 分配：分配一块大小为当前容量的某个倍数的新内存。vector 和 string 一般为 2. 把容器的所有元素从旧的内存复制到新的内存。 析构掉旧内存中的对象。 释放旧内存。 **size()**：告诉你该容器中有多少个元素。 **capacity()**：告诉你该容器利用已经分配的内存可以容纳多少个元素。这是容器所能容纳的元素总数。 **resize(Container::size_type n)**：强迫容器改变到包含 n 个元素的状态。在调用 resize 之后，size 将返回 n。 **reserve(Container::size_type n)**：强迫容器把它的容量变为至少是 n，前提是 n 不小于当前的大小。 使用 reserve，简单预留适合大小的空间，避免循环过程中发生重新分配： 123vector&lt;int&gt; v;v.reserve(1000);for (int i = 1; i &lt;= 1000; ++i) v.push_back(i); 对 push_back 的调用不会使 string 中的迭代器、指针和引用无效： 123456string s;...if (s.size() &lt; s.capacity()){ s.push_back('x');} 第 15 条：注意 string 实现的多样性。每个 string 包含的信息： 字符串的大小（size），即它所包含的字符个数。 存储该字符串中字符的内存容量（capacity）。 字符串的值（value)，即构成该字符串的字符。 可选： 分配子的拷贝。 对值的引用计数。 P56-P59 实现A 实现B 实现C 实现D 第 16 条：了解如何把 vector 和 string 数据传给旧的 API。 C++标准要求 vector 中的元素存储在连续的内存中，就像数组一样，所以可以直接得到容器中的数据指针。 对于 vector v; 表达式 v[0] 给出了一个引用，它是该向量中的第一个元素，所以 &amp;v[0] 是指向第一个元素的指针。 &amp;*v.begin() 等价于 &amp;v[0] 对于 string，由于 string 中的数据不一定存储在连续的内存中且 string 的内部表示不一定是以空字符结尾，需使用成员函数 c_str()。 P62 第 17 条：使用 “swap 技巧” 除去多余的容量。shrink to fit：为了避免向量仍占用不再需要的内存，你希望有一种方法能把它的容量从以前的最大值缩减到当前需要的数量。 从 contestants 向量中除去多余的容量： 1vector&lt;Contestant&gt;(contestants).swap(contestants); vector 的拷贝构造函数只为说拷贝的元素分配所需要的内存，所以这个临时变量没有多余的容量。 swap：临时变量的数据和 contestents 的数据做 swap 操作。在这之后，contestents 具有了被去除之后的容量，即原先临时变量的容量。临时变量随后被析构，从而释放先前为 contestents 所占据的内存。注意，迭代器、指针和引用也将被交换（string 除外）。 同样适用于 string 123string s;...string(s).swap(s); 清除一个容器： 12345vector&lt;Contestant&gt; v;string s;... vector&lt;Contestant&gt;().swap(v); // 清除v并把它的容量变为最小string().swap(s); // 清除s并把它的容量变为最小 第 18 条：避免使用 vector bool。vector 是一个假的容器： 它不是一个 STL 容器。 它并不存储 bool。为了节省空间，它储存的是 bool 的紧凑表示——使用了与位域（bitfield）一样的思想，一个 8 位的字节可容纳 8 个 “bool”。你可以创建一个指向 bool 的指针，而指向单个位的指针则是不允许的。指向单个位的引用也是被禁止的。 vector::operator[] 返回一个对象，表现得像是一个指向单个位的引用，即所谓的代理对象（proxy object）。 vector 的替代方案： deque：deque 是一个 STL 容器，而且它确实存储 bool。但 deque 中元素的内存不是连续的。 bitset：bitset 不是 STL 容器，它的大小（元素的个数）在编译时就确定了，所以它不支持迭代器。与 vector 一样，它使用了一种紧凑表示，只为所包含的每个值提供一位空间。 总之，vector 是一个失败了的雄心勃勃的实验，它不完全满足 STL 容器的要求；你最好不要使用它；你可以使用 deque 和 bitset 来替代它，这两个数据结构几乎能做 vector 所能做的一切事情。","link":"/2021/07/16/Effective-STL-2-vector-%E5%92%8C-string/"},{"title":"Effective STL 笔记-第3章 关联容器","text":"3 关联容器 第 19 条：理解相等（equality）和等价（equivalence）的区别。find 对”相同“的定义是相等，是以 operator== 为基础的。但 x 和 y 有相等的值并不一定意味着它们的所有数据成员都有相等的值。 set::insert 对“相同”的定义是等价，是以 operator&lt; 为基础的。 考虑 set&lt;Widget&gt; s 和 两个对象 w1 和 w2，如果下面的表达式为真，则 w1 和 w2 对于 operator&lt; 具有相等的值： 1! (w1 &lt; w2) &amp;&amp; ! (w2 &lt; w1); 如果两个值中的任何一个（按照一定的排序准则）都不在另一个的前面，那么这两个值（按照这一准则）就是等价的。 标准关联容器总是保持排列顺序的，所以每个容器必须有一个比较函数（默认为 less）来决定保持怎样的顺序。等价的定义正是通过该比较函数实现的。 使用单一的比较函数可以避免一大堆问题。 第 20 条：为包含指针的关联容器指定比较类型。set&lt;string*&gt; ssp; 是如下代码的缩写。 set&lt;string*, less&lt;string*&gt; &gt; ssp; 如果你想让 string* 指针在集合中按字符串的值排序，那么不能使用默认的比较函数子类（function class）less&lt;string*&gt;。你必须自己编写函数子类（不能是函数，set 需要的是一个类型，并在内部用它创建一个函数 ）。 123456789struct StringPtrLess: public binary_function&lt;const string*, const string*, bool&gt;{ bool operator() (const string *ps1, const string *ps2) const { return *ps1 &lt; *ps2 }}; 第 21 条：总是让比较函数在等值情况下返回 false。相等的值从来就不会有前后顺序关系，所以，对于相等的值，比较函数应当始终返回 false。 equal_range：指定一个包含等价值的区间。 任何一个定义了”严格的弱序化“的函数必须对相同值得两个拷贝返回 false。 第 22 条：切勿直接修改 set 或 multiset 中的键。对于一个 map&lt;K, V&gt; 或 map&lt;K, V&gt; 类型的对象，其中的元素类型是 pair&lt;const K, V&gt;，因为键的类型是 const K，所以它不能修改。 set / multiset 中的值不是 const，所以对这些值进行修改的代码可以通过编译。 类型转换： 1234if (i != se.end()){ const_cast&lt;Employee&gt;(*i).setTitle(&quot;Corporate Deitiy&quot;);} 注意，不能使用 static_cast ，因为类型转换的结果是一个临时的匿名对象，它是 *i 的一个拷贝，setTitle 被作用在这个临时对象上，而不是 *i 上！ 执行一次强制类型转换就意味着临时关掉了类型系统的安全性。 小结： 如果你不关心程序的可移植性，而你想改变 set 或 multiset 中元素的值，并且你的 STL 实现允许，则请继续做下去。只是注意不要改变元素中的键部分，即元素中能够影响容器有序性的部分。 如果你重视可移植性，就要确保 set 和 multiset 中的元素不能被修改。至少不能未经过强制类型转换就修改。 安全、可移植的方法： 1234567891011Employee selectedID;...EmpIDSet::iterator i = se.find(selectedID); // 第1步：找到待修改的元素if (i != se.end()) { Employee e (*i); // 第2步：拷贝该元素 e.setTitle(&quot;Corporate Deily&quot;); // 第3步：修改拷贝 se.erase(i++); // 第4步：删除该元素 // 递增迭代器以保持它的有效性 se.insert(i, e) // 第5步：插入该元素，它的位置和原来相同。 }; 第 23 条：考虑用排序的 vector 替代关联容器。标准的关联容器通常被实现为平衡二叉树。适合插入、删除、查找的混合操作，提供对数时间的查找能力。但比较浪费内存空间（父指针，左儿子指针，右儿子指针）。如果节点散布在全部地址空间，将会导致更多的页缺失。 散列容器：提供常数时间的查找能力。 使用数据结构的一般过程： 设置阶段：创建一个新的数据结构，并插入大量元素。在这个阶段，几乎所有的操作都是插入和删除操作，很少或几乎没有查找操作。 查找阶段：查询该数据结构以找到特定的信息。在这个阶段，几乎所有的操作都是查找操作，很少或几乎没有插入和删除操作。 重组阶段：改变该数据结构的内容，或许是删除所有的当前数据，再插入新的数据。在行为上，这个阶段与第1阶段类似。但这个阶段结束以后，应用程序又回到了第2阶段。 使用 vector 替代标准关联容器： 在排序的 vector 中存储数据可能比在标准关联容器中存储同样的数据要耗费更少的内存。 考虑到页面错误的因素，通过二分搜索法来查找一个排序的 vector 可能比查找一个标准关联容器要更快一点。 存储在 vector 中的数据必须是 pair&lt;K, V&gt; ，因为排序时它的元素的值将通过赋值操作被移动。 对 vector 做排序时，必须为 pair 写一个自定义的比较类型。（P85） 第 24 条：当效率至关重要时，请在 map::operator[] 与 map::insert 之间谨慎做出选择。map 的 operator[] 函数与众不同，它与 vector、deque 和 string 的 operator[] 函数无关，与用于数组的内置 operator[] 也没有关系。它的设计目的时为了提供添加和更新（add or update）的功能。 m[k] = v 检查键 k 是否已经在 map 中了。如果没有，它就被加入，并以 v 作为相应的值。如果 k 已经在映射表中了，则与之关联的值被更新为 v。 k 不在映射表时，operator[] 使用值类型的默认构造函数创建一个新的对象，然后返回指向这个新对象的引用。这样做效率会很低，可以换为 insert 操作，节省了 3 个函数调用（创建默认构造的对象，析构该临时对象，调用赋值操作符）。 总结：当向映射表中添加元素时，要优先选用 insert 而不是 operator[]；当更新已经在映射表中的元素的值时，要优先选择 operator[]。 P90：efficientAddOrUpdate 第 25 条：熟悉非标准的散列容器。非标准的散列容器有 hash_map，hash_set，hash_multimap，hash_multiset SGI 的散列容器： 12345template&lt;typename T, typename HashFunction = hash&lt;T&gt;, typename CompareFunction = equal_to&lt;T&gt;, typename Allocator = allocator&lt;T&gt; &gt;class hash_set; 注意，与标准关联容器不同， SGI 的散列容器使用 equal_to 作为默认的比较函数，通过测试两个对象是否相等而不是等价来决定容器中的两个对象是否相等。 SGI 的实现把表的元素放在一个单向链表中，而 Dinkumware 的实现则使用了双向链表。","link":"/2021/07/17/Effective-STL-3-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/"},{"title":"Effective STL 笔记-第5章 算法","text":"5 算法 第 30 条：确保目标区间足够大。（inserter）transform 算法：使用 front_inserter 将导致算法将结果插入到容器的头部，使用 back_inserter 将导致算法将结果插入到容器的尾部。 向容器末尾添加新的对象（使用 back_inserter，适用于所有提供了 push_back 方法的容器（vector,string,deque,list））： 12345int transmogrify(int x) // 该函数根据x生成一个新的值vector&lt;int&gt; results; transform(values.begin(), values.end(), // 将transmogrify作用在values的每个对象上 back_inserter(results), // 并将返回值插入到resultes的末尾。 transmogrify); 向容器前面添加新的对象（使用 front_inserter，适用于所有提供了 push_front 方法的容器）： 12345int transmogrify(int x) // 该函数根据x生成一个新的值list&lt;int&gt; results; transform(values.begin(), values.end(), // 将transmogrify作用在values的每个对象上 front_inserter(results), // 并将返回值以逆向顺序 transmogrify); // 插入到resultes的头部， 将 transform 的输出结果存放在 results 的前端，同时保留它们在 values 中原有的顺序，只需按照相反方向遍历 values 即可： 12345int transmogrify(int x) // 该函数根据x生成一个新的值list&lt;int&gt; results; transform(values.rbegin(), values.rend(), // 将transform的结果插入到容器头部， front_inserter(results), // 并保持相对顺序。 transmogrify); 将 transform 的结果插入到容器中特定位置上： 12345int transmogrify(int x) // 该函数根据x生成一个新的值list&lt;int&gt; results; transform(values.rbegin(), values.rend(), inserter(results, results.begin()+results.size()/2), transmogrify); // 将transform的结果插入到容器中间的位置 如果使用 transform 要覆盖原来的元素，第三个参数可以使用迭代器。 要在算法执行过程中增大目标区间，请使用插入型迭代器，比如 ostream_interator、back_inserter、front_inserter。 第 31 条：与排序有关的的选择。（sort相关） 如果需要对 vector、string、deque 或者数组中的元素执行一次完全排序，可以使用 sort 或 stable_sort。 如果有一个 vector、string、deque 或者数组，并且只需要对等价性最前面的 n 个元素进行排序，那么可以使用 partial_sort。 如果有一个 vector、string、deque 或者数组，并且需要找到第 n 个位置上的元素，或者，需要找到等价性最前面的 n 个元素但又不必对这 n 个元素进行排序，可以使用 nth_element。 将一个标准序列容器中的元素按照是否满足某个条件区分开来，使用 partition 和 stable_partition。 sort、stable_sort、partial_sort、nth_element 算法都要求随机访问迭代器，所以这些算法只能用于 vector、string、deque 和数组。 对于 list，可以使用 partition 和 stable_partition，可以用 list::sort 来替代 sort 和 stable_sort 算法。 实现 partial_sort 和 nth_element，需要通过间接途径。 性能排序：partition &gt; stable_partion &gt; nth_element &gt; partial_sort &gt; sort &gt; stable_sort 第 32 条：如果确实需要删除元素，则需要在 remove 这一类算法之后调用 erase。remove 是泛型算法，不接受容器作为参数，它不知道元素被存放在哪个容器中，也不可能推断出是什么容器（因为无法从迭代器推知对应的容器类型）。只有容器的成员函数才可以删除容器中的元素。 remove 不是真正意义上的删除，因为它做不到！ erase-remove 删除方式： 123vector&lt;int&gt; v;...v.erase(remove(v.begin(), v.end(), 99), v.end()); 例外：list 中的 remove 也应该被称为 erase，它可以真正删除元素。 两个 remove 类算法：remove_if 和 unique。 第 33 条：对包含指针的容器使用 remove 这一类算法时要特别小心。对包含指针的容器使用 remove 这一类算法时要特别警惕，否则就是资源泄露。 使用智能指针（RSCP，Reference Counting Smart Pointer）就无需考虑这些问题。但智能指针类型（RCSP&lt;Widget&gt;）必须能够隐式地转换为内置指针类型（Widget*）。 第 34 条：了解哪些算法要求使用排序的区间作为参数。要求排序区间的算法 binary_search、lower_bound、upper_bound、equal_range：只有当这些算法接收随机访问迭代器时，才保证对数时间的查找效率。否则，尽管比较次数依然是区间元素个数的对数，执行过程需要线性时间。 set_union、set_intersection、set_difference、set_symmetric_difference：需要排序的区间，这样能够保证线性时间内完成工作。 merge 和 inplace_merge：实现了合并和排序的联合操作，源区间已经排过序则可以线性时间内完成。 includes：判断一个区间中的所有对象是否都在另一个区间中，如果这两个区间排序则承诺线性时间的效率。 不一定要求排序区间，但通常情况下会与排序区间一起使用unique 通常用于删除一个区间的所有重复值，但并非真正意义上的删除。 必须为 STL 提供一致的排序信息：如果你为一个算法提供了一个排序的区间，而这个算法也带一个比较函数作为参数，那么，你一定要保证你传递的比较函数与这个排序区间所用的比较函数有一致的行为。 所有要求排序区间的算法（除了 unique 和 unique_copy）均使用等价性来判断两个对象是否“相同”，这与标准的关联容器一致。与此相反的是，unique 和 unique_copy 在默认情况下使用“相等”来判断两个对象是否“相同”。 第 35 条：通过 mismatch 或 lexicographical_compare 实现简单的忽略大小写的字符串比较。判断两个字符串是否相同，而不去管它们的大小写（ciCharCompare）123456789int ciCharCompare(char c1, char c2){ int lc1 = tolower(static_cast&lt;unsigned char&gt;(c1)); int lc2 = tolower(static_cast&lt;unsigned char&gt;(c2)); if (lc1 &lt; lc2) return -1; if (lc1 &gt; lc2) return 1; return 0;} 在 C 和 C++ 中，char 可能是有符号的，可能是无符号的。tolower 的参数和返回值都是 int，但是，除非该 int 值是 EOF，否则它的值必须可以用 unsigned char 表示。 ciStringCompare1234567int ciStringCompareImpl(const string &amp;s1, const string &amp;s2);int ciStringCompare(const string &amp;s1, const string &amp;s2){ if (s1.size() &lt; s2.size()) return ciStringCompareImpl(s1, s2); else return -ciStringCompare(s2, s1);} 第一种实现：mismatch 1234567891011//std::not2template &lt;class Predicate&gt; binary_negate&lt;Predicate&gt; not2 (const Predicate&amp; pred);//Return negation of binary function object//Constructs a binary function object (of a binary_negate type) that returns the //opposite of pred (as returned by operator !).// It is defined with the same behavior as:template &lt;class Predicate&gt; binary_negate&lt;Predicate&gt; not2 (const Predicate&amp; pred){ return binary_negate&lt;Predicate&gt;(pred);// 二元比较后再取非。 第二种实现：lexicographical_compare 123456789101112int ciCharCompare(char c1, char c2){ return tolower(static_cast&lt;unsigned char&gt;(c1)) &lt; tolower(static_cast&lt;unsigned char&gt;(c2));}bool ciStringCompare(const string &amp;s1, const string &amp;s2){ return lexicographical_compare(s1.begin(), s1.end(), s2.begin(), s2.end(), ciCharLess);} lexicographical_compare 是 strcmp 的一个泛化版本，可以允许用户自定义两个值的比较准则。如果在找到不同的值之前，第一个区间已经结束了，返回 true：一个前缀比任何一个以他为前缀的区间更靠前。 第 36 条：理解 copy_if 算法的正确实现copy_if 的正确实现： 1234567891011121314template&lt;typename InputIterator, typename OutputIterator, typename Predicate&gt;OutputIterator copy_if(InputIterator begin, InputIterator end, OutputIterator destBegin Predicate p) { while (begin != end) { if (p(*begin)) *destBegin++ = *begin; ++begin; } return destBegin; } 第 37 条：使用 accumulate 或者 for_each 进行区间统计。accumulate（计算出一个区间的统计信息） std::accumulate sum (1) template &lt;class InputIterator, class T&gt; T accumulate (InputIterator first, InputIterator last, T init); custom (2) template &lt;class InputIterator, class T, class BinaryOperation&gt; T accumulate (InputIterator first, InputIterator last, T init, BinaryOperation binary_op); sum： 第一种形式：有两个迭代器和一个初始值。计算 double 的总和时，初始值应该设为 0.0，否则 sum 的值不正确（每次加法的结果转换成整数后再运算） 第二种形式：使用 istream_iterator 和 istreambuf_interator（数值算法，numeric algorithm） 123cout &lt;&lt; accumulate(istream_iterator&lt;int&gt;(cin), istream_iterator&lt;int&gt;(), 0); accumulate 直接返回统计结果。 用法（custom） 计算一个容器中字符串的长度总和。 1234567891011121314string::size_typestringLengthSum(string::size_type sumSofFar, //size_type:中的技术类型 const string &amp;s){ return sumSoFar + s.size();} set&lt;string&gt; ss;...// 对ss中的每个元素调用stringLengthSum，然后把结果付给lengthSum，初始值为0string::size_type lengthSum = accumulate(ss.begin(), ss.end(). static_cast&lt;string::size_type&gt;(0), stringLengthSum); 计算一个区间中数值的乘积。 1234vector&lt;float&gt; vf;...// 对vf中的每个元素调用multipies&lt;float&gt;，并把结果赋给product float product = accumulate(vf.begin(), vf.end(), 1.0f, multiplies&lt;float&gt;()); 初始值必须为1.0f，保证是浮点数的1。 for_each（对一个区间的每个元素做一个操作）for_each 接受两个参数：一个是区间，另一个是函数（通常是函数对象），对区间中的每个元素都要调用这个函数。但这个函数只接受一个实参（即当前区间的元素）。 for_each 的函数参数允许有副作用。 for_each 返回的是一个函数对象。 举例：P134，计算一个区间中所有点的平均值。","link":"/2021/07/19/Effective-STL-5-%E7%AE%97%E6%B3%95/"},{"title":"Effective STL 笔记-第6章 函数子、函数子类、函数及其他","text":"6 函数子、函数子类、函数及其他 第 38 条：遵循按值传递的原则来设计函数子类。函数指针是按值传递的。 函数对象往往按值传递和返回。所以，编写的函数对象必须尽可能地小巧，否则复制的开销大；函数对象必须是单态的（不是多态），不得使用虚函数。 如果你希望创建一个包含大量数据并且使用了多态性的函数子类，该怎么办呢？ 123456789101112template&lt;typename T&gt;class BPFC: //BPFC = Big Polymorphic public // Functor Class unary_function&lt;T, void&gt; { private: Widget w; // 包含大量数据，按值传递效率低 int x; ...public: virtual void operator() (const T&amp; val) cosnt; // 虚函数存在剥离问题 } 那么你应该创建一个小巧、单态的类，其中包含一个指针，指向另一个实现类，并且将所有的数据和虚函数都放在实现类中（“Pimpl Idiom”）。 1234567891011121314151617181920212223template&lt;typename T&gt;class BPFCImpl: public unary_function&lt;T, void&gt; {private: Widget w; int x; ... virtual ~BPFCImpl(); virtual void operator() (const T&amp; val) const;friend class BPFC&lt;T&gt;; // 允许BPFC访问内部数据。 }template&lt;typename T&gt;class BPFC: // 新的BPFC类：短小、单态 public unary_function&lt;T, void&gt; {private: BPFCImpl&lt;T&gt; *pImpl; // BPFC唯一的数据成员public: void operator() (const T&amp; val) const // 现在这是一个非虚函数，将调用转到BPFCImpl中 { pImpl-&gt;operator()(val); }} 第 39 条：确保判别式是 “纯函数”。判别式（predicate）：一个返回值为 bool 类型的函数。 纯函数：指返回值仅仅依赖于其参数的函数。 判别式类（predicate class）：一个函数子类，它的 operator() 函数是一个判别式（返回 true 或 false）。 STL 中凡是可以接受一个判别式类对象的地方，也就可以接受一个判别式函数。 判别式应该是一个纯函数，而纯函数应该没有状态。 第 40 条：若一个类是函数子，则应使它可配接。对函数指针，要先应用 ptr_fun 之后再应用 not1 之后才可以工作。 4 个标准的函数配接器（not1、not2、bind1st、bind2nd）都要求一些特殊的类型定义，提供这些必要类型定义（argument_type、first_argument_type、second_argument_type、result_type）的函数对象被称为可配接（adaptable）的函数对象。 提供这些类型定义最简单的方法：让函数子从一个基结构继承。 对于 unary_function，必须指定函数子类 operator() 所带的参数类型，以及 operator() 返回类型。 对于 binary_function，必须指定 3 个类型：operator() 第一个和第二个参数类型，以及 operator() 返回类型。 1234567891011121314template&lt;typename T&gt;class MeetsThreshold: public std::unary_function&lt;Widget, bool&gt; {private: const T threshold; // 包含状态信息，使用类封装。public: MeetsThreshold(const T&amp; threshold); bool operator()(const Widget&amp;) const; ...}struct WidgetNameCompare: // STL中所有无状态函数子类一般都被定义成结构。 public std::binary_function&lt;Widget, Widget, bool&gt; { bool operator()(const Widget&amp; lhs, const Widget&amp; rhs) const; } 注意，一般情况下，传递给 binary_function 或 unary_function 的非指针类型需要去掉 const 和应用（&amp;）部分。 第 41 条：理解 ptr_fun、mem_fun 和 mem_fun_ref 的来由。STL语法惯例：函数或者函数对象被调用时，总是使用非成员函数的语法形式。 123456for_each(vw.begin(), vw.end(), test); // 调用1：f(x)，f为非成员函数for_each(vw.begin(), vw.end(), &amp;Widget::test); // 调用2：x.f()，f为成员函数 // x是一个对象或对象的引用list&lt;Widget *&gt; lpw;for_each(lpw.begin(), lpw.end(), &amp;Widgettest); // 调用3：p-&gt;f()，f为成员函数 // p是一个指向对象x的指针。 mem_fun、mem_fun_t：mem_fun 将语法 3 调整为语法 1。 123template&lt;typename R, typename C&gt; //该mem_fun声明针对不带参数的非const成员函数mem_fun_t&lt;R,C&gt; //C是类，R是所指向的成员函数返回的类型。mem_fun(R(C::*pmf)); mem_fun 带一个指向某个成员函数的指针参数 pmf，并且返回一个 mem_fun_t 类型的对象。 mem_fun_t 是一个函数子类，它拥有该成员函数的指针，并提供了 operator() 函数，在 operator() 中调用了通过参数传递进来的对象上的该成员函数。 类似地，mem_fun_ref 将语法 2 调整为语法 1。 第 42 条：确保 less&lt;T&gt; 于 operator&lt; 具有相同的语义。尽量避免修改 less 的行为，可能会误导其他程序员。 如果你使用了 less，无论是显式地还是隐式地，都需要确保它于 operator&lt; 具有相同的意义。 如果你希望以一种特殊的方式来排列对象，那么最好创建一个特殊的函数子类。","link":"/2021/07/20/Effective-STL-6-%E5%87%BD%E6%95%B0%E5%AD%90%E3%80%81%E5%87%BD%E6%95%B0%E5%AD%90%E7%B1%BB%E3%80%81%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E4%BB%96/"},{"title":"Effective STL 笔记-第7章 在程序中使用STL","text":"7 在程序中使用STL 第 43 条：算法调用优先于手写的循环。调用算法优于手写循环： 效率：算法比手写的循环效率更高。 正确性：手写循环比使用算法容易出错。 可维护性：使用算法的代码更加简洁明了。 例子：P155， 算法的名称表明了它的功能，而 for、while、do 循环不能。 手写循环需要维护迭代器的有效性。 第 44 条：容器的成员函数优先于同名的算法。原因： 成员函数往往速度快。 成员函数通常与容器结合得更加紧密。（同样的名称做不同的事情） 对于 map 和 multimap 而言 成员函数可以获得对数时间的性能。 成员函数的相同是等价，而算法是相等。 它们的成员函数只统计检查每个 pair 对象的键部分。而算法同时检查键和值/(key,value)对。 对于 list 而言，list 成员函数只是简单地维护指针，可以提供更好的性能。list 的 remove、remove_if、unqiue 则实实在在的删除了元素。sort 算法不能直接应用于 list，因为 sort 需要随机访问迭代器，而 list 的迭代器是双向迭代器。 第 45 条：正确区分 count、find、binary_search、lower_bound、upper_bound 和 equal_range。存在性测试： 12if (count(lw.begin(), lw.end(), w) != 0) ...if (find(lw.begin(), lw.end(), w) != lw.end()) ... equal_range 返回一个迭代器，第一个迭代器等于 lower_bound 返回的迭代器，第二个迭代器等于 upper_bound 返回的迭代器。它可以同时完成 find 的工作和 count 的工作。 第 46 条：考虑使用函数对象而不是函数作为 STL 算法的参数。12sort(v.begin(), v.end(), doubleGreater);sort(v.begin(), v.end(), greater&lt;double&gt;()); 使用 greater&lt;double&gt;() 的 sort 调用比使用 doubleGreater 的 sort 调用快得多。原因：函数内联，sort 不包含函数调用。 抽象性利益：C++ 的 sort 算法性能总是优于 C 的 qsort。在运行时，sort 算法以内联方式调用它的比较函数，而 qsort 则通过函数指针调用它的比较函数。 使用函数对象，可以让你的程序正确地通过编译，避免语言本身的缺陷。 第 47 条：避免产生 “直写型” （write only）的代码。直写型代码：虽然很容易编写，但是难以阅读和理解。 第 48 条：总是包含（#include）正确的头文件。 几乎所有的标准 STL 容器都被声明在与之同名的头文件中。set 和 map 是个例外， 声明了 set 和 multiset， 声明了 map 和 multimap。 除了 4 个 STL 算法以外，其他所有的算法都被声明在 中。这 4 个算法是 accumulate、inner_product、adjacent_difference、partial_sum，它们被声明在 中。 特殊类型的迭代器，包括 istream_interator、istreambuf_interator，被声明在 中。 标准的函数子和函数子配接器被声明在头文件 中。 第 49 条：学会分析与 STL 相关的编译器诊断信息。第 50 条：熟悉与 STL 相关的 web 站点。SGI STL 站点 STLport 站点 Boost 站点","link":"/2021/07/20/Effective-STL-7-%E5%9C%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E4%BD%BF%E7%94%A8STL/"},{"title":"Kruscal 算法","text":"Kruscal 算法（C++）1. Kruscal 算法简介Kruscal 最小生成树算法起始于一个空的图，并按照以下规则从边集中选择边。 不断重复地选择未被选中的边中权重最轻且不会形成环的一条。 Kruscal 算法通过逐条增加边来构造最小生成树。在保证不出现环的同时，它总简单地选择当前所余的权重最轻的边。这是一个典型的贪心算法，即每次决策都对应于最明显的即时利益。 下面是《算法概论》一书中给出的伪代码。 2. 代码部分下面将伪代码改写成 C++ 程序。 确定图的表示方式 这里我选择建立一个结构体表示边的信息，u、v、w 分别表示边的 2 个端点和边权。 12345struct Edge{ int u, v, w;};Edge graph[MAXN]; 编写 _find 和 _union 有两种方法，分别是基于等级的合并和路径压缩，这里先把它看做黑箱，接下来再详细阐述。 但这两种方法都要使用 Rank 数组，下面先给出一些要用到的全局变量以及初始化 Rank 的 makeset 函数。 12345678910int n, m; // n个结点，m条无向边int parent[MAXN], Rank[MAXN]; // 基于等级的合并int min_weight = 0; // 最小生成树的权值int cnt = 0; // 统计最小生成树的边数，判断是否连通void makeset(int x){ parent[x] = x; Rank[x] = 0;} Kruscal 核心代码——参照伪代码写出 1234567891011121314151617181920212223void kruskal(){ for (int i = 0; i &lt; n; ++i) { makeset(i); // 初始化 } sort(graph, graph + m, [](const Edge &amp;a, const Edge &amp;b) -&gt; bool { return a.w &lt; b.w; }); // 这里使用C++11的lambda，也可以写一个cmp函数 for (int i = 0; i &lt; m; ++i) { int x = _find(graph[i].u), y = _find(graph[i].v); if (x != y) // 第i条边的两个端点u、v属于不同集合 { min_weight += graph[i].w; _union(x, y); ++cnt; } //if (cnt == n-1) break; // 选了n-1条边就结束了，也可以不加，因为剩下的边的顶点肯 // 定都在最小生成树内了，接下来的循环中if总是判断为假。 }} 3. 并查集的编写方式3.1 基于等级的合并存储集合的方法之一是采用有向树，树的结点对应集合中的元素，每个结点都包含一个父指针（使用parent数组实现）。父指针使得结点一级级相连并最终指向树的根，我们用树根元素来代表整个集合。 与其他元素不同，树根的父指针指向该元素自身，所以我们使用 makeset 初始化时将每个元素的 parent 初始化为自身。对于节点的等级信息，我们将其解释为其下悬挂的子树的高度。 12345void makeset(int x){ parent[x] = x; Rank[x] = 0;} find 函数的实现很简单，只需要沿着节点的父指针找到树的根。**_find 的执行时间和树的高度成正比**。 123456int _find(int x){ while (x != parent[x]) x = parent[x]; return x;} 合并两个树（集合）的过程也很简单，只需要将一个树的根（的父指针）指向另一个树的根。由于树的高度影响计算效率，我们应该尽可能使树的高度小一点。因此，我们选择让较低的树的根指向较高的树的根，这样一来，除非将要合并的树等高，否则不会使合并后的树总高度增加。 123456789101112131415161718void _union(int x, int y){ int rx = _find(x); int ry = _find(y); if (rx == ry) return; // x和y的根相同，已经在同一个集合中 if (Rank[rx] &gt; Rank[ry]) { parent[ry] = rx; // 让较低的树根指向较高的树根 } else { parent[rx] = ry; if (Rank[rx] == Rank[ry]) // 两个树等高的情形 ++Rank[ry]; }} 下面是合并的具体过程。 3.2 路径压缩由上文易知，find 操作的时间复杂度为 O(logh)，h 为树高，采用路径压缩可以将总的代价分摊，由 O(logh) 下降到略微超过 O(1)。在每次 find 操作中，当沿着一系列的父指针找到树根后，我们可将这些父指针直接指向树根。 12345int _find(int x){ if (x != parent[x]) parent[x] = _find(parent[x]); return parent[x];} 4. 测试测试题目，洛谷 P3366 【模板】最小生成树 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define MAXN 200001int n, m; // n个结点，m条无向边int parent[MAXN], Rank[MAXN];int min_weight = 0; // 最小生成树的权值int cnt = 0; // 统计最小生成树的边数，判断是否连通struct Edge{ int u; int v; int w;};Edge graph[MAXN];void makeset(int x){ parent[x] = x; Rank[x] = 0;}int _find(int x){ while (x != parent[x]) x = parent[x]; return x;}void _union(int x, int y){ int rx = _find(x); int ry = _find(y); if (rx == ry) return; // x和y的根相同，已经在同一个集合中 if (Rank[rx] &gt; Rank[ry]) { parent[ry] = rx; // 让较低的树根指向较高的树根 } else { parent[rx] = ry; if (Rank[rx] == Rank[ry]) // 两个树等高的情形 ++Rank[ry]; }}void kruskal(){ for (int i = 0; i &lt; n; ++i) { makeset(i); // 初始化 } sort(graph, graph + m, [](const Edge &amp;a, const Edge &amp;b) -&gt; bool { return a.w &lt; b.w; }); for (int i = 0; i &lt; m; ++i) { int x = _find(graph[i].u), y = _find(graph[i].v); if (x != y) // 第i条边的两个端点u、v属于不同集合 { min_weight += graph[i].w; _union(x, y); ++cnt; } //if (cnt == n-1) break; // 选了n-1条边就结束了，也可以不加，因为剩下的边的顶点肯 // 定都在最小生成树内了，接下来的循环中if总是判断为假 }}int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; ++i) { cin &gt;&gt; graph[i].u &gt;&gt; graph[i].v &gt;&gt; graph[i].w; } kruskal(); if (cnt != n - 1) cout &lt;&lt; &quot;orz&quot; &lt;&lt; endl; else cout &lt;&lt; min_weight &lt;&lt; endl;}","link":"/2021/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-2021-08-29-Kruscal%E7%AE%97%E6%B3%95/"},{"title":"Dijkstra 算法","text":"Dijkstra 算法复习小结一、Dijkstra 算法的基本思想Dijkstra 算法是解决单源最短路径问题的一般方法，它是一种贪心算法，要求图中所有边的权重非负。它的基本思想是：从一个起始顶点开始向外扩张，持续不断地将生成的图扩展到已知距离和最短路径的区域。简单地说，就是先加入最近的顶点，然后加入更远一些的顶点。 Dijkstra 算法类似广度优先搜索，扩展也是按照阶段进行的。设图的顶点集为 V，边集为 E，已知最短路径的顶点集为 R，（R 是 V 的一个子集） ，起始顶点为 s。在每个阶段，Dijkstra 算法从集合 V-R 中选择最短路径估计最小的顶点 v（在 V-R 中距离 s 最近的顶点），将 v 加入已知区域 R，然后对 v 的邻接点的最短距离进行调整更新（松弛）。 下面给出拓展 R 的伪代码： 二、算法要点该算法的有几个要点。 图的存储方式。这里使用邻接表较为简单。 1vector&lt; pair&lt;int, int&gt; &gt; adj[1501]; // adj[i].first为邻接点的编号，adj[i].second为到边距离。 每个结点需要建立一个结构体 123456789struct Vertex{ int index; int known; int dist; int path; Vertex() : index(-1), known(0), dist(INT_MAX), path(-1) {}};Vertex table[1501]; index 为图中结点的编号（可有可无） known 用来标记该节点的最短路径是否已知（true 已知，false 未知）。true 表明该节点属于已知区域 R，false 表明该节点属于 V - R。 dist 表示起始顶点 s 到该节点的距离。如果 known 为 true，则 d 为最短距离。 path 表示起始顶点 s 到该结点路径中的上一个结点（前驱），它用来打印路径。 核心部分（参考伪代码写出） 123456789101112131415161718192021222324void Dijkstra(int start, int n){ table[start].dist = 0; // 起始顶点的距离为0。 for (;;) { int k = findmin(n); // 找到V-R中距离s最近的顶点。 if (k == -1) // 所有的顶点都已知最短路径了，即V=R。 break; table[k].known = 1; // 将该节点加入已知区域R中。 // 更新当前节点的所有邻接点的最短路径（松弛） for (int i = 0; i &lt; adj[k].size(); ++i) { int v = adj[k][i].first; if (table[v].known == 0 &amp;&amp; table[v].dist &gt; table[k].dist + adj[k][i].second) { table[v].dist = table[k].dist + adj[k][i].second; table[v].path = k; } // 如果节点v最短路径未知，且经过当前顶点k的路径，能够使得从源节点s到结点v的最短路径的权重比当前的估计值更小，则我们对结点v的估计值dist和前驱path进行更新。 } }} 具体细节在注释。在 main 函数中已经使用 Initiate 进行初始化（其实也不需要，因为 Vertex 类的默认构造函数已经初始化了）。 对于 findmin，可以使用优先队列，但是本人水平有限，就使用暴力搜索的方式。 1234567891011121314int findmin(int n){ int min = INT_MAX, key = -1; for (int i = 1; i &lt;= n; ++i) { if (!table[i].known &amp;&amp; table[i].dist &lt; min) { min = table[i].dist; key = i; } } return key;} 三、证明算法的正确性从 s 到 v 的最短路径即为这样一条路径——它是基于一条已知最短路径中的某条边的扩展路径，选择这些拓展路径的最短路径就可以确定v。 四、时间复杂度If we use a vector to store “distance” information for all vertices, then finding the smallest value takes O(|V|) time, and the total updating takes O(|E|) time, and the running time is O(|V|2). 这里我使用了数组来存储结点 dist 的信息，所以 findmin 操作（找到 V-R 中 dist 最小值的顶点）会花费 O(|V|) 时间，松弛操作又花费 O(|E|) 时间，所以运行时间为 O(|V|^2)。 If we use a binary heap to store “distance” information, the finding the smallest takes O(log|V|) time and every updating also takes O(log|V|) time, so the total running time is ​ O(|V|) + O(|V|log|V|) +O(|E|log|V|) = O(|E|log|V|). 补充：采用不同数据结构时间复杂度 五、测试代码最后给出测试代码，如果有错请指出。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt; pair&lt;int, int&gt; &gt; adj[1501];struct Vertex{ int index; int known; int dist; int path; Vertex() : index(-1), known(0), dist(INT_MAX), path(-1) {}};Vertex table[1501];void Initiate(int n){ for (int i = 1; i &lt;= n; ++i) { table[i].index = i; table[i].known = 0; table[i].dist = INT_MAX; table[i].path = -1; } for(int i = 1; i &lt;= n; ++i){ adj[i].clear(); }}int findmin(int n){ int min = INT_MAX, key = -1; for (int i = 1; i &lt;= n; ++i) { if (!table[i].known &amp;&amp; table[i].dist &lt; min) { min = table[i].dist; key = i; } } return key;}void Dijkstra(int start, int n){ table[start].dist = 0; for (;;) { int k = findmin(n); if (k == -1) break; table[k].known = 1; // 更新当前节点的所有邻接点 for (int i = 0; i &lt; adj[k].size(); ++i) { int v = adj[k][i].first; if (table[v].known == 0 &amp;&amp; table[v].dist &gt; table[k].dist + adj[k][i].second) { table[v].dist = table[k].dist + adj[k][i].second; table[v].path = k; } } }}void Print(int start, int n){ for(int i = 1; i &lt;= n; ++i){ if(table[i].known == 1) cout &lt;&lt; start &lt;&lt; &quot;-&quot; &lt;&lt; i &lt;&lt; &quot;:&quot; &lt;&lt; table[i].dist &lt;&lt; endl; }}void print_path(Vertex v) { if(v.path != -1) { print_path(table[v.path]); cout &lt;&lt; &quot; to &quot;; } cout &lt;&lt; v.index;}int main(){ int t; cin &gt;&gt; t; // 样例数 for (int i = 1; i &lt;= t; ++i) { int n, m; cin &gt;&gt; n &gt;&gt; m; // 顶点数，边数 Initiate(n); int u, v, w; for (int i = 1; i &lt;= m; ++i) { cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; adj[u].push_back({v, w}); } int src; cin &gt;&gt; src; Dijkstra(src, n); Print(src, n); // 输出从源点到其他点的最短路径 } return 0;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287输入：1100 1981 40 61 88 32 16 53 51 24 36 74 64 34 81 25 94 36 8 37 63 37 87 87 99 58 32 108 51 18 64 38 66 58 71 58 98 89 12 29 40 510 31 410 45 410 55 411 24 411 63 412 46 212 81 412 97 613 24 615 47 1015 83 615 100 116 54 116 71 617 51 417 90 818 70 1018 96 919 67 321 47 321 93 121 99 322 36 223 21 923 30 1023 74 424 89 1025 71 126 5 926 33 1026 47 826 73 326 97 227 67 228 96 229 64 529 81 430 96 531 1 931 35 732 81 633 21 933 100 534 4 234 59 234 68 334 95 338 24 939 7 639 14 639 45 1039 90 439 92 1041 71 641 95 442 43 1042 52 442 62 542 64 643 9 843 65 943 66 1043 96 844 13 444 22 944 61 344 81 945 52 646 26 847 28 147 52 247 70 748 31 948 33 250 32 550 43 1052 43 352 83 853 1 853 4 853 33 453 41 253 59 654 58 954 88 356 39 357 2 557 23 757 44 1059 19 960 82 161 22 162 20 962 74 663 21 863 98 364 9 264 50 865 73 366 24 466 44 467 20 1067 34 767 68 867 72 867 83 867 98 868 8 668 25 768 67 569 7 169 85 570 16 670 34 670 61 870 84 170 93 571 13 371 15 271 67 971 83 1071 100 572 61 573 6 273 64 174 16 574 69 576 14 377 31 577 86 178 12 478 59 278 66 679 12 579 22 1079 57 1079 88 980 3 381 18 981 32 181 87 582 23 782 49 283 5 583 74 683 93 1084 42 884 52 684 74 484 99 885 7 685 60 586 7 1088 26 588 60 1089 18 491 11 491 35 591 53 692 44 693 28 493 37 593 48 693 87 494 42 694 59 894 83 495 28 696 62 497 42 698 2 498 33 298 91 799 2 8100 21 5100 30 6100 66 10100 86 7 10输出：10-1:1310-2:4010-4:4410-5:2310-6:2610-7:3010-8:2910-9:2110-10:010-11:4710-12:2310-13:3110-15:3610-16:2910-18:3610-19:4310-20:3410-21:4010-22:3110-23:3410-24:2710-25:5210-26:2110-28:3010-30:4210-31:410-32:2810-33:3110-34:4210-35:1110-36:3310-37:3310-40:1910-41:5110-42:2910-43:1310-44:2710-45:410-46:2510-47:2910-48:3410-49:2910-50:3310-51:3010-52:1010-53:4910-54:3010-55:410-58:3910-59:3410-60:2610-61:3010-62:2510-63:3310-64:2510-65:2210-66:2310-67:4310-68:4510-69:2910-70:3610-71:3410-72:5110-73:2410-74:2410-81:2710-82:2710-83:1810-84:3710-85:3410-86:4310-87:3210-88:1610-89:3710-91:4310-93:2810-94:2610-95:4510-96:2110-97:2310-98:3610-99:3510-100:36 六、参考文献 算法概论 作者: Sanjoy Dasgupta / Christos Papadimitriou / Umesh Vazirani 出版社: 清华大学出版社，P127-P129 算法导论 第三版，P383-P385 七、推荐题目","link":"/2021/08/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-2021-08-30-Dijkstra%E7%AE%97%E6%B3%95/"},{"title":"算法导论-动态规划原理","text":"算法导论-动态规划原理1. 动态规划的概念 动态规划 (dynamic programming) 与分治方法相似，都是通过组合子问题的解来求解原问题（programming 指的是一种表格法，并非编写计算机程序。 动态规划应用于子问题重叠的情况，即不同的子问题具有公共的子子问题（子问题的求解是递归进行的，将其划分为更小的子子问题）。动态规划对每个子子问题只求解一次，将其解保存在一个表格中，从而无需每次求解一个子子问题都重新计算，避免了这种不必要的计算工作。 动态规划常用来求解最优化问题 (optimization problem)。这类问题有很多可行解，动态规划可以寻找到具有最优值（最大值或最小值）的解。这样的解为问题的一个最优解，而不是最优解，因为可能有多个解都达到最优值。 2. 动态规划的基本步骤和性质2.1 基本步骤 刻画一个最优解的结构特征（将原问题划分为子问题）。 利用子问题的最优解递归地定义最优解的值（递推公式）。 计算最优解的值，通常采用自底向上的方法。 利用计算出的信息构造一个最优解。 2.2 性质 两种方法：带备忘的自顶向下 (top-down)法；自底向上 (bottom-up)法 动态规划的标识：最优子结构，子问题重叠 最优子结构： 一个问题的最优解包含子问题的最优解，问题的最优解由子问题的最优解组合而成，而这些子问题可以独立求解。 做出一次选择，做出这次选择后会产生一个或多个待解的子问题；如何最好地刻画子问题空间（变量个数，具体表现在 dp 数组的维度）；考察多种选择中选择最优解。 子问题无关：同一个原问题的子问题的解不影响另一个子问题的解。 子问题重叠：递归算法重复求解相同的子问题。 重构最优解：我们将每个子问题所作出的选择存入一个表中，这样就不必根据代价值来重构这些信息。 如果每个问题都至少要求解一次，自底向上比备忘录快。如果子问题空间中的某些问题完全不必求解，则备忘方法快。 3. 最优子结构 (Optimal substructure) 最优子结构并不适用于所有最优化问题。 最短路径问题具有最优子结构的性质，但最长简单路径问题不具有这种性质。 例子：给定一个有向图 G = (V,E) 和 一对结点 u 和 v ，如果 p = p1p2 是从 u 到 v 的最短路径，那么 p1 是从 u 到 w 的最短路径。 证明如下： 如果存在另外一条从 u 到 w 的最短路径，叫做 p’1，那么 p‘1p2 这条路径的长度小于 p1p2 的长度，这就与假设矛盾。 子问题无关：同一个原问题的一个子问题的解不影响另一个子问题的解。 最短路径问题的子问题是无关 (independent) 的。 如果 (p1 = uw) (p2 = wv) 是最短路径，那么 p1 和 p2 除了 w 不能再有其他公共顶点。 最优子结构的体现： 原问题的最优解涉及多少个子问题。 在确定最优解使用哪些子问题时，我们需要考察多少种选择。 4. 重叠子问题 (Overlapping Subproblems ) 5. 无后效性这里参考了 leetcode 作者 liweiwei1419 的题解。 一个问题的递归结构如下图所示（这里忽略问题场景）。 可以发现有重复求解的部分，需要添加缓存，这是「记忆化递归」。 另外还可以从通过发现一个问题最开始的样子，通过「递推」一步一步求得原始问题的解，此时求解的过程如下图所示： 箭头指向的地方表示当前求解的过程中参考了以前求解过的问题的结果，这个过程不能形成回路，形成回路就无法求解。 6. 经典问题 装配线调度（Assembly-Line Scheduling） 钢条切割 矩阵链乘法 最长公共子序列（Longest Common Subsequence，LCS） 旅行商问题（TSP） 最优二叉搜索树","link":"/2021/06/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%8E%9F%E7%90%86/"},{"title":"RIP 协议的 2 个问题","text":"RIP 协议的 2 个问题 一、 基础知识 工作原理： 路由信息协议 (Routing Information Protocol，RIP) 是一种采用距离向量算法的路由协议，它的工作原理是利用邻居的路由表构造自己的路由表。它的最大优点是简单。 RIP 距离定义： 从路由器到直连网的距离定义为 1；从路由器到非直连网的距离定义为所经过的路由器数加 1（最后一个路由器到直连网的距离为 1）。 初始时每个 RIP 路由器只有到直连网的路由，距离为 1。 路由表中到目的网络的距离以跳为单位，所以 RIP 协议的距离也称为 “跳数”。最大距离为 15，距离 16 表示无穷大，即目的网络不可达。 RIP 认为好的路由就是它通过的路由器少，即 “距离” 短。所以，RIP 只会选择一条具有最少路由器的路由（最短路由），即使存在一条高速低时延但路由器较多的路由。 按固定的时间间隔交换路由信息： 每 30 秒， RIP 路由器把它的整个路由表发送给邻居。具体实现时发给每个邻居时会错开发送，30秒的时间也会随机变化一点。 距离向量算法： 当收到邻居发来的路由表 (update packet) 时，路由器将按以下步骤更新它的路由表：&lt;目的网络, 距离, 下一跳&gt; 首先将收到路由的距离全部加 1 (即一跳的距离)。 然后利用上述路由修改路由表: 把路由表中不存在的路由（原来的路由没有该目的网络）加入路由表。 如果下一条的路由地址不是邻居，且收到的上述路由比路由表中的路由的距离更小，则更新该路由的距离为新距离，把下一跳改为邻居。 如果路由已存在并且下一跳就是该邻居，则必须进行更新。（因为这是最新的消息，要已最新的消息为准。不管距离变大、变小还是不变都要更新）。 二、慢收敛问题 (Slow Convergence) 当增加一个新网络 N1 的时候，N1 的路由要从 R1 传到 Rm 最多需要多长时间？最少需要多少时间？ 最长时间：(m-1) * 30 s 增加了新网络 N1 时，恰好 R1 要等待 30 s 后才能将自己的路由表传给 R2，R1 的路由表传到 R2 后，R2 也要等待 30 s 后才能将自己的路由表传给 R3，以此类推。所以到达 Rm 要等待 (m-1) * 30 s。 最短时间：0 s（不计物理传播时间） R1 快要发送路由表时，恰好增加了新网络 N1，这时 R1 立即发送自己的路由表给 R2，恰好此时 R2 收到路由表后立即发送自己的路由表给 R3，以此类推。每一步都恰到好处。 三、计数到无穷问题(Count to Infinity)1. 无环的情况 注：上图中，’&lt;&gt;’ 表示的是 &lt;目的网络，距离，下一跳&gt;，’-‘ 表示下一跳为直连网。 问题：当 N1 失效时（比如路由器 R1 到 N1 的链路出现了故障），R1 把 N1 路由的距离改为 16（无穷大） 后会发生什么？ 解析：N1 失效后，R1 把 N1 路由的距离改为 16。然而 R1 发送自己的路由表给 R2 前，R2 可能已经先把自己的路由表发给了 R1，R1 到 N1 的距离会更新为 3（16 被覆盖了），这时 R1 再把自己的路由表发送给 R2，R2 到 N1 的距离会更新为 4。这样的更新一直继续下去（因为互为来源），直到 R1 和 R2 到 N1 的距离都增大到 16 时，R1 和 R2 才知道 N1 是不可达的。 网络出故障的传播时间往往很长（例如几分钟），这时 RIP 的一个主要缺点。 解决方法：**水平分割技术 (split horizon)**：从一个接口学来的路由不会从该接口发回去。用一个形象的类比，“ 从老师学来的东西，不要还给老师 ”。 2. 有环的情况 注：上图中，’&lt;&gt;’ 表示的是 &lt;目的网络，距离，下一跳&gt;，’-‘ 表示下一跳为直连网。 问题：即使使用了 “水平分割技术”，依然可能产生计数到无穷的情况。 当网络 N1 失效时，R2 路由表更新为 &lt;N1, 16, - &gt;。根据水平分割技术，由于 R1 和 R3 到 N1 的路由是向 R2 学来的，R1 和 R3 都不能将路由表发给R2。此时，R2 将路由表分别发给 R1 和 R3。接下来的事件严格按照时间顺序进行。 R2 发给 R1 的路由表先于 R2 发给 R3 的路由表到达，R1 的路由更新为 &lt;N1, **16**, R2&gt; R1 的路由表刚刚更新后，R3 就恰好将自己的路由表发送给了 R1，根据 RIP 协议，R1 的路由再次被更新为 &lt; N1, **3**, R3&gt; 此时，R1 的学习来源是 R3，所以 R1 可以将自己的路由表发送给 R2 了，R2 的路由表更新为 &lt;N1, **4**, R1&gt; R2 再向 R3 发送路由表，则 R3 的路由表更新为 &lt;N1, 5, R2&gt;。 此时三个路由表的距离都不是无穷 (16)，它们会不断持续更新路由表，直到所有的路由到 N1 的距离为 16。由上文可知这会消耗不少的时间。 解决方法：利用抑制技术 (hold down) 和触发更新 (triggered update)。 抑制技术：距离被改为无穷大的路由在一段短时间 (180 s) 内其距离不允许被修改，这么做的目的是为了防止抖动。 触发更新：一旦出现路由变化，立即把变化的路由发送给邻居。原有的 30 s 发一次完整的路由表机制依然不变。","link":"/2021/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-RIP-%E5%8D%8F%E8%AE%AE%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"网络编程笔记(七)-制作 HTTP 服务器端","text":"网络编程笔记(七)-制作 HTTP 服务器端 代码及注释如下，需要基础的 HTTP 知识才能理解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;pthread.h&gt;#define BUF_SIZE 1024#define SMALL_BUF 100void *request_handler(void *arg); // 线程入口函数void send_data(FILE *fp, char *ct, char *file_name); // 向浏览器客户端发送数据char *content_type(char *file); // 数据类型void send_error(FILE *fp);void error_handling(char *message);int main(int argc, char *argv[]) { int serv_sock, clnt_sock; struct sockaddr_in serv_adr, clnt_adr; int clnt_adr_size; char buf[BUF_SIZE]; pthread_t t_id; if (argc != 2) { printf(&quot;Usage : %s &lt;port&gt; \\n&quot;, argv[0]); exit(1); } if ((serv_sock = socket(PF_INET, SOCK_STREAM, 0)) == -1) error_handling(&quot;bind error&quot;); memset(&amp;serv_adr, 0, sizeof(serv_adr)); serv_adr.sin_family = AF_INET; serv_adr.sin_addr.s_addr = htonl(INADDR_ANY); serv_adr.sin_port = htons(atoi(argv[1])); if (bind(serv_sock, (struct sockaddr *)&amp;serv_adr, sizeof(serv_adr)) == -1) { error_handling(&quot;bind error&quot;); } if (listen(serv_sock, 20) == -1) { error_handling(&quot;listen error&quot;); } while (1) { clnt_adr_size = sizeof(clnt_adr); clnt_sock = accept(serv_sock, (struct sockaddr *)&amp;clnt_adr, &amp;clnt_adr_size); printf(&quot;connection request : %s %d\\n&quot;, inet_ntoa(clnt_adr.sin_addr), ntohs(clnt_adr.sin_port)); pthread_create(&amp;t_id, NULL, request_handler, &amp;clnt_sock); pthread_detach(t_id); } close(serv_sock); return 0;}void *request_handler(void *arg) { int clnt_sock = *((int *)arg); char req_line[SMALL_BUF]; FILE *clnt_read; FILE *clnt_write; char method[10]; char ct[15]; char file_name[30]; //将套接字转换为标准I/O clnt_read = fdopen(clnt_sock, &quot;r&quot;); clnt_write = fdopen(dup(clnt_sock), &quot;w&quot;); // 复制文件描述符，实现半关闭模型 fgets(req_line, SMALL_BUF, clnt_read); // 保存请求行数据 if (strstr(req_line, &quot;HTTP/&quot;) == NULL) { // 查看是否为HTTP提出的请求 send_error(clnt_write); fclose(clnt_read); fclose(clnt_write); return NULL; } strcpy(method, strtok(req_line, &quot; /&quot;)); // 请求方式 strcpy(file_name, strtok(NULL, &quot; /&quot;)); // 请求的文件名 strcpy(ct, content_type(file_name)); // 请求内容类型 if (strcmp(method, &quot;GET&quot;) != 0) { // 是否为GET请求 send_error(clnt_write); fclose(clnt_read); fclose(clnt_write); return NULL; } fclose(clnt_read); send_data(clnt_write, ct, file_name); // 服务端响应消息}void send_data(FILE *fp, char *ct, char *file_name) { char protocol[] = &quot;HTTP/1.0 200 OK\\r\\n&quot;; // 状态行(用HTTP1.1版本进行响应，你的请求已经正确处理) char server[] = &quot;Server:Linux Web Server \\r\\n&quot;; // 服务端名 char cnt_len[] = &quot;Content-length:2048\\r\\n&quot;; // 数据长度不超过2048 char cnt_type[SMALL_BUF]; char buf[BUF_SIZE]; FILE *send_file; sprintf(cnt_type, &quot;Content-type:%s\\r\\n\\r\\n&quot;, ct); // 两个\\r\\n是因为头部行和正文之间有一个空行 send_file = fopen(file_name, &quot;r&quot;); // 打开本地文件 if (send_file == NULL) { send_error(fp); return; } fputs(protocol, fp); // 发送状态行 // 发送头部行 fputs(server, fp); fputs(cnt_len, fp); fputs(cnt_type, fp); while (fgets(buf, BUF_SIZE, send_file) != NULL) { // 发送正文（HTML对象） fputs(buf, fp); fflush(fp); } fflush(fp); fclose(fp); // 服务端响应客服端请求后立即断开连接（短链接）}char *content_type(char *file) { char extension[SMALL_BUF]; char file_name[SMALL_BUF]; strcpy(file_name, file); strtok(file_name, &quot;.&quot;); strcpy(extension, strtok(NULL, &quot;.&quot;)); // 文件拓展名 if (!strcmp(extension, &quot;html&quot;) || !strcmp(extension, &quot;htm&quot;)) { return &quot;text/html&quot;; } else { return &quot;text/plain&quot;; }}void send_error(FILE *fp) { char protocol[] = &quot;HTTP/1.0 400 Bad Request\\r\\n&quot;; // 请求文件不存在 char server[] = &quot;Server:Linux Web Server \\r\\n&quot;; char cnt_len[] = &quot;Content-length:2048\\r\\n&quot;; char cnt_type[] = &quot;Content-type:text/html\\r\\n\\r\\n&quot;; char content[] = &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;NETWORK&lt;/title&gt;&lt;/head&gt;&quot; &quot;&lt;body&gt;&lt;font size=+5&gt;&lt;br&gt;br error filename request!&quot; &quot;&lt;/font&gt;&lt;body&gt;&lt;html&gt;&quot;; fputs(protocol, fp); fputs(server, fp); fputs(cnt_len, fp); fputs(cnt_type, fp); fflush(fp);}void error_handling(char *message) { fputs(message, stderr); fputs(&quot;\\n&quot;, stderr); exit(1);} 参考资料https://cloud.tencent.com/developer/article/1350710","link":"/2021/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%B8%83-%E5%88%B6%E4%BD%9C-HTTP-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/"},{"title":"网络编程笔记(四)-套接字选项和 UDP","text":"网络编程笔记(四)-套接字选项和 UDP 参考《UNIX网络编程》第 7、8 章，《TCP/IP 网络编程》 第 9 章。 套接字选项有很多方法来获取和设置影响套接字的选项： getsockopt 和 setsockopt 函数； fcntl 函数； ioctl 函数。 getsockopt 和 setsockopt1234#include &lt;sys/socket.h&gt;// 均返回：若成功则为0，若出错则为-1.int getsockopt(int sockfd int level, int optname, void *optval, socklen_t *optlen); int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen); 参数： sockfd：指向一个打开的套接字描述符 level：指定系统中解释选项的代码或为通用套接字代码，或为某个特定于协议的代码（IPV4、IPV6、TCP、SCTP）。 optname：选项名。 *optval：指向某个变量的指针。对于 setsockopt 它是值参数，从 *optval 中取得选项待设置的新值。对于 getsockopt 它是值-结果参数，把已获取的选项当前值存放到 *optval 中。 optlen：*optval 的大小由它指定。 套接字选项粗分为两大基本类型： 标志选项：启用或禁止某个特性的二元选项。*optval 为 0 表示禁止，不为 0 表示启用。 值选项：取得并返回我们可以设置或检查的特定值的选项。 一些套接字选项SO_RCVBUF &amp; SO_SNDBUF：I/O 缓冲大小相关 SO_RCVBUF：输入缓冲大小相关可选项 SO_SNDBUF：输出缓冲大小相关可选项 12n = 220 * 1024;setsockapt(sockfd, SOL_SOCKET, SO_RCVBUF, &amp;n, sizeof(n)); 对于 TCP 来说，套接字接收缓冲区中可用空间的的大小限定了 TCP 通告对端的窗口大小。TCP 套接字接收缓冲区不可能溢出，因为不允许对端发出超过本端所通告窗口大小的数据。 UDP 是没有流量控制的：较快地发送端可以很容易地淹没较慢地接收端。 SO_REUSEADDR：重用端口号SO_REUSEADDR 允许 TIME-WAIT 状态下套接字端口号被重用。 它与四次握手中的 TIME-WAIT 状态有关：若服务器先断开连接，则无法立即重新运行，因为套接字在 TIME-WAIT 状态时相应端口号被占用，bind 会失败。下面的代码解决了这个问题。 123optlen = sizeof(option); option = TRUE; setsockopt(serv_sock, SOL_SOCKET, SO_RESUREADDR, (void *)&amp;option, optlen); 7.5.11 P165：所有 TCP 服务器都应该指定本套接字选项，以允许服务器重新启动时 bind 成功。 补充：为什么需要 TIME-WAIT： 在 TIME-WAIT 状态，A 可以继续接收 B 的信息。如果没有 TIME-WAIT，A 发送 ACK 后立即消除套接字，但是 ACK 丢失了，则 B 永远无法接收到 A 的 ACK，会不断试图重传 FIN（B 认为自己发送的 FIN 没有到达 A）。 TCP_NODELAYNagle 算法：防止数据包过多造成网络过载。 立即发送一个数据段，即使发送缓冲区只有一个字节。 只有收到上一个数据段的确认或者发送缓冲区中数据超过 MSS，才可以发送下一个数据段。 对于即时性要求高的地方，如，Window方式的鼠标操作，要关闭Nagle 算法。 禁用 Nagle 算法只需将套接字可选项 TCP_NODELAY 改为 1。 12int opt_val = 1; // 禁用 Nagle 算法setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, (void *)&amp;opt_val, sizeof(opt_val)); fcntl 函数1234#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;int fcntl(int fd, int cmd, .../* int arg */); fcntl (file control) 可执行各种描述符控制操作，提供了与网络编程相关的如下特性： 非阻塞式 I/O：通过使用 F_SETFL 命令设置 O_NONBLOCK 文件状态标志，我们可以把一个套接字设置为非阻塞型。 信号驱动 I/O：通过使用 F_SETFL 命令设置 O_ASYNC 文件状态标志，我们可以把一个套接字设置成一旦其状态发生变化，内核就产生一个 SIGIO 信号。 F_SETOWN 命令允许我们指定用于接收 SIGIO 和 SIGURG 信号的套接字属主（进程 ID 或进程组 ID）。 总结 许多 TCP 服务器设置 SO_KEEPALIVE 套接字选项以自动终止一个半开连接。 SO_LINGER 套接字使得我们能够更好的地控制 close 函数的返回时机，允许我们强制发送 RST 而不是 TCP 的四分组连接终止序列。 每个 TCP 套接字和 SCTP 套接字都有一个发送缓冲区和接收缓冲区，每个 UDP 套接字都有一个接收缓冲区。SO_SNDBUF 和 SO_RCVBUF 套接字选项允许我们改变这些缓冲区的大小。这两个选项最常见的用途是长肥管道上的批量数据传送。 基本 UDP 套接字编程UDP 客户/服务器原理UDP是无连接不可靠的数据报协议。典型的 UDP 客户/服务器程序中，客户不与服务器建立连接，而是只管使用 sendto 给服务器发送数据报；服务器也不接受来自客户的连接，只管调用 recvfrom 函数等待客户数据的到达。 使用 UDP 编写的一些常见应用程序有：DNS（域名系统）、NFS（网络文件系统）、SNMP（简单网络管理协议）。 recvfrom 和 sendto 函数12345678#include &lt;sys/socket.h&gt;// 均返回：若成功则返回读或写的字节大小，若出错则返回-1ssize_t recvform(int sockfd, void *buff , size_t nbytes, int flags, struct sockaddr *from , socklen_t *addrlen);ssize_t sendto(int sockfd, const void *buff , size_t nbytes, int flags, const struct sockaddr *to , socklen_t addrlen); 参数： 前三个参数 sockfd、buff、nbytes 等同于 read 和 write 的三个参数：描述符、指向读入/写出缓冲区的指针、读/写字节数。 flags：这里暂时把 flags 置为 0。 recvfrom 的 from：指向一个由该函数返回时候填写的数据报发送者的协议地址的套接字地址结构，填写的字节数在 addrlen（值-结果参数）。recvfrom 的参数 from、addrlen 类似 accept 的最后两个参数。 sendto 的 to：指向一个含有数据报接收者的协议地址（IP 地址和端口号）的套接字地址结构，大小由 addrlen 参数指定。sendto 的参数 to、addrlen 类似 connect 的最后两个参数。 UDP 回射服务程序和客户程序服务程序 udpcliserv/udpserv01.c 1234567891011121314151617181920212223242526272829#include &quot;../lib/unp.h&quot;void dg_echo(int sockfd, SA *pcliaddr, socklen_t clilen) { int n; socklen_t len; char mesg[MAXLINE]; for (;;) { len = clilen; n = Recvfrom(sockfd, mesg, MAXLINE, 0, pcliaddr, &amp;len); Sendto(sockfd, mesg, n, 0, pcliaddr, len); }}int main(int argc, char **argv) { int sockfd; struct sockaddr_in servaddr, cliaddr; sockfd = Socket(AF_INET, SOCK_DGRAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); servaddr.sin_port = htons(SERV_PORT); Bind(sockfd, (SA *)&amp;servaddr, sizeof(servaddr)); dg_echo(sockfd, (SA *)&amp;cliaddr, sizeof(cliaddr));} 客户程序 udpcliserv/udpcli01.c 12345678910111213141516171819202122232425262728293031323334#include &quot;../lib/unp.h&quot;void dg_cli(FILE *fp, int sockfd, const SA *pservaddr, socklen_t servlen) { int n; char sendline[MAXLINE], recvline[MAXLINE + 1]; while (Fgets(sendline, MAXLINE, fp) != NULL) { Sendto(sockfd, sendline, strlen(sendline), 0, pservaddr, servlen); // 注意recvfrom的最后两个参数为NULL，不关心数据发送者的协议地址 n = Recvfrom(sockfd, recvline, MAXLINE, 0, NULL, NULL); recvline[n] = 0; /* null terminate */ Fputs(recvline, stdout); }}int main(int argc, char **argv) { int sockfd; struct sockaddr_in servaddr; if (argc != 2) err_quit(&quot;usage: udpcli &lt;IPaddress&gt;&quot;); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_port = htons(SERV_PORT); Inet_pton(AF_INET, argv[1], &amp;servaddr.sin_addr); sockfd = Socket(AF_INET, SOCK_DGRAM, 0); dg_cli(stdin, sockfd, (SA *)&amp;servaddr, sizeof(servaddr)); exit(0);} 大多数 TCP 服务器是并发的，大多数 UDP 服务器是迭代的。 每个 UDP 套接字都有一个接收缓冲区，当进程调用 recvfrom 时，缓冲区中的下一个数据报以 FIFO （先进先出）顺序返回给进程。 UDP 初始回射程序的问题 数据报丢失数据报丢失导致客户永久阻塞于 recvfrom 调用，设置一个超时可以解决这个问题。 验证接收到的响应：重写 dg_cli 函数，分配另一个套接字地址结构用于存放由 recvfrom 返回的结构，然后比较返回的地址。保留来自数据报所发往的服务器的应答，而忽略任何其他数据报。 1234567891011121314151617181920212223242526#include &quot;../lib/unp.h&quot;void dg_cli(FILE *fp, int sockfd, const SA *pservaddr, socklen_t servlen) { int n; char sendline[MAXLINE], recvline[MAXLINE + 1]; socklen_t len; struct sockaddr *preply_addr; preply_addr = Malloc(servlen); // 分配另一个套接字地址结构 while (Fgets(sendline, MAXLINE, fp) != NULL) { Sendto(sockfd, sendline, strlen(sendline), 0, pservaddr, servlen); len = servlen; // 注意这里与 dg_cli 相比，recvfrom的最后2个参数不为0，设为新分配的套接字地址 n = Recvfrom(sockfd, recvline, MAXLINE, 0, preply_addr, &amp;len); // 比较返回的地址 if (len != servlen || memcmp(pservaddr, preply_addr, len) != 0) { printf(&quot;reply from %s (ignored)\\n&quot;, Sock_ntop(preply_addr, len)); continue; } recvline[n] = 0; /* null terminate */ Fputs(recvline, stdout); }} 服务器进程未运行 异步错误：服务器主机响应 “port unreachable” ICMP消息，不过这个 ICMP 错误不返回给客户进程，客户永远阻塞于 recvfrom 调用。 对于一个 UDP 套接字，由它引发的异步错误却并不返回给它，除非它已连接。这需要给 UDP 套接字调用 connect。 UDP 的 connect 函数UDP 的 connect 不同于TCP，没有三次握手的过程，内核只是检查是否存在立即可知的错误，记录对端 IP 地址和端口号，然后立即返回到调用进程。对于已连接的 UDP 套接字，与默认未连接的 UDP 套接字相比，有以下 3 个变化： 不能再给输出操作指定目的 IP 地址和端口号——不使用 sendto，而改用 write 或 send。 不必使用 recvfrom 以获悉数据报的发送者，而改用 read、recv 或 recvmsg。 已连接 UDP 套接字引发的异步错误会返回给它们所在的进程，而未连接的 UDP 套接字不接收任何异步错误。 小结：UDP 客户进程或服务器进程只在使用自己的 UDP 套接字与确定的唯一对端通信时，才可以调用 connect。调用 connect 通常是 UDP 客户。 将初始的 UDP 客户函数 dg_cli 修改：调用 connect，并以 read 和 write 代替 recvfrom 和 sendto。 1234567891011121314void dg_cli(FILE *fp, int sockfd, const SA *pservaddr, socklen_t servlen) { int n; char sendline[MAXLINE], recvline[MAXLINE + 1]; Connect(sockfd, (SA *)pservaddr, servlen); while (Fgets(sendline, MAXLINE, fp) != NULL) { Write(sockfd, sendline, strlen(sendline)); n = Read(sockfd, recvline, MAXLINE); recvline[n] = 0; /* null terminate */ Fputs(recvline, stdout); }} 使用 select 函数的 TCP 和 UDP 回射服务器程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/* include udpservselect01 */#include &quot;../lib/unp.h&quot;int main(int argc, char **argv) { int listenfd, connfd, udpfd, nready, maxfdp1; char mesg[MAXLINE]; pid_t childpid; fd_set rset; ssize_t n; socklen_t len; const int on = 1; struct sockaddr_in cliaddr, servaddr; void sig_chld(int); /* create listening TCP socket */ listenfd = Socket(AF_INET, SOCK_STREAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); servaddr.sin_port = htons(SERV_PORT); Setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on)); // 设置SO_REUSEADDR套接字选项以防该端口已有连接存在。 Bind(listenfd, (SA *)&amp;servaddr, sizeof(servaddr)); Listen(listenfd, LISTENQ); /* create UDP socket */ udpfd = Socket(AF_INET, SOCK_DGRAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); servaddr.sin_port = htons(SERV_PORT); // 无需调用bind之前设置SO_REUSEADDR套接字选项，因为TCP端口独立于UDP端口 Bind(udpfd, (SA *)&amp;servaddr, sizeof(servaddr)); /* end udpservselect01 */ /* include udpservselect02 */ Signal(SIGCHLD, sig_chld); /* must call waitpid() */ FD_ZERO(&amp;rset); maxfdp1 = max(listenfd, udpfd) + 1; for (;;) { FD_SET(listenfd, &amp;rset); FD_SET(udpfd, &amp;rset); if ((nready = select(maxfdp1, &amp;rset, NULL, NULL, NULL)) &lt; 0) { if (errno == EINTR) continue; /* back to for() */ else err_sys(&quot;select error&quot;); } if (FD_ISSET(listenfd, &amp;rset)) { len = sizeof(cliaddr); connfd = Accept(listenfd, (SA *)&amp;cliaddr, &amp;len); if ((childpid = Fork()) == 0) { /* child process */ Close(listenfd); /* close listening socket */ str_echo(connfd); /* process the request */ exit(0); } Close(connfd); /* parent closes connected socket */ } if (FD_ISSET(udpfd, &amp;rset)) { len = sizeof(cliaddr); n = Recvfrom(udpfd, mesg, MAXLINE, 0, (SA *)&amp;cliaddr, &amp;len); Sendto(udpfd, mesg, n, 0, (SA *)&amp;cliaddr, len); } }}/* end udpservselect02 */ 总结 UDP 套接字可能产生异步错误（分组发送完一段时间后才报告的错误），TCP 套接字总是给应用进程报告这些错误，但是 UDP 套接字必须已连接才能接收这些错误。 UDP 没有流量控制，但这一般不成问题，因为许多 UDP 应用程序是用请求-应答模式构造的，而且不用传送大量数据。 参考资料https://wuhlan3.gitee.io/wuhlan3/2021/08/06/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%83%EF%BC%89 https://blog.csdn.net/zzxiaozhao/article/details/102662861 https://www.cnblogs.com/Anker/p/3265058.html","link":"/2021/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%9B-%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%89%E9%A1%B9%E5%92%8CUDP/"},{"title":"网络编程笔记(二)-TCP客户服务器示例","text":"网络编程笔记(二)-TCP客户/服务器示例 参考《UNIX网络编程》第 5 章，《TCP/IP 网络编程》 第 10 章。 回射（echo）客户/服务器原理概述 并发服务器端实现模型和方法： 多进程服务器：通过创建多个进程提供服务。 多路复用服务器：通过捆绑并统一管理 I/O 对象提供服务（select 和 epoll）。 多线程服务器：通过生成与客户端等量的线程提供服务。 这里学习第一种——多进程服务器。 需要用到的 linux 命令： ps au ：查看进程 ID 和状态。 ./可执行文件 &amp;：后台运行某个进程。 原始并发服务器的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;signal.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/socket.h&gt;#define BUF_SIZE 100#define LISTENQ 5void error_handling(char *message);void str_echo(int sockfd);int main(int argc, char **argv){ int listenfd, connfd; pid_t childpid; socklen_t clilen; struct sockaddr_in cliaddr, servaddr; if (argc != 2) { printf(&quot;Usage : %s &lt;port&gt;\\n&quot;, argv[0]); exit(1); } listenfd = socket(AF_INET, SOCK_STREAM, 0); if (listenfd == -1) { error_handling(&quot;socket error&quot;); } bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); servaddr.sin_port = htons(atoi(argv[1])); if (bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)) == -1) error_handling(&quot;bind() error&quot;); if (listen(listenfd, LISTENQ) == -1) error_handling(&quot;listen() error&quot;); for (;;) { clilen = sizeof(cliaddr); connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;clilen); if (connfd == -1) continue; else printf(&quot;new client %d... \\n&quot;, connfd); if ((childpid = fork()) == 0) { /* child process */ close(listenfd); /* close listening socket */ str_echo(connfd); /* process the request */ // close(connfd); printf(&quot;%d client disconnected...&quot;, connfd); exit(0); } else if (childpid == -1) { close(connfd); puts(&quot;fail to fork&quot;); continue; } close(connfd); /* parent closes connected socket */ }}void str_echo(int sockfd){ ssize_t n; char buf[BUF_SIZE]; while ((n = read(sockfd, buf, BUF_SIZE)) &gt; 0) write(sockfd, buf, n);}void error_handling(char *message){ fputs(message,stderr); fputs(&quot;\\n&quot;,stderr); exit(1); } 客户端： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;signal.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/socket.h&gt;#define BUF_SIZE 100void error_handling(char *sendline);void str_cli(FILE *fp, int sockfd);int main(int argc, char **argv){ int sockfd; struct sockaddr_in serv_addr; if (argc != 3) { printf(&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\\n&quot;, argv[0]); exit(1); } sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd == -1) { error_handling(&quot;socket() error&quot;); } bzero(&amp;serv_addr, sizeof(serv_addr)); serv_addr.sin_family = AF_INET; serv_addr.sin_addr.s_addr = inet_addr(argv[1]); serv_addr.sin_port = htons(atoi(argv[2])); if (connect(sockfd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)) == -1) error_handling(&quot;connect() error\\r\\n&quot;); else printf(&quot;Connected....\\n&quot;); str_cli(stdin, sockfd); /* do it all */ close(sockfd); exit(0);}void str_cli(FILE *fp, int sockfd){ int str_len = 0; while (1) { char sendline[BUF_SIZE], recvline[BUF_SIZE]; printf(&quot;Input sendline(Q to quit):\\n&quot;); fgets(sendline, BUF_SIZE, stdin); if (!strcmp(sendline, &quot;q\\n&quot;) || !strcmp(sendline, &quot;Q\\n&quot;)) break; write(sockfd, sendline, strlen(sendline)); str_len = read(sockfd, sendline, BUF_SIZE - 1); sendline[str_len] = 0; printf(&quot;sendline from server : %s \\n&quot;, sendline); }}void error_handling(char *sendline){ fputs(sendline, stderr); fputs(&quot;\\n&quot;, stderr); exit(1);} POSIX 信号处理信号的定义信号（signal）就是告知某个进程发生了某个事件的通知；信号通常是异步发生的，也就是说接受信号的进程不知道信号的准确发生时刻。 信号可以： 一个进程发给另一个进程； 内核发给某个进程。 信号的处置每个信号都有一个与之关联的处置，即收到特定信号时的处理方法；可以通过调用 sigaction 函数来设定一个信号的处置。 处置方法有三种选择： 提供一个函数，只要有特定信号发生它就被调用。这样的函数称为信号处理函数（signal handler），这种行为称为捕获（catching）信号。有两个信号 SIGKILL 和 SIGSTOP 不能被捕获。信号处理函数由信号值这个单一的整数参数来调用，且没有返回值，其函数原型如下： 1void handler(int signo); 可以把某个信号的处置方法设定为 SIG_IGN 来忽略（ignore）它。SIDKILL 和 SIDSTOP 这两个信号不能被忽略； 可以把某个信号的处置方法设定为 SIG_DEF 来启用它的默认（default）处置，默认初值通常是收到信号后终止进程。另有个别信号的默认处置为忽略，如 SIGCHLD 和 SIGURG。 第一种处置方法建立信号处置的 POSIX 方法就是调用 sigaction 函数，但比较复杂（简单方法是调用自带的 signal 函数）。POSIX 明确规定了调用 sigaction 时的语义定义。解决方法是定义自己 signal——只是调用 sigaction 函数，以所期望的 POSIX 语义提供一个简单的接口。 UNIX 系统自带的 signal 函数，历史悠久，不太稳定，也叫信号注册函数。 123456#include &lt;signal.h&gt; // 功能：返回之前注册的函数指针。// 参数：int signo，void (*func)(int)// 返回类型：参数为int型，返回为void型函数指针void (*signal(int signo, void (*func)(int)))(int); 一些常见的信号值： SIGALARM：已到通过 alarm 函数注册的时间 SIGINT：输入 CTRL + C SIGCHILID：子进程终止 利用 sigaction 函数进行信号处理，可以代替 signal，也更加稳定（POSIX 明确规定了调用 sigaction 时的信号语义）。signal 函数在 UNIX 的不同系列操作系统中可能存在区别，但是 sigaction 完全相同。 12345678910#include &lt;signal.h&gt; /*参数： signo：传递的信号 act：对应于第一个参数的信号处理函数 oldact：获取之前注册的信号处理函数指针，若不需要则传递0返回值：成功返回0，失败返回-1*/ int sigaction(int signo, const struct sigaction *act, struct sigaction *oldact); 声明并初始化结构体以调用上述函数： 12345struct sigaction { void (* sa_handler)(int); // 保存信号处理函数的指针 sigset_t sa_mask; // 可初始化为0 int sa_flags; // 可初始化为0}; 第二种处置方法把某个信号的处置方法设定为 SIG_IGN 来忽略（ignore）它。SIDKILL 和 SIDSTOP 这两个信号不能被忽略。 第三种处置方法可以把某个信号的处置方法设定为 SIG_DEF 来启用它的默认（default）处置，默认处置通常是收到信号后终止进程。有个别信号的默认处置为忽略，如 SIGCHLD 和 SIGURG。 处理 SIGCHLD 信号（僵死进程）僵死进程的概念进程 ID：创建时进程都会从操作系统获得进程 ID，其值为大于 2 的整数（1 为分配给操作系统启动后的首个进程）。 通过 fork 函数创建进程：复制正在运行的、调用 fork 函数的进程，父子进程拥有完全独立的内存结构。两个进程都执行 fork 函数以后的语句，共享同一代码。 初始服务器的代码存在僵死进程问题。 僵死进程：目的是为了维护子进程的信息（进程ID，终止状态，资源利用信息），以便父进程在以后某个时候存取。如果父进程未主动要求获得子进程的结束状态值，操作系统将让子进程长时间处于僵死状态。僵死进程占用内存中的空间，最终可能导致耗尽内核资源。 启动初始服务器： 启动初始客户端并连接服务器，可以看到，断开连接后出现僵死进程（Z）： 销毁僵死进程的方法wait 函数利用 wait 函数销毁僵死进程的原理：父进程主动请求获取子进程的返回值。 1234#include &lt;sys/wait.h&gt; // 返回值：成功时返回终止的子进程ID，失败返回-1 pid_t wait(int * statloc); wait 和 waitpid 均返回两个值：已终止子进程的进程 ID 号，以及通过 statloc 指针返回的子进程终止状态（一个整数）。子进程终止状态需要通过下列宏分离： WIFEXITED：子进程正常终止时返回 TRUE。 WEXITSTATUS：返回子进程的返回值。 1234wait(&amp;status);if (WIFEXITED(status)){ printf(&quot;Child pass num : %d&quot;, WEXITSTATUS(status)); } waitpid 函数wait 的局限性：调用 wait 函数时，如果没有已终止的子进程，那么程序将阻塞（Blocking）直到有子进程终止。wait 函数不能处理客户端与服务器同时建立多个连接的情况（《UNIX 网络编程》P109-111） wait 函数会引起程序阻塞，但 waitpid 函数不会阻塞，而且可以指定等待的目标子进程，options 指定为 WNOHANG 时没有终止子进程也不会阻塞。 12345678910111213141516171819#include &lt;sys/wait.h&gt; /*参数： pid：等待终止的目标子进程ID，若传递-1，则与wait函数相同，等待任意子进程 statloc：与wait函数的statloc参数一致 options：传递头文件sys/wait.h中声明的常量 WNOHANG，即使没有终止子进程也不会阻塞，而是返回0并退出函数*/// 返回值：成功时返回终止子进程ID，失败返回-1 pid_t waitpid(pid_t pid, int * statloc, int options);// Example:while (!waitpid(-1, &amp;status, WNOHANG)){ sleep(1); puts(&quot;sleep 1sec.&quot;); } if (WIFEXITED(status)){ printf(&quot;child send %d \\n&quot;,WEXITSTATUS(status));} 使用 signal 消除僵死进程 在服务器程序中调用 listen 之后添加信号注册函数 signal： 1signal(SIGCHLD, sig_chld); 编写信号处理函数 sig_chld： 1234567891011121314151617// 版本1：使用 waitvoid sig_chld(int signo){ pid_t pid; int stat; pid = wait(&amp;stat); printf(&quot;child %d terminated\\n&quot;,pid); return;}// 版本2，使用 waitpidvoid sig_chld(int signo){ pid_t pid; int stat; while( (pid = waitpid(-1, &amp;stat, WHOHANG)) &gt; 0 ) printf(&quot;child %d terminated\\n&quot;,pid); return;} 可以看到，没有僵死进程： 使用 sigaction 消除僵死进程类似 signal，在服务器程序中调用 listen 之后添加以下代码，使用同样的信号处理函数 sig_chlid。 1234567// 处理僵死进程 struct sigaction act; int state; act.sa_handler = sig_chld; sigemptyset(&amp;act.sa_mask); act.sa_flags = 0; state = sigaction(SIGCHLD, &amp;act, 0); 使用 waitpid 而不是 wait 的原因——UNIX 信号不排队 一个客户与并发服务器建立 5 个连接时，建立一个信号处理函数并在其中调用的 wait 不足以防止出现僵死进程（只能终止一个进程）。原因：所有 5 个信号都在信号处理函数执行之前产生，而信号处理函数只执行了一次，因为 Unix 信号一般是不排队的。正确的解决方法是调用 waitpid 而不是 wait：在一个循环内调用 waitpid，以获取所有已终止子进程的状态。WHOHANG 告知 waitpid 没有已终止子进程时也不要阻塞。 1234567void sig_chld(int signo){ pid_t pid; int stat; while( (pid = waitpid(-1, &amp;stat, WHOHANG)) &gt; 0 ) printf(&quot;child %d terminated\\n&quot;,pid); return;} 小结 当 fork 子进程时，必须捕获 SIGCHLD 信号。 当捕获信号时，必须处理被中断的系统调用。(P107) SIGCHLD 的信号处理函数必须正确编写，应使用 waitpid 函数以免留下僵死进程。 服务器进程终止复习 TCP 四次握手关闭连接的过程： 模拟服务器进程崩溃时，客户端会发生什么： 找到服务器子进程的进程 ID，并执行 kill 命令杀死它。此时被杀死的服务器子进程的所有打开着的描述符都将关闭。这就导致服务器向客户端发送一个 FIN，而客户端会向服务器响应一个 ACK。是四次握手关闭连接的前半部分。 SIGCHLD 信号被发送给服务器父进程，僵死子进程得到正确处理。然而问题是客户进程此时阻塞在 fgets 函数上，等待从终端接收一行文本。 此时在另一个窗口运行 netstat 命令，可以看到 TCP 连接终止序列的前半部分已经完成。 服务器终端： 12345678910111213141516[qhn@Tommy tcpcliserv]$ ps auUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 1910 0.1 0.3 341764 7732 tty1 Ssl+ 19:26 0:04 /usr/bin/X :0 -background none -noreset -audit 4 -verbose -auth /runqhn 3840 0.0 0.1 117096 2772 pts/0 Ss 19:44 0:00 /usr/bin/bashqhn 6772 0.0 0.0 6388 544 pts/0 S 20:30 0:00 ./tcpserv04qhn 7240 0.0 0.1 116968 3184 pts/1 Ss 20:32 0:00 /usr/bin/bashqhn 8104 0.0 0.0 6396 396 pts/1 S+ 20:39 0:00 ./tcpcli01 127.0.0.1qhn 8105 0.0 0.0 6388 104 pts/0 S 20:39 0:00 ./tcpserv04qhn 8159 0.0 0.0 155448 1872 pts/0 R+ 20:39 0:00 ps au[qhn@Tommy tcpcliserv]$ kill 8105[qhn@Tommy tcpcliserv]$ child 8105 terminated[qhn@Tommy tcpcliserv]$ netstat -a | grep 9877tcp 0 0 0.0.0.0:9877 0.0.0.0:* LISTEN tcp 0 0 localhost:9877 localhost:51616 FIN_WAIT2 tcp 1 0 localhost:51616 localhost:9877 CLOSE_WAIT 此时，在客户端键入一行文本 “another line”，str_cli 调用 written，客户 TCP 将数据发送给服务器（FIN 的接收并没有告知客户 TCP 服务器进程已经终止，但实际上在本例中服务器进程已经被杀死了）。由于服务器先前打开的连接套接字已经终止，于是响应以一个 RST。 客户进程之前阻塞在 fgets 上，看不到这个 RST。客户发送 “another line” 后立即调用 readline，直接收到终止符 EOF（因为之前客户端收到了 FIN），这是客户未预期的，所以客户端会提示以出错信息 “server terminated prematurely”（服务器过早终止）退出。 客户端终端： 12345678[qhn@Tommy tcpcliserv]$ ./tcpcli01 127.0.0.1hellohellohihianother linestr_cli: server terminated prematurely[qhn@Tommy tcpcliserv]$ 本例的问题在于：当 FIN 到达客户套接字时，客户正阻塞在 fgets 调用上，不能够及时处理。客户端实际上在应对两个描述符——套接字和用户输入。它不能单纯阻塞在这两个源中某个特定源的输入上，而是应该同时阻塞在这两个源的输入上。这正是 select 和 poll 这两个函数的目的之一。 服务器主机崩溃在不同的主机上运行服务器和客户端，先启动服务器，再启动客户端，确定它们正常启动后，从网络上断开服务器主机，并在客户键入一行文本。 当服务器主机崩溃后（不是由操作员执行命令关机），已有的网络连接上不再发出任何东西。 此时客户键入一行文本，文本由 writen 写入内核，再由客户 TCP 作为一个数据分节发出。然后客户阻塞在 readline 调用，等待服务器回射应答。 此时用 tcpdump 就会发现，客户 TCP 持续重传数据分节，试图从服务器上接收一个 ACK。 既然客户阻塞在 readline 调用上，该调用会返回一个错误： 假设服务器已经崩溃，对客户的数据分节根本没有响应，返回错误 ETIMEDOUT； 如果某个中间路由器判定服务器已不可达，则该路由器会响应一个 “destination unreachable” （目的地不可达）ICMP 消息，返回错误为 **EHOSTUNREACH **或 ENETUNREACH。 本例的问题在于：想要知道服务器主机是否崩溃，只能通过客户向服务器主机发送数据来检验。如果想不发送数据就检测出服务器主机是否崩溃，需要使用 SO_KEEPALIVE 套接字选项。 服务器主机崩溃并重启服务器主机崩溃并重启时，在客户上键入一行文本。重启后，服务器 TCP 丢失了崩溃前所有连接信息，因此 TCP 对客户响应一个 RST（重置连接）。当客户 TCP 收到该 RST 时，客户正阻塞于 readline 调用，导致该调用返回 ECONNRESET 错误。 服务器主机关机服务器主机被操作员关机将会发生什么：Unix 系统关机时，init 进程会给所有进程发送一个 SIGTERM 信号（该信号可被捕获），等待一段固定时间（5~12s），然后给所有仍在运行的程序发送给一个 SIGKILL（该信号不能被捕获）。这么做的目的是，留出一小段时间给所有运行的进程来清除与终止。 如果不捕获 SIGTERM 信号并终止，服务器将由 SIGKILL 信号终止。当服务器子进程终止时，它的所有打开着的描述符都被关闭，这样又回到了服务器进程终止的问题。 数据格式在客户与服务器之间传递二进制值时，如果字节序不一样或所支持的长整数的大小不一致，将会出错。 3 个问题： 不同的实现以不同的格式存储二进制数——大端字节序与小端字节序。 不同的实现在存储相同的 C 数据类型上可能存在差异——大多数 32 位 Unix 系统使用 32 位表示长整数，而 64 位系统一般使用 64 位表示长整数。 不同的实现给结构打包的方式存在差异。因此，穿越套接字传送二进制结构绝不是明智的。 解决方法： 把所有的数值数据作为文本串来传递。 显式定义所支持数据类型的二进制格式（位数、大端或小端字节序），并以这样的格式在客户与服务器之间传递所有数据。远程过程调用（RPC）通常使用这种技术。 总结从简单的 echo 服务器开始，解决了以下问题： 处理僵死子进程——采用信号处理（signal，sigaction）。 服务器进程终止时，客户进程收到 FIN 但并不知道终止——使用 select、poll。 服务器主机崩溃时，必须通过客户向服务器发送数据才能检验—— SO_KEEPALIVE 套接字选项。 穿越套接字传送二进制结构绝不是明智的——把所有的数值数据作为文本串来传递。 参考资料https://www.cnblogs.com/soldierback/p/10690783.html https://blog.csdn.net/zzxiaozhao/article/details/102662861 https://wuhlan3.gitee.io/wuhlan3/2021/08/03/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%94%EF%BC%89","link":"/2021/10/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-2021-10-04-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%BA%8C-TCP%E5%AE%A2%E6%88%B7%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A4%BA%E4%BE%8B/"},{"title":"网络编程笔记(三)-I&#x2F;O复用：select和poll函数","text":"网络编程笔记(三)-I/O复用：select和poll函数 参考《UNIX网络编程》第 6 章，《TCP/IP 网络编程》 第 7、12 章。 I/O 模型I/O 复用的场合： 当客户处理多个描述符时（一般是交互式输入和网络套接字），必须使用I/O复用。 当客户同时处理多个套接字时，这种情况很少出现。 如果一个 TCP 服务器既要处理监听套接字，又要处理已连接套接字，一般就要使用 I/O 复用。 如果一个服务器既要处理 TCP，又要处理 UDP，一般就要使用 I/O 复用。 如果一个服务器要处理多个服务或多个协议，一般就要使用 I/O 复用。 UNIX 下可用的 5 种 I/O 模型： 阻塞式 I/O； 非阻塞式 I/O； I/O 复用（select 和 poll）； 信号驱动式 I/O（SIGIO）； 异步 I/O（POSIX 的 aio_系列函数）。 输入操作的 2 个阶段： 等待数据准备好（一般是等待数据从网络中到达，到达时被数据被复制到内核中的缓冲区）； 从内核向进程复制数据（把数据从内核缓冲区复制到应用进程缓冲区）。 前四种为同步 I/O，因为真正的 I/O 操作将阻塞进程。 select 函数定义和功能1234567891011121314#include &lt;sys/select.h&gt; #include &lt;sys/time.h&gt; /* 参数： maxfd：监视对象文件描述符数量（最大文件描述符+1） readset：是否存在待读取数据的文件描述符 writeset：是否可传输无阻塞数据的文件描述符 exceptset：是否发生异常的文件描述符 timeout：超时信息 （如果select发生了阻塞，那么就通过设置timeout防止这种情况） */// 返回值：若有就绪描述符则返回其数目，超时返回 0，失败返回 -1 int select(int maxfd, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval * timeout) 可读：是否存在套接字接收数据。 可写：无需阻塞传输数据的套接字有哪些。 异常：哪些套接字发生异常。 select 函数调用过程： 设置文件描述符，指定监视范围，设置超时。 调用 select 函数。 查看调用结果。 fd_set：设置文件描述符fd_set 数据类型的操作以位为单位进行。注册和更改值得操作由下列宏完成。 1234void FD_ZERO(fd_set *fdset); // 将fd_set变量得所有位初始化为0void FD_SET(int fd, fd_set *fdset); // 注册：将文件描述符fd置1void FD_CLR(int fd, fd_set *fdset); // 清除：将文件描述符fd置0void FD_ISSET(int fd, fd_set *fdset); // 判断文件描述符fd是否被设置为1 maxfd 和中间 3 个描述符集参数maxfd：指定待测试的描述符个数（待测试的最大描述符 +1，+1 是因为从 0 开始），描述符 0, 1, 2, … 一直到 maxfd - 1 都将被测试。 如果我们对 readset、writeset、exceptset 中的某一个条件不感兴趣，就可以把它设为空指针。 描述符集参数是值-结果参数。原来为 1 的所有位均变为 0，但发生变化的文件描述符对应位除外——值仍为 1 的文件描述符发生了变化。select 返回后使用 FD_ISSET 宏来测试 fd_set 数据类型。因此，每次重新调用 select 函数时，都得再次把所有描述符集内所关心的位置为 1。 struct timeval：超时时间1234struct timeval{ long tv_sec; // sec long tv_usec; // microsec}; 这个参数有三种选择： 永远等待下去：仅在有一个描述符准备好 I/O 时才返回。为此要将该参数设置为空。 等待一段固定时间（等待时间不超过这个固定时间）。为此要设置秒数和微秒数。 根本不等待：检查描述符后立即返回，这称为轮询（polling）。为此要设置秒数和微秒数均为 0。 描述符就绪条件对于每一列满足任何一行，该列的表头就准备好了。 str_cli 的两次修改初始的 str_cli 如下： 1234567891011121314#include &quot;unp.h&quot;void str_cli(FILE *fp, int sockfd) { char sendline[MAXLINE], recvline[MAXLINE]; while (Fgets(sendline, MAXLINE, fp) != NULL) { Writen(sockfd, sendline, strlen(sendline)); if (Readline(sockfd, recvline, MAXLINE) == 0) err_quit(&quot;str_cli: server terminated prematurely&quot;); Fputs(recvline, stdout); }} 第一次修改初始的 str_cli 问题是：当套接字发生某些事情时，客户可能阻塞与 fgets 调用。新版本改为阻塞于 select 调用——或是等待标准输入可读，或是等待套接字可读。 如果对端 TCP 发送数据，那么该套接字变为可读，并且 read 返回一个大于 0 的值（即读入数据的字节数） 如果对端 TCP 发送一个 FIN（对端进程终止），那么该套接字变为可读，并且read 返回 0（EOF） 如果对端 TCP 发送一个 RST（对端主机崩溃并重新启动），那么该套接字变为可读，并且 read 返回 -1，errno 含有确切的错误码。 1234567891011121314151617181920212223242526#include &quot;../lib/unp.h&quot;void str_cli(FILE *fp, int sockfd) { int maxfdp1; fd_set rset; // readset: 读描述符集 char sendline[MAXLINE], recvline[MAXLINE]; FD_ZERO(&amp;rset); for (;;) { FD_SET(fileno(fp), &amp;rset); // 打开标准IO文件指针fp FD_SET(sockfd, &amp;rset); // 打开套接字描述符 maxfdp1 = max(fileno(fp), sockfd) + 1; Select(maxfdp1, &amp;rset, NULL, NULL, NULL); if (FD_ISSET(sockfd, &amp;rset)) { /* socket is readable */ if (Readline(sockfd, recvline, MAXLINE) == 0) // EOF err_quit(&quot;str_cli: server terminated prematurely&quot;); Fputs(recvline, stdout); } if (FD_ISSET(fileno(fp), &amp;rset)) { /* input is readable */ if (Fgets(sendline, MAXLINE, fp) == NULL) return; /* all done */ Writen(sockfd, sendline, strlen(sendline)); } }} 这个版本的 str_cli 存在两个问题： 批量输入时，标准输入的 EOF 并不意味着同时也完成了从套接字的读入（套接字上还有数据在传送）。 混合使用 stdio 和 select 导致错误——select 并不知道 stdio 使用了缓冲区。fgets 返回一行写给服务器，随后 select 被调用以等待新的工作，而不管 stdio 缓冲区还有额外的输入待消费。 shutdown 函数1234#include &lt;sys/socket.h&gt;// 返回值：成功返回0，出错返回-1int shutdown(int sockfd, int howto) close 和 shutdown 对比： close 把描述符的引用计数减 1，仅在该计数变为 0 时才关闭套接字。 shutdown 可以不管引用计数，直接激发 TCP 的正常连接终止序列（四次握手）。 close 终止读和写两个方向的数据传输。shutdown 可以告诉对方自己已经完成了数据发送，即使对端仍有数据要发送。shutdown 可以只关闭其中一个流，而非同时断开两个流。 shutdown 的行为依赖于 howto 参数： SHUT_RD：断开输入流，关闭连接的读这一半——套接字中不再有数据可接收，进程不能再对这样的套接字调用任何读函数。可以把第二个参数指定为 SHUT_RD 防止环回复制。关闭SO_USELOOPBACK套接字选项也能防止回环 SHUT_WR：断开输出流：关闭连接的写这一半（半关闭，half-close）进程不能再对这样的套接字调用任何写函数。 SHUT_RDWR：同时断开 I/O 流，连接的读半部和写半部都关闭，等效于调用两次 shutdown。 第二次修改 使用 select：服务器关闭它那一段的连接就会通知我们。 使用 shutdown：废弃了以文本行为中心的代码，改而针对缓冲区操作。 123456789101112131415161718192021222324252627282930313233343536373839#include &quot;../lib/unp.h&quot;void str_cli(FILE *fp, int sockfd) { int maxfdp1, stdineof; // stdineof是一个初始化为0的新标志，只要该标志为0，每次在主循环我们总是select标准输入的可读性。 fd_set rset; char buf[MAXLINE]; int n; stdineof = 0; FD_ZERO(&amp;rset); for (;;) { if (stdineof == 0) FD_SET(fileno(fp), &amp;rset); // select标准输入的可读性 FD_SET(sockfd, &amp;rset); maxfdp1 = max(fileno(fp), sockfd) + 1; Select(maxfdp1, &amp;rset, NULL, NULL, NULL); if (FD_ISSET(sockfd, &amp;rset)) { /* socket is readable */ if ((n = Read(sockfd, buf, MAXLINE)) == 0) { if (stdineof == 1) // 在套接字读到EOF时，如果我们已在标准输入上遇到 EOF，那就是正常的终止 return; /* normal termination */ else // 如果没有在标准输入上遇到 EOF，那就是服务器进程已经过早终止。 err_quit(&quot;str_cli: server terminated prematurely&quot;); } Write(fileno(stdout), buf, n); } if (FD_ISSET(fileno(fp), &amp;rset)) { /* input is readable */ if ((n = Read(fileno(fp), buf, MAXLINE)) == 0) { stdineof = 1; // 标准输入上碰到EOF，将新标志置为1 Shutdown(sockfd, SHUT_WR); /* send FIN */ FD_CLR(fileno(fp), &amp;rset); continue; } Writen(sockfd, buf, n); // read和write：对缓冲区而不是文本行进行操作。 } }} TCP 回射服务器程序（修订版）服务器使用 select 的版本，避免了为每个客户创建一个新进程。 《TCP/IP网络编程》P203-P205 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;arpa/inet.h&gt;#include &lt;signal.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/select.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/wait.h&gt;#include &lt;unistd.h&gt;#define BUF_SIZE 100void error_handling(char *message);int main(int argc, char *argv[]) { int serv_sock, clnt_sock; char buf[BUF_SIZE]; struct sockaddr_in serv_adr; struct sockaddr_in clnt_adr; socklen_t adr_sz; fd_set reads, cpy_reads; struct timeval timeout; int fd_max, str_len, fd_num, i; if (argc != 2) { printf(&quot;Usage : %s &lt;port&gt;\\n&quot;, argv[0]); exit(1); } serv_sock = socket(PF_INET, SOCK_STREAM, 0); if (serv_sock == -1) { error_handling(&quot;socket error&quot;); } memset(&amp;serv_adr, 0, sizeof(serv_adr)); serv_adr.sin_family = AF_INET; serv_adr.sin_addr.s_addr = htonl(INADDR_ANY); serv_adr.sin_port = htons(atoi(argv[1])); if (bind(serv_sock, (struct sockaddr *)&amp;serv_adr, sizeof(serv_adr)) == -1) { error_handling(&quot;bind() error&quot;); } if (listen(serv_sock, 5) == -1) { error_handling(&quot;listen() error&quot;); } FD_ZERO(&amp;reads); FD_SET(serv_sock, &amp;reads); // 初始时，监听套接字是描述集中唯一的非0项 fd_max = serv_sock; // 这里不加1，下面select时就要加1，因为从0到fd_max-1 while (1) { cpy_reads = reads; timeout.tv_sec = 5; timeout.tv_usec = 5000; if ((fd_num = select(fd_max + 1, &amp;cpy_reads, 0, 0, &amp;timeout)) == -1) break; if (fd_num == 0) continue; for (i = 0; i &lt; fd_max + 1; i++) { if (FD_ISSET(i, &amp;cpy_reads)) { if (i == serv_sock) { // connection request adr_sz = sizeof(clnt_adr); clnt_sock = accept(serv_sock, (struct sockaddr *)&amp;clnt_adr, &amp;adr_sz); FD_SET(clnt_sock, &amp;reads); // 注册与客户端连接的套接字文件描述符 if (fd_max &lt; clnt_sock) { fd_max = clnt_sock; } printf(&quot;connected client : %d \\n&quot;, clnt_sock); } else { // read message str_len = read(i, buf, BUF_SIZE); if (str_len == 0) { // close FD_CLR(i, &amp;reads); close(i); printf(&quot;closed client %d \\n&quot;, i); } else { write(i, buf, str_len); // echo } } } } } close(serv_sock); return 0;}void error_handling(char *message) { fputs(message, stderr); fputs(&quot;\\n&quot;, stderr); exit(1);} 《UNIX 网络编程》P138 - P142 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/* include fig01 */#include &quot;../lib/unp.h&quot;int main(int argc, char **argv) { int i, maxi, maxfd, listenfd, connfd, sockfd; int nready, client[FD_SETSIZE]; // client数组，记录客户套接字 ssize_t n; fd_set rset, allset; char buf[MAXLINE]; socklen_t clilen; struct sockaddr_in cliaddr, servaddr; listenfd = Socket(AF_INET, SOCK_STREAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); servaddr.sin_port = htons(SERV_PORT); Bind(listenfd, (SA *)&amp;servaddr, sizeof(servaddr)); Listen(listenfd, LISTENQ); maxfd = listenfd; /* initialize */ maxi = -1; /* index into client[] array */ for (i = 0; i &lt; FD_SETSIZE; i++) client[i] = -1; /* -1 indicates available entry */ FD_ZERO(&amp;allset); FD_SET(listenfd, &amp;allset); /* end fig01 */ /* include fig02 */ for (;;) { rset = allset; /* structure assignment */ nready = Select(maxfd + 1, &amp;rset, NULL, NULL, NULL); if (FD_ISSET(listenfd, &amp;rset)) { /* new client connection */ clilen = sizeof(cliaddr); connfd = Accept(listenfd, (SA *)&amp;cliaddr, &amp;clilen); for (i = 0; i &lt; FD_SETSIZE; i++) if (client[i] &lt; 0) { client[i] = connfd; /* save descriptor */ break; } if (i == FD_SETSIZE) err_quit(&quot;too many clients&quot;); FD_SET(connfd, &amp;allset); /* add new descriptor to set */ if (connfd &gt; maxfd) maxfd = connfd; /* for select */ if (i &gt; maxi) maxi = i; /* max index in client[] array */ if (--nready &lt;= 0) continue; /* no more readable descriptors */ } for (i = 0; i &lt;= maxi; i++) { /* check all clients for data */ if ((sockfd = client[i]) &lt; 0) continue; if (FD_ISSET(sockfd, &amp;rset)) { if ((n = Read(sockfd, buf, MAXLINE)) == 0) { /*connection closed by client */ Close(sockfd); FD_CLR(sockfd, &amp;allset); client[i] = -1; } else Writen(sockfd, buf, n); if (--nready &lt;= 0) break; /* no more readable descriptors */ } } }}/* end fig02 */ pselect 函数1234567#include &lt;sys/select.h&gt;#include&lt;signal.h&gt;#include&lt;time.h&gt;// 返回值：若有就绪描述符则为其数目，若超时则为0，若出错则为-1int pselect(int maxfdpl, fd_set *readset, fd_set *writeset, fd_set *execptset, const struct timespec *timeout, const sigset_t *sigmask); pselect 使用 timespec 结构，而不使用 timeval 结构. 1234struct timespec { time_t tv_sec; // seconds long tv_nsec; // nanoseconds，指定纳秒而不是微秒}; pselect 函数增加了第六个参数——一个指向信号掩码的指针。该参数允许先禁止递交某些信号，再测试由这些当前被禁止的信号处理函数设置全局变量，然后调用 pselect，告诉它重新设置信号掩码。 poll 函数poll 提供的功能与 select 类似，不过在处理流设备时，它能提供额外信息。 12345678910#include &lt;poll.h&gt;// 返回值：若有就绪描述符则为其数目，若超时则为0，若出错则为-1/* 参数： fd: 第一个参数是指向一个结构数组第一个元素的指针。每个数组元素都是一个pollfd结构，用于指定测试某个给定描述符fd的条件。 nfds: 指定结构结构数组中的元素个数。 timeout: 指定poll函数在返回前等待多长时间。*/int poll(struct pollfd *fd, nfds_t nfds, int timeout); 要测试的条件由 events 指定，poll 函数在相应的 revents 成员中返回该描述符的状态。 12345struct pollfd { int fd; // 被监视的文件描述符 short events; // 请求的事件 short revents; // 实际发生的事件}; events 和 revents 的一些常值：第一部分处理输入，第二部分处理输出，第三部分处理错误（只能在 revents 中设定）。poll 识别三类数据：普通（normal），优先级带（priority band），高优先级（high priority）。 timeout 值： INFTIM：永远等待； 0：立即返回，不阻塞进程； ＞0：等待指定数目的毫秒数。 使用poll()和select()不一样，你不需要显式地请求异常情况报告。 POLLIN | POLLPRI等价于select()的读事件. POLLOUT |POLLWRBAND等价于select()的写事件。 POLLIN等价于POLLRDNORM |POLLRDBAND 而POLLOUT则等价于POLLWRNORM。 例如，要同时监视一个文件描述符是否可读和可写，我们可以设置 events为POLLIN |POLLOUT。在poll返回时，我们可以检查revents中的标志，对应于文件描述符请求的events结构体。如果POLLIN事件被设置，则文件描述符可以被读取而不阻塞。如果POLLOUT被设置，则文件描述符可以写入而不导致阻塞。这些标志并不是互斥的：它们可能被同时设置，表示这个文件描述符的读取和写入操作都会正常返回而不阻塞。 使用 poll 函数改写 TCP 回射服务器程序：《UNIX 网络编程》P146-P148 总结 5 种 I/O 模型，这里只讨论 I/O 复用模型。 I/O 复用最常用的函数是 select。批量输入时，即使用户输入结束，仍然有可能有数据残留在服务器和客户间的管道上（2个方向），需要使用 shutdown 函数以利用其半关闭特性。 混合使用 stdio 和 read/write 有危险，需要针对缓冲区而不是文本行进行操作。 poll 函数功能类似 select，但它能为流设备提供额外信息 参考资料https://wuhlan3.gitee.io/wuhlan3/2021/08/04/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E5%85%AD%EF%BC%89 IO多路复用之select总结 IO多路复用之poll总结 https://blog.csdn.net/lixungogogo/article/details/52226434","link":"/2021/10/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-2021-10-06-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%B8%89-IO%E5%A4%8D%E7%94%A8%EF%BC%9Aselect%E5%92%8Cpoll%E5%87%BD%E6%95%B0/"},{"title":"网络编程笔记(五)-域名系统和高级I&#x2F;O","text":"网络编程笔记(五)-域名系统和高级I/O 参考 《UNIX 网络编程》第 11 章，《TCP/IP 网络编程》第 8、11、12、13 章 域名与地址转换DNS 是对 IP 地址和域名相互转换的系统，其核心是 DNS 服务器。 gethostbyname 函数：利用域名获取 IP 地址鼓励使用 getaddrinfo 函数，可以同时处理 IPv4 和 IPv6 地址，而且是可重入的。 12345678910111213141516171819202122#include &lt;netdb.h&gt; // 返回值：成功时返回hostent变量地址值，失败返回NULL指针 struct hostent * gethostbyname(const char * hostname); struct hostent{ char * h_name; // 存有官方域名（Official domain name） char ** h_aliases; // 同一个IP可以绑定多个域名，除了官方域名以外的其他域名 int h_addrtype; // 保存地址族信息，IPv4存有AF_INET int h_length; // 保存IP地址长度：4 char ** h_addr_list; // address list：最重要成员，保存IP地址 // 可能分配多个IP给同一域名，利用多个服务器进行负载均衡} // 用法：for(i=0;host-&gt;h_aliases[i];i++){ printf(&quot;Aliases %d: %s \\n&quot;,i+1,host-&gt;h_aliases[i]); }for(i=0;host-&gt;h_addr_list[i];i++){ printf(&quot;IP addr %d:%s \\n&quot;, i+1, inet_ntoa(*(struct in_addr*)host -&gt;h_addr_list[i])); // 注意类型转换，先取成员变量得到一级指针，再转换一级指针为struct in_addr*，最后解引用得到IP地址！} 注意 h_addr_list 实际指向 in_addr 结构体变量值而非字符串地址值。 gethostbyaddr：利用 IP 地址获取域名123456789#include &lt;netdb.h&gt; // 返回值：成功时返回hostent变量地址值，失败返回NULL指针 /* 参数： addr：含有IP地址的in_addr结构体指针 len：第一个参数字节大小，IPv4为4，IPv6为16 family：地址族信息，IPv4为AF_INET, IPv6为AF_INET6*/struct hostent * gethostbyaddr(const char * addr, socklen_t len, int family); 分割 I/O多进程：父进程只需编写接收数据的代码，子进程只需编写发送数据的代码，简化了代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;arpa/inet.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;unistd.h&gt;#define BUF_SIZE 30void error_handling(char *message);void read_routine(int sock, char *buf);void write_routine(int sock, char *buf);int main(int argc, char *argv[]) { int sock; pid_t pid; struct sockaddr_in serv_adr; char buf[BUF_SIZE]; if (argc != 3) { printf(&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\\n&quot;, argv[0]); exit(1); } sock = socket(PF_INET, SOCK_STREAM, 0); if (sock == -1) { error_handling(&quot;socket() error&quot;); } memset(&amp;serv_adr, 0, sizeof(serv_adr)); serv_adr.sin_family = AF_INET; serv_adr.sin_addr.s_addr = inet_addr(argv[1]); serv_adr.sin_port = htons(atoi(argv[2])); if (connect(sock, (struct sockaddr *)&amp;serv_adr, sizeof(serv_adr)) == -1) { error_handling(&quot;connect() error\\r\\n&quot;); } else { printf(&quot;Connected....&quot;); } pid = fork(); if (pid == 0) { write_routine(sock, buf); } else { read_routine(sock, buf); } close(sock); return 0;}void error_handling(char *message) { fputs(message, stderr); fputs(&quot;\\n&quot;, stderr); exit(1);}void read_routine(int sock, char *buf) { while (1) { int str_len = read(sock, buf, BUF_SIZE); if (str_len == 0) { return; } buf[str_len] = 0; printf(&quot;Message from server : %s &quot;, buf); }}void write_routine(int sock, char *buf) { while (1) { fgets(buf, BUF_SIZE, stdin); if (!strcmp(buf, &quot;q\\n&quot;) || !strcmp(buf, &quot;Q\\n&quot;)) { shutdown(sock, SHUT_WR); return; } write(sock, buf, strlen(buf)); }} 进程间通信管道函数 pipe1234567#include &lt;unistd.h&gt;// 参数// fileds[0]：管道出口// fileds[1]：管道入口// 返回值：成功返回0，失败返回-1int pipe(int fildes[2]); 父子进程传递数据，注意一个管道不能完成双向通信。 123456789101112131415161718192021222324252627int fds[2];pipe(fds);pid = fork()// 单向通信if (pid == 0) { write(fds[1], str, sizeof(str));} else { read(fds[0], buf, BUF_SIZE); puts(buf);}// 双向通信int fds1[2], fds2[2];pipe(fds1[2]); pipe(fds2[2]);pid = fork();if (pid == 0) { write(fds1[1], str1, sizeof(str1)); read(fds2[0], buf, BUF_SIZE); printf(&quot;Child proc output: %s \\n&quot;, buf);} else { read(fds1[0], buf, BUF_SIZE); printf(&quot;Parent proc output: %s \\n&quot;, buf); write(fds2[1], str2, sizeof(str2));} 高级 IO 函数send 和 recv 函数send 和 recv 允许通过第四个参数从进程到内核传递标志。 send 函数1ssize_t send(int sockfd, const void* buf, size_t len, int flags); 功能：在一个已连接套接字上发送数据。 参数 ： sockfd：一个已连接的套接字描述符。(in) buf：指向要传送数据的缓冲区。(in) len：上述缓冲区的长度(字节数)。(in) flags：指明发送方式：0——忽略 该选项，MSG_DONTROUTE——不进行路由，MSG_OOB——用于发送带外数据。 send 的成功只是数据被成功发出，并不意味数据已经被接收方成功接收。如果传输层没有缓冲区空间放置要发送的数据，send 将被阻塞，除非采用的是非阻塞套接字。对非阻塞面向流的套接字，send 实际所写字节数取决于客户和服务器的缓冲区空闲块大小。select 函数可以用来确定是否可以发送更多的数据。 recv 函数1ssize_t recv(int sockfd, void* buf, int len, int flags); 功能：在一个已连接套接字上发送数据。 参数 ： sockfd：一个已连接的套接字描述符。(in) buf：指向要接收数据的缓冲区。(out) len：上述缓冲区的长度(字节数)。(in) flags：影响接收方式的标志。 一些 flags MSG_OOB：发送紧急消息，用于创建特殊发送方法和通道以发送紧急信息。 通过 MSG_OOB 可选项传递数据不会加快数据传输速度，而且通过信号处理函数也只能读取 1 字节，剩余数据只能通过未设置 MSG_OOB 的普通输入函数读取。 这是因为： TCP 连接上只有一个字节可以作为带外数据发送。 TCP 不存在真正的 “带外数据”：真正意义上的带外传输需要通过单独的通信路径高速传输数据，只是利用 TCP 的紧急模式进行传输。 MSG_PEEK：查看已读取的数据，而且系统不在 recv 或 recvfrom 返回后丢弃这些数据。 readv 和 writev 函数通过 writev 可以将分散保存在多个缓冲的数据一并发送，通过 readv 函数可以由多个缓冲分别接收。即多次 write 函数可以通过一次 writev 替代，只用传送一个数据包，提高效率。 1234567891011121314151617#include＜sys/uio.h＞ // 成功时返回接收的字节数，失败时返回-1ssize_t readv(int fd,const struct iovec*vector,int count);/* 结构体 iovec 中包含待发送数据的位置和大小信息。 count 为第二个参数传递的数组长度。*/// 成功时返回发送的字节数，失败时返回-1ssize_t writev(int fd, const struct iovec* vector, int count);struct iovec{ void * iov_base; // 缓冲地址 size_t iov_len; // 缓冲大小} 多播和广播多播程序类似 UDP 套接字连接，不需要建立连接，但要设置相应的套接字选项。多播程序一般分为 Sender 和 Receiver。 多播可以跨域不同网络，只要加入多播组就能接收数据。 广播也是基于 UDP 完成的，但广播只能向同一网络中的主机传递数据。广播分为直接广播和本地广播。 参考资料https://github.com/chankeh/net-lenrning-reference","link":"/2021/10/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%BA%94-%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F%E5%92%8C%E9%AB%98%E7%BA%A7IO/"},{"title":"网络编程笔记(六)-标准IO、epoll、多线程","text":"网络编程笔记(六)-标准IO、epoll、多线程 参考《TCP/IP 网络编程》15、16、17、18 章 套接字和标准 I/O标准 I/O 函数的 2 个优点： 良好的移植性（Portability）。 利用缓冲提高性能。 使用 read 和 write 函数传输 400M 文件的时间远远大于使用标准函数 fgets 和 fputs。 标准 I/O 函数的几个缺陷： 不容易进行双向通信。如果要同时进行读写操作，则应以 r+、w+、a+ 模式打开。 有时候可能频繁调用 fflush。每次切换读写工作状态都应该调用 fflush 函数。 需要以 FILE 结构体指针形式返回文件描述符； 利用 fdopen 函数将文件描述符转换成 FILE 结构体指针： 12345678#include &lt;stdio.h&gt; /* fildes: 需要转换的文件描述符 mode: 将要创建的 FILE 结构体指针的模式信息 */// 成功时返回转换的FILE结构体指针，失败时返回 NULL FILE * fdopen(int fildes, const char *mode); 利用 fileno 函数将 FILE 结构体指针转换成文件描述符 1234#include &lt;stdio.h&gt; // 成功时返回转换后的文件描述符，失败时返回-1 int fileno(FILE * stream); 关于 I/O 分离流的其他内容I/O 分离流的方式I/O 流分离的方式： TCP I/O 过程（routine）分离：通过调用 fork 函数复制出一个文件描述符，以区分输入和输出中使用的文件描述符，虽然文件描述符不会根据输入和输出进行区分，但是我们分开了 2 个文件描述符的用途。 调用 2 次调用 fdopen：创建读模式 FILE 指针和写模式 FILE 指针，分离了输入工具和输出工具。 TCP I/O 过程（routine）分离流的好处： 通过分开输入过程（代码）和输出过程降低实现难度。 与输入无关的输出操作可以提高速度。 2 次调用 fdopen 分离流的目的： 为了将 FILE 指针按读模式、写模式加以区分。 可以通过区分读写模式降低难度。 通过区分 I/O 缓冲提高缓冲性能。 流分离带来的问题流分离带来的问题：终止流时无法半关闭。读模式 FILE 指针、写模式 FILE 指针都是基于同一个文件描述符创建的。因此，针对任意一个 FILE 指针调用 fclose 都将关闭文件描述符，终止套接字。 解决方法：在创建 FILE 指针前复制文件描述符，然后利用各自的文件描述符创建读模式 FILE 指针和写模式 FILE 指针，这样销毁所有文件描述符后才能销毁套接字（引用计数）。 文件描述符的复制dup 和 dup2 函数12345678910#include &lt;unistd.h&gt; int dup(int fildes) // 成功时返回复制的文件描述符，失败时返回-1/* fildes：需要复制的文件描述符 filders2：明确指定的文件描述符整数值*/int dup2(int fildes, int fildes2) 无论复制出多少文件描述符，均应调用 shutdown 函数发送 EOF 并进入半关闭状态。 优于 select 的 epollselect 和 epoll 的比较select 不适合以 web 服务器端开发为主流的现代开发环境，所以要学习 Linux 平台下的 epoll。 基于 select 的 I/O 复用技术速度慢的原因： 调用 select 函数后常见的针对所有文件描述符的循环语句。 每次调用 select 函数时都需要向函数传递监视对象信息。 select 的优点： 服务器端接入者少。 程序具有兼容性——大部分操作系统都支持 select 函数。 epoll 函数epoll_create 函数epoll_create：向操作系统请求创建保存 epoll 文件描述符的空间，对应 select 方式下声明的 fd_set 变量。该函数返回的文件描述符主要用于区分 epoll 例程。 12345#include &lt;sys/epoll.h&gt; // size: epoll实例的大小// 返回值：成功时返回epoll文件描述符，失败时返回-1 int epoll_create(int size) 注意，size 只是建议 epoll 例程大小，仅供操作系统参考。Linux 2.6.8 之后的内核将完全忽略 size 参数，因为内核会根据情况调整 epoll 例程的大小。 epoll_ctl 函数epoll_ctl：向空间（对应于 select 中的位数组）注册并注销文件描述符，对应 select 中的 FD_SET、FD_CLR 函数。 12345678910111213141516#include &lt;sys/epoll.h&gt;/* epfd： 用于注册监视对象的epoll例程的文件描述符。 op： 用于指定监视对象的添加、删除或更改。 fd： 需要注册的监视对象文件描述符。 event： 监视对象事件类型。*/// 成功时返回0，失败时返回-1 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)// 用法：struct epoll_event event;event.events = EPOLLIN; // 详见结构体 epoll_eventevent.data.fd = sockfd;epoll_ctl(epfd, EPOLL_CTL_ADD, sockfd, &amp;event); 举例： epoll_ctl(A, EPOLL_CTL_ADD, B, C); “epoll 例程中 A 注册文件描述符 B，主要目的是监视参数 C 中的事件。 epoll_ctl(A, EPOLL_CTL_DEL, B, NULL); ”从 epoll 例程 A 中删除文件描述符 B。“ op 操作： EPOLL_CTL_ADD：将文件描述符注册到 epoll 例程。 EPOLL_CTL_DEL：从 epoll 例程中删除文件描述符。使用时需向第四个参数传递 NULL。 EPOLL_CTL_MOD：更改注册的文件描述符的关注事件发生情况。 epoll_wait 函数epoll_wait：等待文件描述符发生变化，类似 select 函数。 123456789#include &lt;sys/epoll.h&gt;/* epfd： 标识事件发生监视范围epoll例程的文件描述符。 events： 保存发生事件的文件描述符集合的结构体地址值。 maxevents： 第二个参数中可以保存的最大事件数。 timeout： 以毫秒为单位的等待时间，传递-1时，一直等待直到发生事件。*/// 返回值：成功时返回发生事件的文件描述符数，同时在第二个参数指向的缓冲中保存发生事件的文件描述符集合。失败时返回-1 int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout) 结构体 epoll_event 和 epoll_dataselect 函数中通过 fd_set 变量查看事件发生与否，epoll 通过以下结构体将发生事件的文件描述符集中到一起： 123456789101112//epoll将发生事件的文件描述符集中在一起，放在epoll_event结构体中 struct epoll_event{ __uint32_t events; epoll_data_t data; }typedef union epoll_data{ void * ptr; int fd; __uint32_t u32; __uint64_t u64; } epoll_data_t; 声明足够大的 epoll_event 结构体数组后，传递给 epoll_wait 函数时，发生变化的文件描述符信息将被填入该数组，无需像 select 一样对所有文件描述符进行循环。 epoll_event 成员 epoll_events 中可以保存的常量及所指的事件类型： 基于 epoll 的回声服务器端注意与 select 进行对比。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// echo_epollserv.c#include &lt;arpa/inet.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;sys/socket.h&gt;#include &lt;unistd.h&gt;#define BUF_SIZE 100#define EPOLL_SIZE 50void error_handling(char *message);int main(int argc, char *argv[]) { int serv_sock, clnt_sock; struct sockaddr_in serv_adr, clnt_adr; socklen_t adr_sz; int str_len, i; char buf[BUF_SIZE]; struct epoll_event *ep_events; struct epoll_event event; int epfd, event_cnt; if (argc != 2) { printf(&quot;Usage : %s &lt;port&gt;\\n&quot;, argv[0]); exit(1); } serv_sock = socket(PF_INET, SOCK_STREAM, 0); if (serv_sock == -1) { error_handling(&quot;socket error&quot;); } memset(&amp;serv_adr, 0, sizeof(serv_adr)); serv_adr.sin_family = AF_INET; serv_adr.sin_addr.s_addr = htonl(INADDR_ANY); serv_adr.sin_port = htons(atoi(argv[1])); if (bind(serv_sock, (struct sockaddr *)&amp;serv_adr, sizeof(serv_adr)) == -1) { error_handling(&quot;bind() error&quot;); } if (listen(serv_sock, 5) == -1) { error_handling(&quot;listen() error&quot;); } epfd = epoll_create(EPOLL_SIZE); //创建epoll例程 ep_events = malloc(sizeof(struct epoll_event) * EPOLL_SIZE); // 将serv_sock添加到例程空间中 event.events = EPOLLIN; event.data.fd = serv_sock; epoll_ctl(epfd, EPOLL_CTL_ADD, serv_sock, &amp;event); while (1) { event_cnt = epoll_wait(epfd, ep_events, EPOLL_SIZE, -1); if (event_cnt == -1) { puts(&quot;epoll_wait() error!&quot;); break; } for (i = 0; i &lt; event_cnt; i++) { if (ep_events[i].data.fd == serv_sock) { adr_sz = sizeof(clnt_adr); clnt_sock = accept(serv_sock, (struct sockaddr *)&amp;clnt_adr, &amp;adr_sz); event.events = EPOLLIN; event.data.fd = clnt_sock; epoll_ctl(epfd, EPOLL_CTL_ADD, clnt_sock, &amp;event); //将请求连接的套接字添加到epoll例程中 printf(&quot;connected client : %d \\n&quot;, clnt_sock); } else { // read message str_len = read(ep_events[i].data.fd, buf, BUF_SIZE); if (str_len == 0) { // close request! epoll_ctl(epfd, EPOLL_CTL_DEL, ep_events[i].data.fd, NULL); // 将断开连接的套接字从epoll例程中移除 close(ep_events[i].data.fd); printf(&quot;closed client %d \\n&quot;, ep_events[i].data.fd); } else { write(ep_events[i].data.fd, buf, str_len); // echo！ } } } } close(serv_sock); close(epfd); // 注意关闭epoll例程 return 0;}void error_handling(char *message) { fputs(message, stderr); fputs(&quot;\\n&quot;, stderr); exit(1);} 边缘触发和条件触发边缘触发和条件触发的区别——在于发生事件的时间点： 条件触发：只要输入缓冲有数据，就会一直通知该事件。 边缘触发：输入缓冲收到数据时，仅注册一次事件。 epoll 默认以条件触发方式工作，select 也是以条件触发方式工作的。 实现边缘触发服务器的原理：通过 errno 变量验证错误原因；使用 fcntl 函数更改套接字选项，添加非阻塞 O_NONBLOCK 表至，完成非阻塞 I/O。 1234void setnonblockingmode(int fd){ int flag = fcntl(fd, F_GETFL, 0); fcntl(fd, F_SETFL, flag|O_NONBLOCK); } 边缘触发的优点：可以分离接收数据和处理数据的时间点。 多线程服务器端的实现pthread_create 和 pthread_join pthread_create 功能：生成线程 必须在调用此函数前就为 pthread_t 对象分配内存空间（malloc） `thread_handles = malloc(thread_countsizeof(pthread_t));` 技巧：为每一个线程赋予唯一的 int 型参数 rank `pthread_create(&amp;thread_handles[thread], NULL, Hello, (void) thread);` thread_p 是指针！ pthread_join 分支合并（join）到主线程的直线中 pthread_join(thread_handles[thread], NULL); thread_p 是值！ 类似的函数有 int pthread_detach(pthread_t thread); 调用 pthread_detach 不会引起线程终止或进入阻塞状态。 临界区 临界区 实例：计算 pi 的线程函数 竞争条件 当多个线程都要访问共享变量或共享文件这样的共享资源时，如果其中一个访问是更新操作，那么这些访问就可能会导致某种错误 临界区 一个更新共享资源的代码段，一次只允许一个线程执行该代码段 必须串行执行临界区的代码 互斥量（mutex） 特殊类型 pthread_mutex_t 初始化和销毁 pthread_mutex_int pthread_mutex_init(&amp;mutex, NULL); pthread_mutex_destroy pthread_mutex_destroy(&amp;mutex); 上锁和解锁 pthread_mutex_lock pthread_mutex_lock(&amp;mutex); pthread_mutex_unlock pthread_mutex_unlock(&amp;mutex); 使用互斥量时，多个进程进入临界区的顺序是随机的 信号量（semaphore） 信号量定义：一种特殊类型的 unsigned int 无符号整型变量，可以赋值为 0、1、2…… 优点 能够初始化为任何非负值 信号量没有归属权，任何线程都能够对锁上的信号量进行解锁 生产者-消费者同步 一个消费者线程在继续运行前，需要等待一些条件或数据被生产者线程创建 基本操作 引入 semaphore 头文件 和 pthread_t 一样，init 前需要分配内存 semaphores = malloc(thread_count*sizeof(sem_t)); 初始化和销毁 sem_init sem_destroy P 操作和 V 操作 sem_wait 将信号量减 1 如果值变成 负数，则阻塞执行 P 操作的线程，否则线程继续执行 sem_post 将信号量加 1 如果值 小于等于零，则唤醒一个等待进程 多线程并发服务器端的实现（聊天程序）服务器：可以同时连接多个客户 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;arpa/inet.h&gt;#include &lt;pthread.h&gt;#include &lt;semaphore.h&gt;#include &lt;signal.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/wait.h&gt;#include &lt;unistd.h&gt;#define BUF_SIZE 100#define MAX_CLNT 256void *handle_clnt(void *arg);void send_msg(char *msg, int len);void error_handling(char *message);int clnt_cnt = 0;int clnt_socks[MAX_CLNT];pthread_mutex_t mutx;int main(int argc, char *argv[]) { int serv_sock; int clnt_sock; struct sockaddr_in serv_adr; struct sockaddr_in clnt_adr; int clnt_adr_sz; pthread_t t_id; // 传递给线程的id if (argc != 2) { printf(&quot;Usage : %s &lt;port&gt;\\n&quot;, argv[0]); exit(1); } pthread_mutex_init( &amp;mutx, NULL); // 互斥访问临界区——clnt_cnt和clnt_socks serv_sock = socket(PF_INET, SOCK_STREAM, 0); if (serv_sock == -1) { error_handling(&quot;socket() error&quot;); } memset(&amp;serv_adr, 0, sizeof(serv_adr)); serv_adr.sin_family = AF_INET; serv_adr.sin_addr.s_addr = htonl(INADDR_ANY); serv_adr.sin_port = htons(atoi(argv[1])); if (bind(serv_sock, (struct sockaddr *)&amp;serv_adr, sizeof(serv_adr)) == -1) { error_handling(&quot;bind() error&quot;); } if (listen(serv_sock, 5) == -1) { error_handling(&quot;listen() error&quot;); } while (1) { clnt_adr_sz = sizeof(clnt_adr); clnt_sock = accept(serv_sock, (struct sockaddr *)&amp;clnt_adr, &amp;clnt_adr_sz); // 以下代码访问临界区，将相关信息写入clnt_cnt和clnt_socks。 pthread_mutex_lock(&amp;mutx); clnt_socks[clnt_cnt++] = clnt_sock; pthread_mutex_unlock(&amp;mutx); pthread_create(&amp;t_id, NULL, handle_clnt, (void *)&amp;clnt_sock); pthread_detach(t_id); // 从内存中销毁完全已终止的线程 printf(&quot;Connetcted client IP :%s \\n&quot;, inet_ntoa(clnt_adr.sin_addr)); } close(serv_sock); return 0;}void *handle_clnt(void *arg) { int clnt_sock = *((int *)arg); // 传递给线程的参数 int str_len = 0; int i; char msg[BUF_SIZE]; while ((str_len = read(clnt_sock, msg, sizeof(msg))) != 0) send_msg(msg, str_len); pthread_mutex_lock(&amp;mutx); // 访问临界区前获得锁 for (i = 0; i &lt; clnt_cnt; i++) { if (clnt_sock == clnt_socks[i]) { // 覆盖删除 while (i++ &lt; clnt_cnt - 1) clnt_socks[i] = clnt_socks[i + 1]; break; } } clnt_cnt--; pthread_mutex_unlock(&amp;mutx); close(clnt_sock); return NULL;}// send to allvoid send_msg(char *msg, int len) { int i; pthread_mutex_lock(&amp;mutx); for (i = 0; i &lt; clnt_cnt; i++) { write(clnt_socks[i], msg, len); } pthread_mutex_unlock(&amp;mutx);}void error_handling(char *message) { fputs(message, stderr); fputs(&quot;\\n&quot;, stderr); exit(1);} 客户端：分离输入和输出而创建线程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;arpa/inet.h&gt;#include &lt;pthread.h&gt;#include &lt;semaphore.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;unistd.h&gt;#define BUF_SIZE 100#define NAME_SIZE 20void *send_msg(void *arg);void *recv_msg(void *arg);void error_handling(char *message);char name[NAME_SIZE] = &quot;[DEFAULT]&quot;;char msg[BUF_SIZE];int main(int argc, char *argv[]) { int sock; struct sockaddr_in serv_adr; pthread_t snd_thread, rcv_thread; void *thread_return; if (argc != 4) { printf(&quot;Usage : %s &lt;IP&gt; &lt;port&gt; &lt;name&gt;\\n&quot;, argv[0]); exit(1); } sprintf(name, &quot;[%s]&quot;, argv[3]); sock = socket(PF_INET, SOCK_STREAM, 0); if (sock == -1) { error_handling(&quot;socket() error&quot;); } memset(&amp;serv_adr, 0, sizeof(serv_adr)); serv_adr.sin_family = AF_INET; serv_adr.sin_addr.s_addr = inet_addr(argv[1]); serv_adr.sin_port = htons(atoi(argv[2])); if (connect(sock, (struct sockaddr *)&amp;serv_adr, sizeof(serv_adr)) == -1) { error_handling(&quot;connect() error\\r\\n&quot;); } else { printf(&quot;connect to the server!\\n&quot;); } pthread_create(&amp;snd_thread, NULL, send_msg, (void *)&amp;sock); pthread_create(&amp;rcv_thread, NULL, recv_msg, (void *)&amp;sock); pthread_join(snd_thread, &amp;thread_return); pthread_join(rcv_thread, &amp;thread_return); close(sock); return 0;}void error_handling(char *message) { fputs(message, stderr); fputs(&quot;\\n&quot;, stderr); exit(1);}void *send_msg(void *arg) { int sock = *((int *)arg); char name_msg[NAME_SIZE + BUF_SIZE]; while (1) { fgets(msg, BUF_SIZE, stdin); if (!strcmp(msg, &quot;q\\n&quot;) || !strcmp(msg, &quot;Q\\n&quot;)) { close(sock); exit(0); } sprintf(name_msg, &quot;%s %s&quot;, name, msg); write(sock, name_msg, strlen(name_msg)); } return NULL;}void *recv_msg(void *arg) { int sock = *((int *)arg); char name_msg[NAME_SIZE + BUF_SIZE]; int str_len; while (1) { str_len = read(sock, name_msg, NAME_SIZE + BUF_SIZE - 1); if (str_len == -1) { return (void *)-1; } name_msg[str_len] = 0; fputs(name_msg, stdout); } return NULL;} 参考资料https://github.com/chankeh/net-lenrning-reference","link":"/2021/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%85%AD-%E6%A0%87%E5%87%86IO%E3%80%81epoll%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"title":"网络编程笔记(一)-基本TCP套接字编程","text":"网络编程笔记(一)-基本TCP套接字编程 参考《UNIX网络编程》1 - 4 章，《TCP/IP网络编程》1 - 5 章。 基础知识基本概念 守护进程（daemon）：一般认为 Web 服务器程序是一个长时间运行的程序，它只在响应来自网络的请求时才发送网络消息。守护进程能在后台运行且不跟任何终端关联。 TCP 套接字的花哨名字：网际（AF_INET）字节流（SOCK_STREAM）套接字 时间获取服务器的众所周知端口：13 协议无关性： 将 IPv4 修改为 IPv6 协议 sockaddr_in ——&gt; sockaddr_in6 AF_INET ——&gt; AF_INET6 sin_port ——&gt; sin6_port 更好的做法是编写协议无关程序。 包裹函数 weapper function。在本书中，约定包裹函数名是实际函数名的首字母大写形式。每个包裹函数完成实际的函数调用，检查返回值，并在错误时终止进程。 123456int Socket(int family, int type, int protocol){ int n; if( (n = socket(family, type, protocol)) &lt; 0) err_sys(&quot;socket error&quot;); return(n);} Unix errno 值：只要有一个 UNIX 函数中有错误发生，全局变量 errno 就被置为一个指明该错误类型的正值，函数本身则通常返回 -1。err_sys（作者定义的）查看 errno 变量的值并输出相应的出错信息。 服务器种类： 迭代服务器：对于每个客户都迭代执行一次 并发服务器：同时处理多个客户（Unix 的 fork 函数，用线程替代 fork 等） 国际标准化组织（International Organization for Standardization，ISO）的计算机通信开放系统互连模型（open systems interconnection，OSI），是一个七层模型。 物理层/数据链路层：随系统提供的设备驱动程序和网络硬件。 网络层：由 IPv4 和 IPv6 这两个协议处理。在附录 A 中讲述。 传输层：即本书所讲的套接字编程接口，从应用层(上3层)进入传输层的接口。 会话层/表示层/应用层：OSI 的顶上三层被合并为一层，称为应用层。Web 客户端（浏览器)、Telnet 客户、web 服务器、FTP 服务器等在这层。 《Unix 网络编程》讲述的套接字编程接口是从顶上三层（网际协议的应用层）进入传输层的接口，重点关注如何使用套接字编写使用 TCP 或 UDP 的网络应用程序。 套接字提供的是从OSI模型的顶上三层进入传输层的接口，这里设计有两个原因： 理由一：顶上三层处理具体网络应用（如 FTP、Telnet 或 HTTP）的所有细节，却对通信细节了解很少；底下四层对具体网络应用了解不多，却处理所有的通信细节：发送数据，等待确认，给无序到达的数据排序，计算并验证校验和等等。 理由二：顶上三层通常构成所谓的用户进程（user process），底下四层却通常作为操作系统内核的一部分提供。Unix 与其他现代操作系统都提供分隔用户进程与内核进程的机制。由此可见，第 4 层和第 5 层之间的接口是构建 API 的自然位置。 POSIX（Portable Operating System Interface，可移植操作系统接口） 64 位体系结构：LP64 模型中，长整数（L）和指针（P）都占用 64 位。 相关 linux 指令 netstat -ni：提供网络接口信息，-n 输出数值地址而不是反向解析为名字。其中 loopback 接口称为 lo，以太网接口称为 eth0（这里是 ens33）。 netstat -nr：查看路由表 ifconfig ens33：获得 ens33 以太网接口的详细信息 ping -b 192.168.200.255：对本地接口的广播地址执行 ping ，可以找到本地网络中其他主机的 IP 地址。 Linux ps（英文全拼：process status）命令用于显示当前进程的状态，类似于 windows 的任务管理器 grep：Global regular expression print 计算机网络基础 TCP 提供面向连接的、可靠的、排序、流量控制、全双工的数据传送服务。 UDP 提供无连接的、不可靠的、尽力服务。发送给接收进程的数据有可能丢失，也有可能错序。 SCTP：流控制传输协议。提供可靠全双工关联的面向连接的协议。 使用关联来指代 SCTP 的连接：一个连接只涉及两个 IP 地址之间的通信，一个关联指代两个系统之间的一次通信。 SCTP 是多宿的，单个 SCTP 端点能够支持多个 IP 地址。 SCTP 面向消息，它提供各个记录的按序递送服务。 TCP 的建立和终止TCP 三路握手建立连接： 服务器被动打开 (passive open)：服务器调用 socket、bind、litsen 函数，准备好接受外来连接。 客户主动打开 (active open)：客户调用 connext，发送 SYN 报文，告诉对方初始序号。通常 SYN 报文不携带数据，其所在的 IP 数据报只包含一个 IP 首部、一个 TCP 首部和可能有的TCP选项。 服务器必须确认（ACK）客户的 SYN：服务器在单个分节中，发送自己要发送数据的初始序列号 SYN 和对客户 SYN 的确认（ACK）。 客户必须确认服务器的 SYN，发送 ACK。 TCP选项： MSS 选项：通告对端自己的最大报文段长度（maximum segment size） 窗口规模选项：通告对端的最大窗口大小（advertised window size）为 65535(16 bits)，但现在要求更大的窗口，必须左移 0~14 位。 时间戳选项：防止失而复现的分组可能造成的数据损坏。窗口规模选项和时间戳选项也称长肥管道选项。 TCP 四路握手释放连接： 主动关闭 (active close)：某个应用进程首先调用 close，发送一个 FIN 分节表示自己的数据发送完毕。 被动关闭 (passive close)：TCP 确认这个 FIN，它的接收也作为一个文件结束符（EOF）传递给接收端应用进程（FIN 意味着无额外数据可接收）。 一段时间后，接收 FIN 的进程将会调用 close 关闭自己的套接字，它的 TCP 也发送一个FIN。 接收到最终 FIN 的原发送端 TCP 确认这个 FIN。 半关闭 (half-close)：被动关闭一端向主动关闭一端流动数据。 当一个 Unix 进程不论自愿地（调用 exit 或从 main 函数返回）还是非自愿地（收到一个终止本进程的信号）终止时，所有打开的描述符都被关闭，这也导致仍然打开的任何 TCP 连接上也发出一个 FIN。 TCP 状态转移图理解状态转换图是使用 netstat 命令诊断网络问题的基础。 TIME_WAIT状态TIME_WAIT：停留在这个状态的持续时间是最长报文段生命期（maximum segment lifetime，MSL）的两倍，也称 2MSL。 TIME_WAIT 状态存在的两个理由： 可靠地实现 TCP 全双工连接的终止：最终的 ACK 需要维护状态，比如 ACK 丢失需要重传，否则会响应 RST 允许老的重复报文段在网络中消逝：正确处理重复的分组——迷途的重复分组/漫游的重复分组。 端口号端口的作用： 让应用层的各种应用进程将其数据通过端口 向下 交付给传输层 让传输层知道应当将其报文段中的数据 向上 通过端口交付给应用层相应的进程 端口是传输层的服务访问点 (SAP)：数据链路层的 SAP 是 MAC 地址，网络层的 SAP 是 IP 地址，传输层的 SAP 是端口 端口号：标识计算机应用层中的各进程 UDP 协议和 TCP 协议如何知道把收到的数据段交给哪个上层进程呢？利用数据段 (segment) 中的目的端口号 (2个字节) 端口号分类： IANA 的知名端口（Well-known ports，也称众所周知端口）0~1023为提供知名网络服务的系统进程所用。 例如: 20-ftp Data，21-ftp Control，23-telnet，25-SMTP，53-DNS，69-TFTP，80-HTTP，110-POP3，161-SNMP。 Unix 系统的保留端口（reserved port）指的是小于 1024 的任何端口，所有知名端口都是保留端口。 注册端口（Registered ports）1024~49151。在 IANA 注册的专用端口号，为企业软件所用。 动态端口（Private ports）49152~65535。没有规定用途的端口号，一般用户可以随意使用。也称为私用或暂用端口号。 套接字 (Socket)(1) 通过IP地址或域名找到主机： www.baidu.com-&gt;36.152.44.96 (2) 通过端口号找到主机上的进程 套接字是网络数据传输用的软件设备，网络编程又称套接字编程。 套接字函数是 TCP 协议的编程接口，每个 TCP 套接字都有自己的接收缓冲区和发送缓冲区。 一个 TCP 的套接字对是一个定义该连接的两个端点的四元组：本地 IP 地址、本地 TCP 端口号、外地 IP 地址、外地 TCP 端口号。标识每个端点的两个值（IP 地址和端口号）通常称为一个套接字。 TCP 端口号与并发服务器 STEP1：该服务器主机是多宿的。*:* 表示监听套接字。 STEP2：客户主机选择临时端口 1500 连接服务器。 STEP3：我们必须区分已连接套接字和监听套接字。注意已连接套接字使用与监听套接字相同的本地端口（21） STEP4：客户主机另一个客户使用临时端口 1501 连接同一个服务器。注意第一个连接的套接字对与第二个连接的套接字对不同，因为客户选择的临时端口号不同。 必须查看套接字对的所有 4 个元素才能确定由哪个端点接收某个到达的分节，图 2-14 对于同一个本地端口（21）存在 3 个套接字。 网络地址结构IPv4 套接字地址结构1234567891011121314151617181920212223242526272829// 用来存放因特网的 IP 地址和端口号struct sockaddr_in{ sa_family_t sin_family; // 地址族（Address Family） uint16_t sin_port; // 16位TCP/UDP端口号 struct in_addr sin_addr; // 32位IP地址 char sin_zero[8]; // 不使用}struct in_addr{ in_addr_t s_addr // 32位IPv4地址，整数}// 通用的套接字地址结构，经常将sockaddr_in强制转换为sockaddr，它是bind函数的指针参数之一struct sockaddr{ sa_family_t sin_family; // 地址族（Address Family） char sa_data[14]; // 地址信息}// Example:struct sockaddr_in serv_addr; // 直接向 sockaddr 填充地址信息很麻烦（要填充0）...// 类型强制转换 if (bind(serv_sock, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)) == -1) error_handling(&quot;bind() error&quot;);... sockaddr_in 参数分析： sin_family：地址族，AF_INET（IPV4网络协议中使用的地址族），AF_INET6（IPV6网络协议中使用的地址族），AF_LOCAL（本地通信中采用的UNIX协议的地址族）。 sin_port：以网络字节序保存 16 位端口号。 sin_addr：以网络字节序保存 32 位地址信息。 sin_zero：使结构体 sockaddr_in 的大小与结构体 sockaddr 保持一致而插入的成员，必须填充 0. 注意点： 32 位 IPv4 地址存在两种不同访问方法： serv.sin_addr 按照 in_addr 结构来引用地址。 serv.sin_addr.s_addr 按照 in_addr_t（通常是一个无符号位的 32 位整数）来引用地址。 必须正确使用 IPv4 地址，尤其是它作为函数参数时，因为编译器对传递结构和传递整数的处理是完全不同的。 sin_zero 字段未曾使用，总是把它置为 0。按照惯例，我们总是在填写结构体之前，把整个结构体都置为 0。使用 bzero() 函数 socket 地址结构仅在给定主机上使用：虽然某些字段（例如IP地址和端口号）用在不同主机之间的通信中，但是结构本身是不会在主机上传递的。 IPv6 套接字地址结构12345678910111213141516171819202122#include &lt;netinet/in.h&gt;struct in6_addr{ unit8_t s6_addr[16]; /* 128位IPv6地址 */};#define SIN6_LENstruct sockaddr_in6{ uint8_t sin6_len; // 结构体长度（28） sa_family_t sin6_family; // AF_INET6 in_port_t sin6_port; uint32_t sin6_flowinfo; // 流信息，它的使用依然是一个课题 struct in6_addr sin6_addr; // IPv6地址 uint32_t sin6_scope_id;};// 新的通用的套接字地址结构struct sockaddr_storage{ uint8_t ss_len; sa_family_t ss_family; ...}; 新的 struct sockaddr_storage 足以容纳系统所支持的任意套接字地址结构。 如果系统支持的任何套接字地址结构有对齐需要，那么 sockaddr_storage 能够满足最苛刻的对齐要求。 sockaddr_storage 足够大，能够容纳系统支持的任何套接字地址结构。 注：除了上面呈现的两个字段外，其他字段对于用户是透明的，需要对 sockaddr_storage 进行类型强制转换后才能够访问其他字段。 网络字节序和主机字节序字节排序函数主机字节序（Host Byte Order）——CPU 在内存中存储数据的方式： 大端序（Big Endian）：高位字节存放到低位地址。 小端序（Little Endian）：高位字节存放到高位地址。 因特网的网络字节序 (Network Byte Order) 采用大端序，即先发送高位字节。例如，发送 0x66020304 的网络序为 04 03 02 66（最右边的最先发送） 字节序转换（Endian Conversations）：在填充 sockaddr_in 结构体前，先要将数据转换为网络字节序。 12345678// h：主机字节序，n：网络字节序// s代表short，16位，用于端口号转换。unsigned short htons(unsigned short host)unsigned short ntohs(unsigned short net)// l代表long，32位，用于IP地址转换。unsigned long htonl(unsigned long host)unsigned long ntohl(unsigned long net) 字节操纵函数名字以 b 开头的第一组函数起源于 4.2BSD： 1234567#include &lt;strings.h&gt;// 功能：把目标字符串中指定数目的字节置为0，经常使用该函数把一个套接字地址结构初始化为0.void bzero (void *dest, size_t nbytes);void bcopy (const void *src, void *dest, size_t nbytes);int bcmp (const void *ptr1, const void *ptr2, size_t nbytes); 名字以 mem 开头的第二组函数起源于 ANSI C 标准： 12345#include &lt;string.h&gt;// 记忆方法：dest = src; 长度参数总是最后一个参数。void *memset (void *dest, int c, size_t len);void *memcpy (void *dest, const void *src, size_t nbytes);int memcmp (const void *ptr1, const void *ptr2, size_t nbytes); 地址转换函数点分十进制的字符串 –》32位网络字节序的二进制整数值：n 代表数值（numeric），a 代表地址（address）。 123456789#include &lt;arpa/inet.h&gt;// 功能：将转换结果（32位IP地址）直接保存在 in_addr 结构体中// 返回值：成功时（字符串有效）返回1，失败时返回0int inet_aton(const char * string, struct in_addr * addr);// 功能：把 点分十进制的IP地址 转化为 32位IP地址。// 返回值：成功时返回32位大端型整数值，失败时返回-1，可以检测无效的IP地址in_addr_t inet_addr(const char * string); 注意：inet_addr 已被废弃：该函数出错时返回 INADDR_NONE常值（通常是一个32位均为1的值），有线广播地址 255.255.255.255 不能被该函数处理！ 32位网络字节序的二进制整数值 –》点分十进制的字符串： 12345#include &lt;arpa/inet.h&gt;// 功能：把 32位IP地址 转化为 点分十进制的IP地址// 返回值：成功时返回转换后的 点分十进制数串的指针，失败时返回-1char * inet_ntoa(struct in_addt adr); 可用于 IPv4 和 IPv6 的地址转换函数：p 代表表达（presentation），n 代表数值（numeric）。 12345678910#include &lt;arpa/inet.h&gt;// 功能：将strptr所指的字符串转换为数值，并通过addrptr指针存放二进制结果。// 返回值：若成功则为1，若输入不是有效的表达格式则为0，若出错则为-1int inet_pton(int family, const char *strptr, void *addrptr);// 功能：从数值格式（addrptr）转换到表达格式（strptr）// 参数：len-目标存储单元的大小。// 返回值：若成功则为指向结果的指针，若出错则为NULLconst char *inet_ntop(int family, const void *addrptr, char *strptr, size_t len); 注：两个函数的 family 参数既可以是 AF_INET，也可以是 AF_INET6；如果以不被支持的地址族作为 family 参数，这两个函数就都返回一个错误，并将 errno 置为 EAFNOSUPPORT； inet_ntop 函数的 strptr 参数不可以是一个空指针，调用者必须为目标存储单元分配内存并指定其大小，调用成功时，这个指针就是该函数的返回值。 网络地址初始化客户端：声明 sockaddr_in 结构体，并初始化要连接的服务器端套接字的 IP 地址和端口号，然后调用 connect 函数。 12345678struct sockaddr_in addr;char *serv_ip = &quot;211.217.168.13&quot;char *serv_port = &quot;9190&quot; memset(&amp;serv_addr, 0, sizeof(addr)); // 结构体变量的所有成员初始化为0serv_addr.sin_family = AF_INET; // 指定地址族 serv_addr.sin_addr.s_addr = inet_addr(serv_ip);serv_addr.sin_port = htons(atoi(serv_port)); // atoi--把ascii转化为int，htons—主机序到网络序 服务器：声明 sockaddr_in 结构体，初始化服务器端 IP 和端口号，可以使用 INADDR_ANY 自动获取服务器端的 IP 地址。 1234567struct sockaddr_in addr;char *serv_port = &quot;9190&quot;memset(&amp;serv_addr, 0, sizeof(addr)); // 结构体变量的所有成员初始化为0serv_addr.sin_family = AF_INET; // 指定地址族 serv_addr.sin_addr.s_addr = inet_addr(INADDR_ANY); // INADDR_ANY: 监听所有(接口的)IP地址serv_addr.sin_port = htons(atoi(serv_port)); // atoi--把ascii转化为int，htons—主机序到网络序 值-结果参数当向一个套接字函数传递一个套接字地址结构时，总是以引用传递，即传递的是一个指向结构的指针。该结构的长度也作为参数来传递，其传递的方式取决于该结构的传递的方向：从进程到内核，还是从内核到进程。 从进程到内核传递的套接字结构有 3 个函数：bind、connect、sendto，这三个函数的一个参数是指向套接字结构的指针，另一个是结构的大小，如： 12struct sockaddr_in serv;connect(sockfd, (SA *)&amp;serv, sizeof(serv)); 指针和指针所指内容的大小都传递给了内核，于是内核知道需要从进程复制多少数据进来。 从内核到进程传递的套接字地址结构有四个函数：accept、recvfrom、getsockname、getpeername，这些函数其中两个参数是：指向套接字结构的指针和指向表示结构大小的指针，如： 12345struct sockaddr_in cli;socklen_t len;len = sizeof(cli);getpeername(unixfd, (SA *)&amp;cli, &amp;len); 这种参数类型叫做值-结果参数： 当函数被调用时，结构大小是一个值（value），它告诉内核该结构大小，这样内核在写该结构时不至于越界）。 当函数返回时，结构大小又是一个结果（result），它告诉进程内核在该结构中存储了多少信息。 总结：当一个套接字函数需要填写一个结构时，该结构的长度也以引用形式传递，这样它的值也可以被函数更改。我们把这样的参数叫做值-结果参数。 书中自定义的读写函数12345#include &quot;unp.h&quot;ssize_t readn (int fildes, void *buff, size_t nbytes);ssize_t written (int filedes, const void *buff, size_t nbytes);ssize_t readline (int fileds, void *buff, size_t maxlen); readn 函数：123456789101112131415161718192021222324252627#include &lt;errno.h&gt;#include &lt;unistd.h&gt;// 功能：从一个描述符读n字节// 参数：fd-文件描述符ssize_t readn(int fd, void *buf, size_t n) { size_t nleft; // 剩余字节数 ssize_t nread; // 一次read读取的字节数 char *ptr; ptr = buf; nleft = n; while (nleft &gt; 0) { if ( (nread = read(fd, ptr, nleft)) &lt; 0) { if (errno == EINTR) { nread = 0; /* call read() again */ } else { return (-1); } } else if (nread == 0) { break; /* EOF */ } nleft -= nread; ptr += nread; } return (n - nleft); /*return &gt;= 0*/} writen 函数：12345678910111213141516171819202122232425#include &lt;unistd.h&gt;#include &lt;errno.h&gt;// 功能：往一个描述符写n字节// 参数：fd-文件描述符ssize_t writen(int fd, const void *vptr, size_t n) { size_t nleft; ssize_t nwritten; const char *ptr; ptr = vptr; nleft = n; while (nleft &gt; 0) { if ( (nwritten = write(fd, ptr, nleft)) &lt;= 0) { if (nwritten &lt; 0 &amp;&amp; errno == EINTR) { nwritten = 0; /* call write() again */ } else { return (-1); /* error */ } } nleft -= nwritten; ptr += nwritten; } return (n - nwritten);} readline 函数：1234567891011121314151617181920212223242526272829#include &lt;unistd.h&gt;#include &lt;errno.h&gt;// 功能：从一个描述符读文本行，一次一个字节，极端地慢ssize_t readline(int fd, void *vptr, size_t maxlen) { ssize_t n, rc; char c, *ptr; ptr = vptr; for (n = 1; n &lt;= maxlen; n++) { again: if ( (rc = read(fd, &amp;c, 1)) == 1) { *ptr++ = c; if (c == '\\n') { break; } } else if (rc == 0) { *ptr = 0; return (n - 1); } else { if (errno == EINTR) { goto again; } return (-1); } } *ptr = 0; return ((maxlen == (n-1))?(n-1):n);} EINTR 错误：表示系统调用被一个捕获的信号中断，如果发生该错误则继续进行读/写操作。 注意，这个 readline 函数每读一个字节的数据就调用一次系统的 read 函数。这是非常低效的。改用标准I/O函数库可以解决性能问题，但是会引发许多后勤问题，因为 stdio 缓冲区的状态是不可见的。 下面是一个 readline 函数较快速的版本。但这会导致新的问题：使用静态变量实现跨域相继函数调用的状态信息维护，使函数变得不可重入或者说非线程安全了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#define MAXLINE 4096static int read_cnt = 0;static char *read_ptr;static char read_buf[MAXLINE];static ssize_t my_read(int fd, char *ptr) { if (read_cnt &lt;= 0) { again: if ( (read_cnt = read(fd, read_buf, sizeof(read_buf))) &lt; 0) { if (errno == EINTR) { goto again; } return (-1); } else if (read_cnt == 0) { return (0); } read_ptr = read_buf; } read_cnt--; *ptr = *read_ptr++; return (1);}ssize_t readline(int fd, void *vptr, size_t maxlen) { ssize_t n, rc; char c, *ptr; ptr = vptr; for (n = 1; n &lt; maxlen; n++) { if ( (rc = my_read(fd, &amp;c)) == 1) { *ptr++ = c; if (c == '\\n') { break; } } else if (c == 0) { *ptr = 0; return (n - 1); } else { return (-1); } } *ptr = 0; return (n);}ssize_t readlinebuf(void **vptrptr) { if (read_cnt) { *vptrptr = read_ptr; } return (read_cnt);} 基本 TCP 套接字编程socket 函数123456789#include &lt;sys/socket.h&gt;// 功能：创建套接字（安装电话机）// 返回值：成功时返回文件描述符，失败是返回-1。int socket(int family, int type, int protocol);// Example:int tcp_socket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);int udp_socket = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP); 固定电话和套接字其实并无太大区别，下面会利用电话机讲解套接字的创建和使用方法。 输入参数： family：套接字中使用的地址簇 (Address Family) 或协议簇 (Protocol Family) 信息。 PF_UNSPEC (未定义) PF_INET：IPv4 PF_INET6：IPv6 PF_LOCAL：本地通信的 UNIX 协议簇 PF_PACKET：底层套接字的协议簇 注：PF 或 AF 开头的是相同的 type：套接字数据传输类型。 SOCK_STREAM：流式（stream），面向连接的套接字，收发数据的套接字内部有缓冲（buffer，就是字节数组），用于 TCP 套接字。 可靠的：传输过程中数据不会消失。 按序传递的：按序传输数据。 基于字节的：传输的数据不存在数据边界。 SOCK_DGRAM：数据报（datagram），面向消息的套接字，不存在连接的概念，用于 UDP 套接字。 不按序传递的，以数据的高速传输为目的：强调快速传输而非传输顺序。 不可靠的：传输的数据可能丢失也可能损毁。 传输的数据有数据边界。 限制每次传输的数据大小。 SOCK_RAW (原始) protocol：计算机间通信使用的协议信息地址簇中的协议号。 IPPROTO_TCP (TCP的协议号6) IPPROTO_UDP (UDP的协议号17) IPPROTO_ICMP (ICMP的协议号1) connect 函数12345#include &lt;sys/socket.h&gt;// 功能：（客户端）建立与TCP服务器的连接// 返回值：成功时返回0，失败时返回-1int connect(int sockfd, const struct sockaddr * servaddr, socklen_t addrlen); connect 函数导致当前套接字从 CLOSED 状态转移到 SYN_SENT 状态，若成功则再转移到 ESTABLISHED 状态。 bind 函数123456#include &lt;sys/socket.h&gt;// 功能：将初始化后的地址信息绑定到套接字// 参数：sockfd—套接字文件描述符，myaddr-存有地址信息的结构体变量地址，addrlen-结构体变量的长度// 返回值：成功时返回0，失败时返回-1int bind(int sockfd, struct sockaddr * myaddr, socklen_t addrlen); bind 把一个本地协议地址赋予一个套接字。调用 bind 函数可以指定一个端口号，可以指定一个 IP 地址，也可以两者都指定，还可以都不指定。 如果指定端口号为 0，则内核在 bind 被调用时选择一个临时端口； 如果 IP 地址为通配地址，那么内核将等到套接字已连接（TCP）或已在套接字上发出数据报（UDP）时才选择一个本地 IP 地址。 通配地址由常值 INADDR_ANY 来指定，其值一般为 0，它告知内核去选择 IP 地址。 1234567// IPv4struct sockaddr_in servaddr;servaddr.sin_addr.s_addr = htonl(INADDR_ANY);// IPv6struct sockaddr_in6 serv;serv.sin6_addr = in6addr_any; listen 函数（由 TCP 服务器调用）1234567#include &lt;sys/socket.h&gt;// 功能：服务器进入等待连接请求的状态// 参数：sock-一个未连接的套接字，将被转换为被动套接字，指示内核应接受指向该套接字的连接请求// backlog-连接请求队列的长度// 返回值：成功时返回0，失败时返回-1int listen(int sock, int backlog); listen 把一个未连接的套接字转换成被动套接字，指示内核应接受指向该套接字的连接请求。调用 listen 导致套接字从 CLOSED 状态转移到 LISTEN。 对于参数 backlog： backlog 被定义为两队列总和的最大值。 不想接受连接时，关闭套接字，不要把 backlog 定义为 0. accept 函数（由 TCP 服务器调用）123456#include &lt;sys/socket.h&gt;// 功能：从已完成连接队列队头返回下一个已完成连接。如果已完成连接队列为空，那么进程进入睡眠状态（套接字阻塞方式）// 参数：sockfd-监听套接字，cliaddr-客户进程的地址，addrlen-该地址的大小// 返回值：成功时返回已连接套接字，失败时返回-1int accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen); 该函数最多返回三个值： 一个既可能是新套接字描述符也可能是出错指示的整数 客户进程的协议地址（由 cliaddr 所指） 该地址的大小（由 addrlen 所指的） 如果我们对返回客户协议地址不感兴趣，可以把后两个参数都设为空指针。 fork 和 exec 函数（并发编程基础）**fork 是 Unix 中派生新进程的唯一方法**。 123#include &lt;unistd.h&gt;pid_t fork(void); fork 的特点是调用它一次，它却返回两次： 它在调用进程（父进程）中返回新派生进程（子进程）的 ID。 它在子进程中返回 0。 任何子进程只有一个父进程，子进程总是可以通过调用 getppid 取得父进程的进程 ID。 fork 的 2 种典型用法： 一个进程创建一个自身的副本：这样每个副本都可以在另一个副本执行其他任务的同时处理各自的操作（网络服务器的典型用法）。 一个进程想要执行另一个程序：先调用 fork 创建出一个自身的副本，然后其中一个副本（通常为子进程）调用 exec 把自身替换成新的程序（shell 之类程序的典型用法）。 exec：将当前进程映像替换成新的程序文件，而且该新程序通常从 main 函数开始执行。进程 ID 并不改变。我们称调用 exec 的进程为调用进程（calling process），称新执行的程序为新程序（new program）。下面是 6 个 exec 函数： 12345678910111213#include &lt;unistd.h&gt;int execl (const char *pathname, const char *arg0, ... /* (char *)0 */); int execv (const char *pathname, char *argv[] ); int execle(const char *pathname, const char *arg0, ... /* (char *)0, char *const envp[] */); int execve (const char *pathname, char *const argv[], char *const envp[] ); int execlp (const char *pathname, const char *arg0, ... /* (char *)0 */); int execvp (const char *pathname, char *const argv[]); 这 6 个 exec 函数的区别在于： 待执行的程序文件是由文件名（filename）还是由路径名（pathname）指定； 新程序的参数是一一列出还是由一个指针数组来引用； 把调用进程的环境传递给新程序还是给新程序指定新的环境。 并发服务器原理（重点）Unix 编写并发服务器最简单的方法就是 fork 一个子进程来服务每个客户。下面是一个典型的并发服务器的轮廓。 12345678910111213141516pid_t pid;int listenfd, connfd;listenfd = Socket( ... );/* fill in sockaddr_in{} with server's well known port */Bind(listenfd, ... );Listen(listenfd, LISTENQ);for( ; ; ){ connfd = Accept(listen, ... ); /* probably blocks*/ if( (pid = Fork()) == 0){ Close(listenfd); // 子进程关闭监听套接字 doit(connfd); // 处理请求 Close(connfd); // 完成客户端的请求后，子进程显式地关闭连接套接字 exit(0); // 上一个Close其实不是必须的，因为exit（进程终止）会关闭所有由内核打开的描述符。 } Close(connfd); // 父进程关闭已连接套接字} 当一个连接建立时，accept 返回，服务器接着调用 fork，然后由子进程通过已连接套接字 connfd 服务客户，父进程则通过监听套接字 listenfd 等待另一个连接。既然新的客户由子进程提供服务，父进程就关闭已连接套接字。 为什么父进程对 connfd 调用 close 没有终止它与客户的连接呢？ 原因：每个文件或套接字都有一个在文件表项中维护的引用计数，它是当前打开着的引用该文件或套接字的描述符的个数。fork 返回后，listenfd 和 connfd 这两个描述符在父进程和子进程间共享，它们各自的访问计数值都为 2。因此，当父进程关闭 connfd 时，只是将引用计数值从 2 减为 1，不会清理和释放该套接字的资源。 close 函数1234#include &lt;unistd.h&gt;// 功能：关闭套接字，终止TCP连接，导致相应的文件描述符引用值减1.int close(int sockfd); 如果确实想要在某个TCP连接上发送一个FIN，那么可以使用shtdown函数替换close函数。 getsockname 和 getpeername 函数123456789#include&lt;sys/socket.h&gt;// 功能：返回与某个套接字关联的本地协议地址// 返回值：成功返回0，出错返回-1.int getsockname (int sockfd, struct sockaddr *localaddr, socklen_t *addrlen);// 功能：返回与某个套接字关联的外地协议地址（peer）// 返回值：成功返回0，出错返回-1.int getpeername (int sockfd, struct sockaddr *peeraddr, socklen_t *addrlen); 这两个函数的最后一个参数都是值-结果参数。 需要这两个函数的理由： TCP 客户没有调用 bind 函数，connect 成功返回后，getsockname 用于返回由内核赋予该连接的本地 IP 地址和本地端口号。 在以端口号 0 调用 bind （告知内核去选择本地端口号）后，getsockname 用于返回由内核赋予的本地端口号。 getsockname 可用于获取某个套接字的地址族。 12345678910#include &quot;unp.h&quot;int sockfd_to_family(int sockfd){ struct sockaddr_storage ss; // 新的通用套接字地址结构 socklen_t len; len = sizeof(ss); if (getsockname(sockfd, (SA*)&amp;ss, &amp;len) &lt; 0) return (-1); return (ss.ss_family); } 在一个以通配 IP 地址调用 bind 的 TCP 服务器上，与某个客户的连接一旦连接，getsockname 就可以用于返回由内核赋予的本地 IP 地址。 当一个服务器是由调用过 accept 的某个进程通过调用 exec 执行程序时，它能够获取客户身份的唯一途径时调用 getpeername.（P95） Linux 文件函数Linux 系统不区分文件和套接字。 文件描述符 fd：系统分配给文件或套接字的整数。从 3 开始以由小到大的顺序编号（numbering），这是因为0、1、2 分别分配给标准输入、标准输出、标准错误。 open 函数12345678#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;// 功能：打开文件// 输入：path——文件名的字符串信息，flag——文件打开模式信息// 返回值：成功时返回为文件描述符，失败时返回-1int open(const char *path, int flag); 打开模式 含义 O_CREAT 必要时创建文件 O_TRUNC 删除全部现有数据 O_APPEND 维持现有数据，保存到其后面 O_RDONLY 只读打开 O_WRONLY 只写打开 O_RDWR 读写打开 close 函数123456#include &lt;unistd.h&gt;// 功能：关闭文件// 输入：fd-需要关闭的文件或套接字的文件描述符// 返回值：成功时返回0，失败时返回-1int close(int fd) write 函数123456#include &lt;unistd.h&gt;// 功能：将数据写入文件// 输入：fd-显示数据传输对象的文件描述符，buf-保存要传输数据的缓冲地址值，nbytes-要传输的数据字节数。ssizet是通过typdef声明的signed int类型。// 返回值：成功时返回写入的字节数，失败时返回-1ssizet write(int fd, const void * buf, size_t nbytes) read 函数123456#include &lt;unistd.h&gt;// 功能：读取文件中的数据// 输入：fd-显示数据接收对象的文件描述符，buf-保存要接收数据的缓冲地址值，nbytes-要接收数据的最大字节数。ssizet是通过typdef声明的signed int类型。// 返回值：成功时返回写入的字节数，失败时返回-1ssizet read(int fd, const void * buf, size_t nbytes) 参考资料https://blog.csdn.net/zzxiaozhao/article/details/102637708 https://wuhlan3.gitee.io/wuhlan3/2021/07/29/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89","link":"/2021/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%B8%80-%E5%9F%BA%E6%9C%ACTCP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C语言","slug":"C语言","link":"/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"linux 配置","slug":"linux-配置","link":"/tags/linux-%E9%85%8D%E7%BD%AE/"},{"name":"操作系统理论","slug":"操作系统理论","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"STL","slug":"STL","link":"/tags/STL/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"计算机网络理论","slug":"计算机网络理论","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%90%86%E8%AE%BA/"},{"name":"linux 网络编程","slug":"linux-网络编程","link":"/tags/linux-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"categories":[{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"Vscode","slug":"Vscode","link":"/categories/Vscode/"},{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"操作系统","slug":"操作系统","link":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"MySQL","slug":"MySQL","link":"/categories/MySQL/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"计算机网络","slug":"计算机网络","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]}
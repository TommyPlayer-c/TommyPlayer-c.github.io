<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Keep moving</title>
  
  
  <link href="https://tommyplayer-c.github.io/atom.xml" rel="self"/>
  
  <link href="https://tommyplayer-c.github.io/"/>
  <updated>2021-12-01T10:48:00.380Z</updated>
  <id>https://tommyplayer-c.github.io/</id>
  
  <author>
    <name>TommyPlayer</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网络编程笔记(七)-制作 HTTP 服务器端</title>
    <link href="https://tommyplayer-c.github.io/2021/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%B8%83-%E5%88%B6%E4%BD%9C-HTTP-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/"/>
    <id>https://tommyplayer-c.github.io/2021/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%B8%83-%E5%88%B6%E4%BD%9C-HTTP-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/</id>
    <published>2021-10-20T16:00:00.000Z</published>
    <updated>2021-12-01T10:48:00.380Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络编程笔记-七-制作-HTTP-服务器端"><a href="#网络编程笔记-七-制作-HTTP-服务器端" class="headerlink" title="网络编程笔记(七)-制作 HTTP 服务器端"></a>网络编程笔记(七)-制作 HTTP 服务器端</h1><span id="more"></span><p>代码及注释如下，需要基础的 HTTP 知识才能理解。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALL_BUF 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">request_handler</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>; <span class="comment">// 线程入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_data</span><span class="params">(FILE *fp, <span class="keyword">char</span> *ct, <span class="keyword">char</span> *file_name)</span></span>;  <span class="comment">// 向浏览器客户端发送数据</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">content_type</span><span class="params">(<span class="keyword">char</span> *file)</span></span>; <span class="comment">// 数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_error</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> serv_sock, clnt_sock;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">clnt_adr</span>;</span></span><br><span class="line">  <span class="keyword">int</span> clnt_adr_size;</span><br><span class="line">  <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line">  <span class="keyword">pthread_t</span> t_id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt; \n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span>)</span><br><span class="line">    error_handling(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">  serv_adr.sin_family = AF_INET;</span><br><span class="line">  serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">  serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bind(serv_sock, (struct sockaddr *)&amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">    error_handling(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (listen(serv_sock, <span class="number">20</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">    error_handling(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    clnt_adr_size = <span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line">    clnt_sock = accept(serv_sock, (struct sockaddr *)&amp;clnt_adr, &amp;clnt_adr_size);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connection request : %s %d\n&quot;</span>, inet_ntoa(clnt_adr.sin_addr),</span><br><span class="line">           ntohs(clnt_adr.sin_port));</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;t_id, <span class="literal">NULL</span>, request_handler, &amp;clnt_sock);</span><br><span class="line">    pthread_detach(t_id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  close(serv_sock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">request_handler</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> clnt_sock = *((<span class="keyword">int</span> *)arg);</span><br><span class="line">  <span class="keyword">char</span> req_line[SMALL_BUF];</span><br><span class="line">  FILE *clnt_read;</span><br><span class="line">  FILE *clnt_write;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> method[<span class="number">10</span>];</span><br><span class="line">  <span class="keyword">char</span> ct[<span class="number">15</span>];</span><br><span class="line">  <span class="keyword">char</span> file_name[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将套接字转换为标准I/O</span></span><br><span class="line">  clnt_read = fdopen(clnt_sock, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  clnt_write = fdopen(dup(clnt_sock), <span class="string">&quot;w&quot;</span>);   <span class="comment">// 复制文件描述符，实现半关闭模型</span></span><br><span class="line">  fgets(req_line, SMALL_BUF, clnt_read);      <span class="comment">// 保存请求行数据</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strstr</span>(req_line, <span class="string">&quot;HTTP/&quot;</span>) == <span class="literal">NULL</span>) &#123;    <span class="comment">// 查看是否为HTTP提出的请求</span></span><br><span class="line">    send_error(clnt_write);</span><br><span class="line">    fclose(clnt_read);</span><br><span class="line">    fclose(clnt_write);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(method, strtok(req_line, <span class="string">&quot; /&quot;</span>));   <span class="comment">// 请求方式</span></span><br><span class="line">  <span class="built_in">strcpy</span>(file_name, strtok(<span class="literal">NULL</span>, <span class="string">&quot; /&quot;</span>));    <span class="comment">// 请求的文件名</span></span><br><span class="line">  <span class="built_in">strcpy</span>(ct, content_type(file_name));      <span class="comment">// 请求内容类型</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(method, <span class="string">&quot;GET&quot;</span>) != <span class="number">0</span>) &#123;         <span class="comment">// 是否为GET请求       </span></span><br><span class="line">    send_error(clnt_write);</span><br><span class="line">    fclose(clnt_read);</span><br><span class="line">    fclose(clnt_write);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fclose(clnt_read);</span><br><span class="line"></span><br><span class="line">  send_data(clnt_write, ct, file_name);   <span class="comment">// 服务端响应消息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_data</span><span class="params">(FILE *fp, <span class="keyword">char</span> *ct, <span class="keyword">char</span> *file_name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> protocol[] = <span class="string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>;          <span class="comment">// 状态行(用HTTP1.1版本进行响应，你的请求已经正确处理)</span></span><br><span class="line">  <span class="keyword">char</span> server[] = <span class="string">&quot;Server:Linux Web Server \r\n&quot;</span>;   <span class="comment">// 服务端名</span></span><br><span class="line">  <span class="keyword">char</span> cnt_len[] = <span class="string">&quot;Content-length:2048\r\n&quot;</span>;       <span class="comment">// 数据长度不超过2048</span></span><br><span class="line">  <span class="keyword">char</span> cnt_type[SMALL_BUF];</span><br><span class="line">  <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line">  FILE *send_file;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sprintf</span>(cnt_type, <span class="string">&quot;Content-type:%s\r\n\r\n&quot;</span>, ct);   <span class="comment">// 两个\r\n是因为头部行和正文之间有一个空行</span></span><br><span class="line">  send_file = fopen(file_name, <span class="string">&quot;r&quot;</span>);                  <span class="comment">// 打开本地文件</span></span><br><span class="line">  <span class="keyword">if</span> (send_file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    send_error(fp);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">fputs</span>(protocol, fp);    <span class="comment">// 发送状态行</span></span><br><span class="line">  <span class="comment">// 发送头部行</span></span><br><span class="line">  <span class="built_in">fputs</span>(server, fp);      </span><br><span class="line">  <span class="built_in">fputs</span>(cnt_len, fp);</span><br><span class="line">  <span class="built_in">fputs</span>(cnt_type, fp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (fgets(buf, BUF_SIZE, send_file) != <span class="literal">NULL</span>) &#123;   <span class="comment">// 发送正文（HTML对象）</span></span><br><span class="line">    <span class="built_in">fputs</span>(buf, fp);</span><br><span class="line">    fflush(fp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fflush(fp);</span><br><span class="line">  fclose(fp);   <span class="comment">// 服务端响应客服端请求后立即断开连接（短链接）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">content_type</span><span class="params">(<span class="keyword">char</span> *file)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> extension[SMALL_BUF];</span><br><span class="line">  <span class="keyword">char</span> file_name[SMALL_BUF];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(file_name, file);</span><br><span class="line">  strtok(file_name, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(extension, strtok(<span class="literal">NULL</span>, <span class="string">&quot;.&quot;</span>));   <span class="comment">// 文件拓展名</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(extension, <span class="string">&quot;html&quot;</span>) || !<span class="built_in">strcmp</span>(extension, <span class="string">&quot;htm&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;text/html&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;text/plain&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_error</span><span class="params">(FILE *fp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> protocol[] = <span class="string">&quot;HTTP/1.0 400 Bad Request\r\n&quot;</span>;    <span class="comment">// 请求文件不存在</span></span><br><span class="line">  <span class="keyword">char</span> server[] = <span class="string">&quot;Server:Linux Web Server \r\n&quot;</span>;</span><br><span class="line">  <span class="keyword">char</span> cnt_len[] = <span class="string">&quot;Content-length:2048\r\n&quot;</span>;</span><br><span class="line">  <span class="keyword">char</span> cnt_type[] = <span class="string">&quot;Content-type:text/html\r\n\r\n&quot;</span>;</span><br><span class="line">  <span class="keyword">char</span> content[] =</span><br><span class="line">      <span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;NETWORK&lt;/title&gt;&lt;/head&gt;&quot;</span></span><br><span class="line">      <span class="string">&quot;&lt;body&gt;&lt;font size=+5&gt;&lt;br&gt;br error filename request!&quot;</span></span><br><span class="line">      <span class="string">&quot;&lt;/font&gt;&lt;body&gt;&lt;html&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fputs</span>(protocol, fp);</span><br><span class="line">  <span class="built_in">fputs</span>(server, fp);</span><br><span class="line">  <span class="built_in">fputs</span>(cnt_len, fp);</span><br><span class="line">  <span class="built_in">fputs</span>(cnt_type, fp);</span><br><span class="line"></span><br><span class="line">  fflush(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">  <span class="built_in">fputs</span>(<span class="string">&quot;\n&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://cloud.tencent.com/developer/article/1350710">https://cloud.tencent.com/developer/article/1350710</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;网络编程笔记-七-制作-HTTP-服务器端&quot;&gt;&lt;a href=&quot;#网络编程笔记-七-制作-HTTP-服务器端&quot; class=&quot;headerlink&quot; title=&quot;网络编程笔记(七)-制作 HTTP 服务器端&quot;&gt;&lt;/a&gt;网络编程笔记(七)-制作 HTTP 服务器端&lt;/h1&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://tommyplayer-c.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="linux 网络编程" scheme="https://tommyplayer-c.github.io/tags/linux-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>网络编程笔记(六)-标准IO、epoll、多线程</title>
    <link href="https://tommyplayer-c.github.io/2021/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%85%AD-%E6%A0%87%E5%87%86IO%E3%80%81epoll%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://tommyplayer-c.github.io/2021/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%85%AD-%E6%A0%87%E5%87%86IO%E3%80%81epoll%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-10-20T16:00:00.000Z</published>
    <updated>2021-10-24T08:34:01.091Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络编程笔记-六-标准IO、epoll、多线程"><a href="#网络编程笔记-六-标准IO、epoll、多线程" class="headerlink" title="网络编程笔记(六)-标准IO、epoll、多线程"></a>网络编程笔记(六)-标准IO、epoll、多线程</h1><blockquote><p>参考《TCP/IP 网络编程》15、16、17、18 章</p></blockquote><span id="more"></span><h1 id="套接字和标准-I-O"><a href="#套接字和标准-I-O" class="headerlink" title="套接字和标准 I/O"></a>套接字和标准 I/O</h1><p>标准 I/O 函数的 2 个优点：</p><ul><li>良好的移植性（Portability）。</li><li>利用缓冲提高性能。</li></ul><p>使用 read 和 write 函数传输 400M 文件的时间<strong>远远大于</strong>使用标准函数 fgets 和 fputs。</p><p>标准 I/O 函数的几个缺陷：</p><ul><li><p>不容易进行双向通信。如果要同时进行读写操作，则应以 r+、w+、a+ 模式打开。</p></li><li><p>有时候可能频繁调用 fflush。每次切换读写工作状态都应该调用 fflush 函数。</p></li><li><p>需要以 <strong>FILE 结构体指针</strong>形式返回文件描述符；</p></li></ul><p>利用 fdopen 函数将文件描述符转换成 FILE 结构体指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">fildes: 需要转换的文件描述符  </span></span><br><span class="line"><span class="comment">mode: 将要创建的 FILE 结构体指针的模式信息 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 成功时返回转换的FILE结构体指针，失败时返回 NULL  </span></span><br><span class="line"><span class="function">FILE * <span class="title">fdopen</span><span class="params">(<span class="keyword">int</span> fildes, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span>;  </span><br></pre></td></tr></table></figure><p>利用 fileno 函数将 FILE 结构体指针转换成文件描述符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功时返回转换后的文件描述符，失败时返回-1  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fileno</span><span class="params">(FILE * stream)</span></span>;  </span><br></pre></td></tr></table></figure><h1 id="关于-I-O-分离流的其他内容"><a href="#关于-I-O-分离流的其他内容" class="headerlink" title="关于 I/O 分离流的其他内容"></a>关于 I/O 分离流的其他内容</h1><h2 id="I-O-分离流的方式"><a href="#I-O-分离流的方式" class="headerlink" title="I/O 分离流的方式"></a>I/O 分离流的方式</h2><p>I/O 流分离的方式：</p><ul><li>TCP I/O 过程（routine）分离：通过调用 fork 函数复制出一个文件描述符，以区分输入和输出中使用的文件描述符，虽然文件描述符不会根据输入和输出进行区分，但是我们分开了 2 个文件描述符的用途。</li><li>调用 2 次调用 fdopen：创建读模式 FILE 指针和写模式 FILE 指针，分离了输入工具和输出工具。</li></ul><p>TCP I/O 过程（routine）分离流的好处：</p><ul><li><p>通过分开输入过程（代码）和输出过程降低实现难度。</p></li><li><p>与输入无关的输出操作可以提高速度。</p></li></ul><p><u>2 次调用 fdopen 分离流的目的</u>：</p><ul><li><p>为了将 FILE 指针按读模式、写模式加以区分。</p></li><li><p>可以通过区分读写模式降低难度。</p></li><li><p>通过区分 I/O 缓冲提高缓冲性能。</p></li></ul><h2 id="流分离带来的问题"><a href="#流分离带来的问题" class="headerlink" title="流分离带来的问题"></a>流分离带来的问题</h2><p>流分离带来的问题：<u>终止流时无法半关闭</u>。读模式 FILE 指针、写模式 FILE 指针都是基于同一个文件描述符创建的。<u>因此，针对任意一个 FILE 指针调用 fclose 都将关闭文件描述符，终止套接字</u>。</p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110241629678.png" alt="image-20211018074650196" style="zoom:67%;" /><p>解决方法：在创建 FILE 指针前复制文件描述符，然后利用各自的文件描述符创建读模式 FILE 指针和写模式 FILE 指针，这样销毁所有文件描述符后才能销毁套接字（引用计数）。</p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110241629220.png" alt="image-20211018075159917" style="zoom:67%;" /><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110241629457.png" alt="image-20211018074937124" style="zoom:67%;" /><h2 id="文件描述符的复制"><a href="#文件描述符的复制" class="headerlink" title="文件描述符的复制"></a>文件描述符的复制</h2><h2 id="dup-和-dup2-函数"><a href="#dup-和-dup2-函数" class="headerlink" title="dup 和 dup2 函数"></a>dup 和 dup2 函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> fildes)</span>  </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 成功时返回复制的文件描述符，失败时返回-1</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="function">fildes：需要复制的文件描述符</span></span></span><br><span class="line"><span class="comment"><span class="function">filders2：明确指定的文件描述符整数值</span></span></span><br><span class="line"><span class="comment"><span class="function">*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> fildes, <span class="keyword">int</span> fildes2)</span>  </span></span><br></pre></td></tr></table></figure><blockquote><p>无论复制出多少文件描述符，均应调用 shutdown 函数发送 EOF 并进入半关闭状态。</p></blockquote><h1 id="优于-select-的-epoll"><a href="#优于-select-的-epoll" class="headerlink" title="优于 select 的 epoll"></a>优于 select 的 epoll</h1><h2 id="select-和-epoll-的比较"><a href="#select-和-epoll-的比较" class="headerlink" title="select 和 epoll 的比较"></a>select 和 epoll 的比较</h2><p>select 不适合以 web 服务器端开发为主流的现代开发环境，所以要学习 Linux 平台下的 epoll。</p><p>基于 select 的 I/O 复用技术速度慢的原因：</p><ul><li><p>调用 select 函数后常见的<strong>针对所有文件描述符的循环语句</strong>。</p></li><li><p>每次调用 select 函数时都需要向函数传递监视对象信息。 </p></li></ul><p>select 的优点：</p><ul><li><p>服务器端接入者少。</p></li><li><p>程序具有兼容性——<u>大部分操作系统都支持 select 函数</u>。</p></li></ul><h2 id="epoll-函数"><a href="#epoll-函数" class="headerlink" title="epoll 函数"></a>epoll 函数</h2><h3 id="epoll-create-函数"><a href="#epoll-create-函数" class="headerlink" title="epoll_create 函数"></a>epoll_create 函数</h3><p>epoll_create：向操作系统请求创建保存 epoll 文件描述符的空间，对应 select 方式下声明的 fd_set 变量。该函数返回的文件描述符主要用于区分 epoll 例程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// size: epoll实例的大小</span></span><br><span class="line"><span class="comment">// 返回值：成功时返回epoll文件描述符，失败时返回-1  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span>  </span></span><br></pre></td></tr></table></figure><blockquote><p>注意，size 只是建议 epoll 例程大小，仅供操作系统参考。Linux 2.6.8 之后的内核将完全忽略 size 参数，因为内核会根据情况调整 epoll 例程的大小。</p></blockquote><h3 id="epoll-ctl-函数"><a href="#epoll-ctl-函数" class="headerlink" title="epoll_ctl 函数"></a>epoll_ctl 函数</h3><p>epoll_ctl：向空间（对应于 select 中的位数组）注册并注销文件描述符，对应 select 中的 FD_SET、FD_CLR 函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">epfd：用于注册监视对象的epoll例程的文件描述符。 </span></span><br><span class="line"><span class="comment">op：用于指定监视对象的添加、删除或更改。</span></span><br><span class="line"><span class="comment">fd：需要注册的监视对象文件描述符。</span></span><br><span class="line"><span class="comment">event：监视对象事件类型。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 成功时返回0，失败时返回-1 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 用法：</span></span></span><br><span class="line"><span class="function">struct epoll_event event</span>;</span><br><span class="line">event.events = EPOLLIN;<span class="comment">// 详见结构体 epoll_event</span></span><br><span class="line">event.data.fd = sockfd;</span><br><span class="line"><span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, sockfd, &amp;event);  </span><br></pre></td></tr></table></figure><p>举例：</p><ul><li><code>epoll_ctl(A, EPOLL_CTL_ADD, B, C);</code> “epoll 例程中 A 注册文件描述符 B，主要目的是监视参数 C 中的事件。</li><li><code>epoll_ctl(A, EPOLL_CTL_DEL, B, NULL);</code> ”从 epoll 例程 A 中删除文件描述符 B。“</li></ul><p>op 操作：</p><ul><li>EPOLL_CTL_ADD：将文件描述符注册到 epoll 例程。</li><li>EPOLL_CTL_DEL：从 epoll 例程中删除文件描述符。使用时需向第四个参数传递 NULL。</li><li>EPOLL_CTL_MOD：更改注册的文件描述符的关注事件发生情况。</li></ul><h3 id="epoll-wait-函数"><a href="#epoll-wait-函数" class="headerlink" title="epoll_wait 函数"></a>epoll_wait 函数</h3><p>epoll_wait：等待文件描述符发生变化，类似 select 函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    epfd：标识事件发生监视范围epoll例程的文件描述符。</span></span><br><span class="line"><span class="comment">    events：保存发生事件的文件描述符集合的结构体地址值。</span></span><br><span class="line"><span class="comment">    maxevents：第二个参数中可以保存的最大事件数。 </span></span><br><span class="line"><span class="comment">    timeout：以毫秒为单位的等待时间，传递-1时，一直等待直到发生事件。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 返回值：成功时返回发生事件的文件描述符数，同时在第二个参数指向的缓冲中保存发生事件的文件描述符集合。失败时返回-1  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span>  </span></span><br></pre></td></tr></table></figure><h3 id="结构体-epoll-event-和-epoll-data"><a href="#结构体-epoll-event-和-epoll-data" class="headerlink" title="结构体 epoll_event 和 epoll_data"></a>结构体 epoll_event 和 epoll_data</h3><p>select 函数中通过 fd_set 变量查看事件发生与否，epoll 通过以下结构体将发生事件的文件描述符集中到一起：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//epoll将发生事件的文件描述符集中在一起，放在epoll_event结构体中  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>&#123;</span>  </span><br><span class="line">    <span class="keyword">__uint32_t</span> events;  </span><br><span class="line">    <span class="keyword">epoll_data_t</span> data;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span>&#123;</span>  </span><br><span class="line">    <span class="keyword">void</span> * ptr;  </span><br><span class="line">    <span class="keyword">int</span> fd;  </span><br><span class="line">    <span class="keyword">__uint32_t</span> u32;  </span><br><span class="line">    <span class="keyword">__uint64_t</span> u64;  </span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;  </span><br></pre></td></tr></table></figure><p>声明足够大的 epoll_event 结构体数组后，传递给 epoll_wait 函数时，发生变化的文件描述符信息将被填入该数组，无需像 select 一样对所有文件描述符进行循环。</p><p>epoll_event 成员 epoll_events 中可以保存的常量及所指的事件类型：</p><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110241629534.png" alt="image-20211019203510040"></p><h2 id="基于-epoll-的回声服务器端"><a href="#基于-epoll-的回声服务器端" class="headerlink" title="基于 epoll 的回声服务器端"></a>基于 epoll 的回声服务器端</h2><p>注意与 <a href="https://tommyplayer-c.github.io/2021/10/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-2021-10-06-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%B8%89-IO%E5%A4%8D%E7%94%A8%EF%BC%9Aselect%E5%92%8Cpoll%E5%87%BD%E6%95%B0/#TCP-%E5%9B%9E%E5%B0%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%BF%AE%E8%AE%A2%E7%89%88%EF%BC%89">select</a> 进行对比。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// echo_epollserv.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLL_SIZE 50</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> serv_sock, clnt_sock;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">clnt_adr</span>;</span></span><br><span class="line">  <span class="keyword">socklen_t</span> adr_sz;</span><br><span class="line">  <span class="keyword">int</span> str_len, i;</span><br><span class="line">  <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">ep_events</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">  <span class="keyword">int</span> epfd, event_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (serv_sock == <span class="number">-1</span>) &#123;</span><br><span class="line">    error_handling(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">  serv_adr.sin_family = AF_INET;</span><br><span class="line">  serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">  serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bind(serv_sock, (struct sockaddr *)&amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">    error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (listen(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">    error_handling(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  epfd = epoll_create(EPOLL_SIZE);  <span class="comment">//创建epoll例程</span></span><br><span class="line">  ep_events = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct epoll_event) * EPOLL_SIZE);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将serv_sock添加到例程空间中</span></span><br><span class="line">  event.events = EPOLLIN; </span><br><span class="line">  event.data.fd = serv_sock;</span><br><span class="line">  epoll_ctl(epfd, EPOLL_CTL_ADD, serv_sock, &amp;event);  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    event_cnt = epoll_wait(epfd, ep_events, EPOLL_SIZE, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event_cnt == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;epoll_wait() error!&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; event_cnt; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ep_events[i].data.fd == serv_sock) &#123;</span><br><span class="line">        adr_sz = <span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line">        clnt_sock = accept(serv_sock, (struct sockaddr *)&amp;clnt_adr, &amp;adr_sz);</span><br><span class="line">        </span><br><span class="line">        event.events = EPOLLIN;</span><br><span class="line">        event.data.fd = clnt_sock;</span><br><span class="line">        epoll_ctl(epfd, EPOLL_CTL_ADD, clnt_sock, &amp;event);  <span class="comment">//将请求连接的套接字添加到epoll例程中</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connected client : %d \n&quot;</span>, clnt_sock);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;  <span class="comment">// read message</span></span><br><span class="line">        str_len = read(ep_events[i].data.fd, buf, BUF_SIZE);</span><br><span class="line">        <span class="keyword">if</span> (str_len == <span class="number">0</span>) &#123;  <span class="comment">// close request!</span></span><br><span class="line">          epoll_ctl(epfd, EPOLL_CTL_DEL, ep_events[i].data.fd, <span class="literal">NULL</span>); <span class="comment">// 将断开连接的套接字从epoll例程中移除</span></span><br><span class="line">          close(ep_events[i].data.fd);</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;closed client %d \n&quot;</span>, ep_events[i].data.fd);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          write(ep_events[i].data.fd, buf, str_len);  <span class="comment">// echo！</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  close(serv_sock);</span><br><span class="line">  close(epfd);    <span class="comment">// 注意关闭epoll例程</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">  <span class="built_in">fputs</span>(<span class="string">&quot;\n&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="边缘触发和条件触发"><a href="#边缘触发和条件触发" class="headerlink" title="边缘触发和条件触发"></a>边缘触发和条件触发</h2><p>边缘触发和条件触发的区别——在于发生事件的时间点：</p><ul><li>条件触发：只要输入缓冲有数据，就会一直通知该事件。</li><li>边缘触发：输入缓冲收到数据时，仅注册一次事件。</li></ul><p>epoll 默认以条件触发方式工作，select 也是以条件触发方式工作的。</p><p>实现边缘触发服务器的原理：通过 errno 变量验证错误原因；使用 fcntl 函数更改套接字选项，添加非阻塞 O_NONBLOCK 表至，完成非阻塞 I/O。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setnonblockingmode</span><span class="params">(<span class="keyword">int</span> fd)</span></span>&#123;  </span><br><span class="line"><span class="keyword">int</span> flag = <span class="built_in">fcntl</span>(fd, F_GETFL, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">fcntl</span>(fd, F_SETFL, flag|O_NONBLOCK);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>边缘触发的优点：可以分离接收数据和处理数据的时间点。</p><h1 id="多线程服务器端的实现"><a href="#多线程服务器端的实现" class="headerlink" title="多线程服务器端的实现"></a>多线程服务器端的实现</h1><h2 id="pthread-create-和-pthread-join"><a href="#pthread-create-和-pthread-join" class="headerlink" title="pthread_create 和 pthread_join"></a>pthread_create 和 pthread_join</h2><ol><li><p>pthread_create</p><pre><code>功能：生成线程必须在调用此函数前就为 pthread_t 对象分配内存空间（malloc）    `thread_handles = malloc(thread_countsizeof(pthread_t));`技巧：为每一个线程赋予唯一的 int 型参数 rank`pthread_create(&amp;thread_handles[thread], NULL, Hello, (void) thread);`thread_p 是指针！</code></pre></li><li><p>pthread_join</p><pre><code>分支合并（join）到主线程的直线中pthread_join(thread_handles[thread], NULL);thread_p 是值！</code></pre><p>类似的函数有 int pthread_detach(pthread_t thread); 调用 pthread_detach 不会引起线程终止或进入阻塞状态。</p></li></ol><h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><ol><li><p>临界区</p><pre><code>实例：计算 pi 的线程函数竞争条件    当多个线程都要访问共享变量或共享文件这样的共享资源时，如果其中一个访问是更新操作，那么这些访问就可能会导致某种错误临界区    一个更新共享资源的代码段，一次只允许一个线程执行该代码段    必须串行执行临界区的代码</code></pre></li><li><p>互斥量（mutex）</p><pre><code>特殊类型 pthread_mutex_t    初始化和销毁        pthread_mutex_int            pthread_mutex_init(&amp;mutex, NULL);        pthread_mutex_destroy            pthread_mutex_destroy(&amp;mutex);    上锁和解锁        pthread_mutex_lock            pthread_mutex_lock(&amp;mutex);        pthread_mutex_unlock            pthread_mutex_unlock(&amp;mutex);使用互斥量时，多个进程进入临界区的顺序是随机的</code></pre></li><li><p>信号量（semaphore）</p><pre><code>信号量定义：一种特殊类型的 unsigned int 无符号整型变量，可以赋值为 0、1、2……优点    能够初始化为任何非负值    信号量没有归属权，任何线程都能够对锁上的信号量进行解锁生产者-消费者同步    一个消费者线程在继续运行前，需要等待一些条件或数据被生产者线程创建基本操作    引入 semaphore 头文件    和 pthread_t 一样，init 前需要分配内存        semaphores = malloc(thread_count*sizeof(sem_t));    初始化和销毁        sem_init        sem_destroy    P 操作和 V 操作        sem_wait            将信号量减 1            如果值变成 负数，则阻塞执行 P 操作的线程，否则线程继续执行        sem_post            将信号量加 1            如果值 小于等于零，则唤醒一个等待进程</code></pre></li></ol><h2 id="多线程并发服务器端的实现（聊天程序）"><a href="#多线程并发服务器端的实现（聊天程序）" class="headerlink" title="多线程并发服务器端的实现（聊天程序）"></a>多线程并发服务器端的实现（聊天程序）</h2><p>服务器：可以同时连接多个客户</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_CLNT 256</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">handle_clnt</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_msg</span><span class="params">(<span class="keyword">char</span> *msg, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> clnt_cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> clnt_socks[MAX_CLNT];</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> serv_sock;</span><br><span class="line">  <span class="keyword">int</span> clnt_sock;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clnt_adr</span>;</span></span><br><span class="line">  <span class="keyword">int</span> clnt_adr_sz;</span><br><span class="line">  <span class="keyword">pthread_t</span> t_id;       <span class="comment">// 传递给线程的id</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_mutex_init</span>(</span><br><span class="line">      &amp;mutx, <span class="literal">NULL</span>);  <span class="comment">// 互斥访问临界区——clnt_cnt和clnt_socks</span></span><br><span class="line">  serv_sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (serv_sock == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">error_handling</span>(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(serv_adr));</span><br><span class="line">  serv_adr.sin_family = AF_INET;</span><br><span class="line">  serv_adr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">  serv_adr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">bind</span>(serv_sock, (struct sockaddr *)&amp;serv_adr, <span class="built_in"><span class="keyword">sizeof</span></span>(serv_adr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">error_handling</span>(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">listen</span>(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">error_handling</span>(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    clnt_adr_sz = <span class="built_in"><span class="keyword">sizeof</span></span>(clnt_adr);</span><br><span class="line">    clnt_sock = <span class="built_in">accept</span>(serv_sock, (struct sockaddr *)&amp;clnt_adr, &amp;clnt_adr_sz);</span><br><span class="line">    <span class="comment">// 以下代码访问临界区，将相关信息写入clnt_cnt和clnt_socks。</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutx);</span><br><span class="line">    clnt_socks[clnt_cnt++] = clnt_sock;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutx);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;t_id, <span class="literal">NULL</span>, handle_clnt, (<span class="keyword">void</span> *)&amp;clnt_sock);</span><br><span class="line">    <span class="built_in">pthread_detach</span>(t_id);   <span class="comment">// 从内存中销毁完全已终止的线程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Connetcted client IP :%s \n&quot;</span>, <span class="built_in">inet_ntoa</span>(clnt_adr.sin_addr));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">close</span>(serv_sock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">handle_clnt</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> clnt_sock = *((<span class="keyword">int</span> *)arg);  <span class="comment">// 传递给线程的参数</span></span><br><span class="line">  <span class="keyword">int</span> str_len = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">char</span> msg[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ((str_len = <span class="built_in">read</span>(clnt_sock, msg, <span class="built_in"><span class="keyword">sizeof</span></span>(msg))) != <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">send_msg</span>(msg, str_len);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_mutex_lock</span>(&amp;mutx);  <span class="comment">// 访问临界区前获得锁</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; clnt_cnt; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (clnt_sock == clnt_socks[i]) &#123; <span class="comment">// 覆盖删除</span></span><br><span class="line">      <span class="keyword">while</span> (i++ &lt; clnt_cnt - <span class="number">1</span>) clnt_socks[i] = clnt_socks[i + <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clnt_cnt--;</span><br><span class="line">  <span class="built_in">pthread_mutex_unlock</span>(&amp;mutx);</span><br><span class="line">  <span class="built_in">close</span>(clnt_sock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// send to all</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_msg</span><span class="params">(<span class="keyword">char</span> *msg, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_mutex_lock</span>(&amp;mutx);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; clnt_cnt; i++) &#123;</span><br><span class="line">    <span class="built_in">write</span>(clnt_socks[i], msg, len);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_mutex_unlock</span>(&amp;mutx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">  <span class="built_in">fputs</span>(<span class="string">&quot;\n&quot;</span>, stderr);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：分离输入和输出而创建线程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME_SIZE 20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">send_msg</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">recv_msg</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> name[NAME_SIZE] = <span class="string">&quot;[DEFAULT]&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> msg[BUF_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sock;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>;</span></span><br><span class="line">  <span class="keyword">pthread_t</span> snd_thread, rcv_thread;</span><br><span class="line">  <span class="keyword">void</span> *thread_return;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt; &lt;name&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sprintf</span>(name, <span class="string">&quot;[%s]&quot;</span>, argv[<span class="number">3</span>]);</span><br><span class="line">  sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (sock == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">error_handling</span>(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(serv_adr));</span><br><span class="line">  serv_adr.sin_family = AF_INET;</span><br><span class="line">  serv_adr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(argv[<span class="number">1</span>]);</span><br><span class="line">  serv_adr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">connect</span>(sock, (struct sockaddr *)&amp;serv_adr, <span class="built_in"><span class="keyword">sizeof</span></span>(serv_adr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">error_handling</span>(<span class="string">&quot;connect() error\r\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect to the server!\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_create</span>(&amp;snd_thread, <span class="literal">NULL</span>, send_msg, (<span class="keyword">void</span> *)&amp;sock);</span><br><span class="line">  <span class="built_in">pthread_create</span>(&amp;rcv_thread, <span class="literal">NULL</span>, recv_msg, (<span class="keyword">void</span> *)&amp;sock);</span><br><span class="line">  <span class="built_in">pthread_join</span>(snd_thread, &amp;thread_return);</span><br><span class="line">  <span class="built_in">pthread_join</span>(rcv_thread, &amp;thread_return);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">close</span>(sock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">  <span class="built_in">fputs</span>(<span class="string">&quot;\n&quot;</span>, stderr);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">send_msg</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sock = *((<span class="keyword">int</span> *)arg);</span><br><span class="line">  <span class="keyword">char</span> name_msg[NAME_SIZE + BUF_SIZE];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">fgets</span>(msg, BUF_SIZE, stdin);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(msg, <span class="string">&quot;q\n&quot;</span>) || !<span class="built_in">strcmp</span>(msg, <span class="string">&quot;Q\n&quot;</span>)) &#123;</span><br><span class="line">      <span class="built_in">close</span>(sock);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sprintf</span>(name_msg, <span class="string">&quot;%s %s&quot;</span>, name, msg);</span><br><span class="line">    <span class="built_in">write</span>(sock, name_msg, <span class="built_in">strlen</span>(name_msg));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">recv_msg</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sock = *((<span class="keyword">int</span> *)arg);</span><br><span class="line">  <span class="keyword">char</span> name_msg[NAME_SIZE + BUF_SIZE];</span><br><span class="line">  <span class="keyword">int</span> str_len;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    str_len = <span class="built_in">read</span>(sock, name_msg, NAME_SIZE + BUF_SIZE - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (str_len == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    name_msg[str_len] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">fputs</span>(name_msg, stdout);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/chankeh/net-lenrning-reference">https://github.com/chankeh/net-lenrning-reference</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;网络编程笔记-六-标准IO、epoll、多线程&quot;&gt;&lt;a href=&quot;#网络编程笔记-六-标准IO、epoll、多线程&quot; class=&quot;headerlink&quot; title=&quot;网络编程笔记(六)-标准IO、epoll、多线程&quot;&gt;&lt;/a&gt;网络编程笔记(六)-标准IO、epoll、多线程&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考《TCP/IP 网络编程》15、16、17、18 章&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://tommyplayer-c.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="linux 网络编程" scheme="https://tommyplayer-c.github.io/tags/linux-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>网络编程笔记(五)-域名系统和高级I/O</title>
    <link href="https://tommyplayer-c.github.io/2021/10/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%BA%94-%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F%E5%92%8C%E9%AB%98%E7%BA%A7IO/"/>
    <id>https://tommyplayer-c.github.io/2021/10/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%BA%94-%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F%E5%92%8C%E9%AB%98%E7%BA%A7IO/</id>
    <published>2021-10-19T16:00:00.000Z</published>
    <updated>2021-10-24T08:33:41.118Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络编程笔记-五-域名系统和高级I-O"><a href="#网络编程笔记-五-域名系统和高级I-O" class="headerlink" title="网络编程笔记(五)-域名系统和高级I/O"></a>网络编程笔记(五)-域名系统和高级I/O</h1><blockquote><p>参考 《UNIX 网络编程》第 11 章，《TCP/IP 网络编程》第 8、11、12、13 章</p></blockquote><span id="more"></span><h1 id="域名与地址转换"><a href="#域名与地址转换" class="headerlink" title="域名与地址转换"></a>域名与地址转换</h1><p>DNS 是对 IP 地址和域名相互转换的系统，其核心是 DNS 服务器。</p><h2 id="gethostbyname-函数：利用域名获取-IP-地址"><a href="#gethostbyname-函数：利用域名获取-IP-地址" class="headerlink" title="gethostbyname 函数：利用域名获取 IP 地址"></a>gethostbyname 函数：利用域名获取 IP 地址</h2><p>鼓励使用 <strong>getaddrinfo</strong> 函数，可以同时处理 IPv4 和 IPv6 地址，而且是可重入的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值：成功时返回hostent变量地址值，失败返回NULL指针  </span></span><br><span class="line"><span class="function">struct hostent * <span class="title">gethostbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * hostname)</span></span>;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span>&#123;</span>  </span><br><span class="line"><span class="keyword">char</span> * h_name;  <span class="comment">// 存有官方域名（Official domain name）</span></span><br><span class="line"><span class="keyword">char</span> ** h_aliases; <span class="comment">// 同一个IP可以绑定多个域名，除了官方域名以外的其他域名  </span></span><br><span class="line"><span class="keyword">int</span> h_addrtype; <span class="comment">// 保存地址族信息，IPv4存有AF_INET</span></span><br><span class="line"><span class="keyword">int</span> h_length; <span class="comment">// 保存IP地址长度：4</span></span><br><span class="line"><span class="keyword">char</span> ** h_addr_list; <span class="comment">// address list：最重要成员，保存IP地址// 可能分配多个IP给同一域名，利用多个服务器进行负载均衡</span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法：</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;host-&gt;h_aliases[i];i++)&#123;  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Aliases %d: %s \n&quot;</span>,i+<span class="number">1</span>,host-&gt;h_aliases[i]);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;host-&gt;h_addr_list[i];i++)&#123;  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;IP addr %d:%s \n&quot;</span>, i+<span class="number">1</span>, <span class="built_in">inet_ntoa</span>(*(struct in_addr*)host</span><br><span class="line">                                             -&gt;h_addr_list[i]));<span class="comment">// 注意类型转换，先取成员变量得到一级指针，再转换一级指针为struct in_addr*，最后解引用得到IP地址！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意 h_addr_list 实际指向 in_addr 结构体变量值而非字符串地址值。</p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110241627141.png" alt="image-20211012215404597" style="zoom:67%;" /><h2 id="gethostbyaddr：利用-IP-地址获取域名"><a href="#gethostbyaddr：利用-IP-地址获取域名" class="headerlink" title="gethostbyaddr：利用 IP 地址获取域名"></a>gethostbyaddr：利用 IP 地址获取域名</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值：成功时返回hostent变量地址值，失败返回NULL指针  </span></span><br><span class="line"><span class="comment">/* 参数：</span></span><br><span class="line"><span class="comment">addr：含有IP地址的in_addr结构体指针</span></span><br><span class="line"><span class="comment">len：第一个参数字节大小，IPv4为4，IPv6为16</span></span><br><span class="line"><span class="comment">family：地址族信息，IPv4为AF_INET, IPv6为AF_INET6</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">struct hostent * <span class="title">gethostbyaddr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * addr, <span class="keyword">socklen_t</span> len, <span class="keyword">int</span> family)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="分割-I-O"><a href="#分割-I-O" class="headerlink" title="分割 I/O"></a>分割 I/O</h1><p>多进程：父进程只需编写接收数据的代码，子进程只需编写发送数据的代码，简化了代码。</p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110241627051.png" alt="image-20211013214814200" style="zoom: 50%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_routine</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_routine</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sock;</span><br><span class="line">  <span class="keyword">pid_t</span> pid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>;</span></span><br><span class="line">  <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (sock == <span class="number">-1</span>) &#123;</span><br><span class="line">    error_handling(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">  serv_adr.sin_family = AF_INET;</span><br><span class="line">  serv_adr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">  serv_adr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (connect(sock, (struct sockaddr *)&amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">    error_handling(<span class="string">&quot;connect() error\r\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Connected....&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pid = fork();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    write_routine(sock, buf);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    read_routine(sock, buf);</span><br><span class="line">  &#125;</span><br><span class="line">  close(sock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">  <span class="built_in">fputs</span>(<span class="string">&quot;\n&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_routine</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">char</span> *buf)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> str_len = read(sock, buf, BUF_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (str_len == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buf[str_len] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Message from server : %s &quot;</span>, buf);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_routine</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">char</span> *buf)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    fgets(buf, BUF_SIZE, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(buf, <span class="string">&quot;q\n&quot;</span>) || !<span class="built_in">strcmp</span>(buf, <span class="string">&quot;Q\n&quot;</span>)) &#123;</span><br><span class="line">      shutdown(sock, SHUT_WR);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    write(sock, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><h2 id="管道函数-pipe"><a href="#管道函数-pipe" class="headerlink" title="管道函数 pipe"></a>管道函数 pipe</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"><span class="comment">// fileds[0]：管道出口</span></span><br><span class="line"><span class="comment">// fileds[1]：管道入口</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fildes[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><p>父子进程传递数据，注意一个管道不能完成双向通信。</p><img src="asset/image-20211013215433704.png" alt="image-20211013215433704" style="zoom: 50%;" /><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110241627605.png" alt="image-20211013215557525" style="zoom:50%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line">pipe(fds);</span><br><span class="line">pid = fork()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单向通信</span></span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    write(fds[<span class="number">1</span>], str, <span class="keyword">sizeof</span>(str));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    read(fds[<span class="number">0</span>], buf, BUF_SIZE);</span><br><span class="line">    <span class="built_in">puts</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向通信</span></span><br><span class="line"><span class="keyword">int</span> fds1[<span class="number">2</span>], fds2[<span class="number">2</span>];</span><br><span class="line">pipe(fds1[<span class="number">2</span>]); pipe(fds2[<span class="number">2</span>]);</span><br><span class="line">pid = fork();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    write(fds1[<span class="number">1</span>], str1, <span class="keyword">sizeof</span>(str1));</span><br><span class="line">    read(fds2[<span class="number">0</span>], buf, BUF_SIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Child proc output: %s \n&quot;</span>, buf);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    read(fds1[<span class="number">0</span>], buf, BUF_SIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent proc output: %s \n&quot;</span>, buf);</span><br><span class="line">    write(fds2[<span class="number">1</span>], str2, <span class="keyword">sizeof</span>(str2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="高级-IO-函数"><a href="#高级-IO-函数" class="headerlink" title="高级 IO 函数"></a>高级 IO 函数</h1><h2 id="send-和-recv-函数"><a href="#send-和-recv-函数" class="headerlink" title="send 和 recv 函数"></a>send 和 recv 函数</h2><p>send 和 recv 允许通过第四个参数从进程到内核传递标志。</p><h3 id="send-函数"><a href="#send-函数" class="headerlink" title="send 函数"></a>send 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span>* buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>功能：在一个已连接套接字上发送数据。 </p><p>参数 ：</p><ul><li>sockfd：一个已连接的套接字描述符。(in)</li><li>buf：指向要传送数据的缓冲区。(in)</li><li>len：上述缓冲区的长度(字节数)。(in)</li><li>flags：指明发送方式：0——忽略 该选项，MSG_DONTROUTE——不进行路由，MSG_OOB——用于发送<strong>带外数据</strong>。</li></ul><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110241628538.png" alt="image-20211013220907721" style="zoom:67%;" /><p>send 的成功只是数据被成功发出，并不意味数据已经被接收方成功接收。<u>如果传输层没有缓冲区空间放置要发送的数据，send 将被阻塞</u>，除非采用的是非阻塞套接字。对非阻塞面向流的套接字，send 实际所写字节数取决于客户和服务器的缓冲区空闲块大小。select 函数可以用来确定是否可以发送更多的数据。</p><h3 id="recv-函数"><a href="#recv-函数" class="headerlink" title="recv 函数"></a>recv 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span>* buf, <span class="keyword">int</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>功能：在一个已连接套接字上发送数据。 </p><p>参数 ：</p><ul><li>sockfd：一个已连接的套接字描述符。(in)</li><li>buf：指向要接收数据的缓冲区。(out)</li><li>len：上述缓冲区的长度(字节数)。(in)</li><li>flags：影响接收方式的标志。</li></ul><h3 id="一些-flags"><a href="#一些-flags" class="headerlink" title="一些 flags"></a>一些 flags</h3><ul><li><p>MSG_OOB：发送紧急消息，用于创建特殊发送方法和通道以发送紧急信息。</p><p>通过 MSG_OOB 可选项传递数据不会加快数据传输速度，而且通过信号处理函数也只能<strong>读取 1 字节</strong>，剩余数据只能通过未设置 MSG_OOB 的普通输入函数读取。</p><p>这是因为：</p><ol><li><p>TCP 连接上只有一个字节可以作为带外数据发送。</p></li><li><p>TCP 不存在真正的 “带外数据”：真正意义上的带外传输需要通过单独的通信路径高速传输数据，只是利用 TCP 的紧急模式进行传输。</p></li></ol></li><li><p>MSG_PEEK：查看已读取的数据，而且系统不在 recv 或 recvfrom 返回后丢弃这些数据。</p></li></ul><h2 id="readv-和-writev-函数"><a href="#readv-和-writev-函数" class="headerlink" title="readv 和 writev 函数"></a>readv 和 writev 函数</h2><p>通过 writev 可以将分散保存在多个缓冲的数据一并发送，通过 readv 函数可以由多个缓冲分别接收。即多次 write 函数可以通过一次 writev 替代，只用传送一个数据包，提高效率。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/uio.h＞ </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功时返回接收的字节数，失败时返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readv</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> struct iovec*vector,<span class="keyword">int</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结构体 iovec 中包含待发送数据的位置和大小信息。</span></span><br><span class="line"><span class="comment">count 为第二个参数传递的数组长度。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 成功时返回发送的字节数，失败时返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">writev</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec* vector, <span class="keyword">int</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span> * iov_base;<span class="comment">// 缓冲地址</span></span><br><span class="line">    <span class="keyword">size_t</span> iov_len;<span class="comment">// 缓冲大小</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110241628346.png" alt="image-20211017201435038" style="zoom: 67%;" /><h1 id="多播和广播"><a href="#多播和广播" class="headerlink" title="多播和广播"></a>多播和广播</h1><p>多播程序类似 UDP 套接字连接，不需要建立连接，但要设置相应的<strong>套接字选项</strong>。多播程序一般分为 Sender 和 Receiver。</p><p>多播可以跨域不同网络，只要加入多播组就能接收数据。</p><p>广播也是基于 UDP 完成的，但广播只能向同一网络中的主机传递数据。广播分为直接广播和本地广播。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/chankeh/net-lenrning-reference">https://github.com/chankeh/net-lenrning-reference</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;网络编程笔记-五-域名系统和高级I-O&quot;&gt;&lt;a href=&quot;#网络编程笔记-五-域名系统和高级I-O&quot; class=&quot;headerlink&quot; title=&quot;网络编程笔记(五)-域名系统和高级I/O&quot;&gt;&lt;/a&gt;网络编程笔记(五)-域名系统和高级I/O&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考 《UNIX 网络编程》第 11 章，《TCP/IP 网络编程》第 8、11、12、13 章&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://tommyplayer-c.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="linux 网络编程" scheme="https://tommyplayer-c.github.io/tags/linux-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>fgets和fscanf对换行符的处理</title>
    <link href="https://tommyplayer-c.github.io/2021/10/08/C%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95-fgets%E5%92%8Cfscanf%E5%AF%B9%E6%8D%A2%E8%A1%8C%E7%AC%A6%E7%9A%84%E5%A4%84%E7%90%86/"/>
    <id>https://tommyplayer-c.github.io/2021/10/08/C%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95-fgets%E5%92%8Cfscanf%E5%AF%B9%E6%8D%A2%E8%A1%8C%E7%AC%A6%E7%9A%84%E5%A4%84%E7%90%86/</id>
    <published>2021-10-07T16:00:00.000Z</published>
    <updated>2021-10-08T14:23:13.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="fgets-和-fscanf-对换行符的处理"><a href="#fgets-和-fscanf-对换行符的处理" class="headerlink" title="fgets 和 fscanf 对换行符的处理"></a>fgets 和 fscanf 对换行符的处理</h1><h2 id="fscanf"><a href="#fscanf" class="headerlink" title="fscanf"></a>fscanf</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span> <span class="params">( FILE * stream, <span class="keyword">const</span> <span class="keyword">char</span> * format, ... )</span></span>;</span><br></pre></td></tr></table></figure><p>fscanf 将<strong>读取并忽略</strong>在下一个非空白字符之前遇到的任何空白字符（空白字符包括空格、换行符和制表符）。</p><p>fscanf 读取字符串时，读取任意数量的非空白字符，在找到的第一个空白字符处停止。在存储序列的末尾自动添加终止空字符。</p><span id="more"></span><h2 id="fgets"><a href="#fgets" class="headerlink" title="fgets"></a>fgets</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">fgets</span> <span class="params">( <span class="keyword">char</span> * str, <span class="keyword">int</span> num, FILE * stream )</span></span>;</span><br></pre></td></tr></table></figure><p>换行符使 fgets 停止读取，但它被函数视为有效字符并包含在复制到 str 的字符串中。</p><p>fgets 只能读取 num - 1 个字符，包括最后的换行符，在复制到 str 的字符后自动附加终止空字符。</p><h2 id="验证实例"><a href="#验证实例" class="headerlink" title="验证实例"></a>验证实例</h2><p>总之，fscanf 不会读取换行符，读取之前会跳过所有换行符，读到换行符停止（流中的换行符还在）。</p><p>fgets 读取一行，读到换行符为止，但会读掉换行符（流中的换行符没有了）。</p><p>因此，如果使用了 fscanf 读取一行的内容，<u>流中会剩余一个换行符</u>，<u>再使用 fgets 只会读到这个剩余的换行符</u>，不会读取下一行。需要再使用 fgets 才能读取下一行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> line[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">fscanf</span>(fp, <span class="string">&quot;%d %d %s&quot;</span>, &amp;a, &amp;b, line);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;%s&quot;</span>, line);  <span class="comment">// String1</span></span><br><span class="line">    </span><br><span class="line">    fgets(line, <span class="number">20</span>, fp);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;%s\n&quot;</span>, line);  <span class="comment">// &#x27;\n&#x27;</span></span><br><span class="line"></span><br><span class="line">    fgets(line, <span class="number">20</span>, fp);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;%s&quot;</span>, line);     <span class="comment">// String2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[qhn@Tommy C_Prog]$ ./a</span><br><span class="line">String1</span><br><span class="line">String2</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at test.c:12</span><br><span class="line">12          <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, line);  // <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">(gdb) <span class="built_in">print</span>(line)</span><br><span class="line"><span class="variable">$1</span> = <span class="string">&quot;\n\000ring1\000@\005@\000\000\000\000\000\340\340\377\377&quot;</span></span><br></pre></td></tr></table></figure><p>12 行不打印任何字符的原因参考 <a href="https://www.cnblogs.com/hwli/p/10325738.html">C编程中printf不加’\n’不输出</a>。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;fgets-和-fscanf-对换行符的处理&quot;&gt;&lt;a href=&quot;#fgets-和-fscanf-对换行符的处理&quot; class=&quot;headerlink&quot; title=&quot;fgets 和 fscanf 对换行符的处理&quot;&gt;&lt;/a&gt;fgets 和 fscanf 对换行符的处理&lt;/h1&gt;&lt;h2 id=&quot;fscanf&quot;&gt;&lt;a href=&quot;#fscanf&quot; class=&quot;headerlink&quot; title=&quot;fscanf&quot;&gt;&lt;/a&gt;fscanf&lt;/h2&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;fscanf&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;( FILE * stream, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; * format, ... )&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;fscanf 将&lt;strong&gt;读取并忽略&lt;/strong&gt;在下一个非空白字符之前遇到的任何空白字符（空白字符包括空格、换行符和制表符）。&lt;/p&gt;
&lt;p&gt;fscanf 读取字符串时，读取任意数量的非空白字符，在找到的第一个空白字符处停止。在存储序列的末尾自动添加终止空字符。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://tommyplayer-c.github.io/categories/C/"/>
    
    
    <category term="C语言" scheme="https://tommyplayer-c.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>网络编程笔记(四)-套接字选项和 UDP</title>
    <link href="https://tommyplayer-c.github.io/2021/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%9B-%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%89%E9%A1%B9%E5%92%8CUDP/"/>
    <id>https://tommyplayer-c.github.io/2021/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%9B-%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%89%E9%A1%B9%E5%92%8CUDP/</id>
    <published>2021-10-06T16:00:00.000Z</published>
    <updated>2021-10-07T11:46:02.850Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络编程笔记-四-套接字选项和-UDP"><a href="#网络编程笔记-四-套接字选项和-UDP" class="headerlink" title="网络编程笔记(四)-套接字选项和 UDP"></a>网络编程笔记(四)-套接字选项和 UDP</h1><blockquote><p>参考《UNIX网络编程》第 7、8 章，《TCP/IP 网络编程》 第 9 章。</p></blockquote><span id="more"></span><h1 id="套接字选项"><a href="#套接字选项" class="headerlink" title="套接字选项"></a>套接字选项</h1><p>有很多方法来获取和设置影响套接字的选项：</p><ul><li>getsockopt 和 setsockopt 函数；</li><li>fcntl 函数；</li><li>ioctl 函数。</li></ul><h2 id="getsockopt-和-setsockopt"><a href="#getsockopt-和-setsockopt" class="headerlink" title="getsockopt 和 setsockopt"></a>getsockopt 和 setsockopt</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// 均返回：若成功则为0，若出错则为-1.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> *optlen)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ol><li>sockfd：指向一个打开的套接字描述符</li><li>level：指定系统中解释选项的代码或为通用套接字代码，或为某个特定于协议的代码（IPV4、IPV6、TCP、SCTP）。</li><li>optname：选项名。</li><li>*optval：指向某个变量的指针。对于 setsockopt 它是值参数，从 *optval 中取得选项待设置的新值。对于 getsockopt 它是值-结果参数，把已获取的选项当前值存放到 *optval 中。</li><li>optlen：*optval 的大小由它指定。</li></ol><p>套接字选项粗分为两大基本类型：</p><ol><li>标志选项：启用或禁止某个特性的二元选项。*optval 为 0 表示禁止，不为 0 表示启用。</li><li>值选项：取得并返回我们可以设置或检查的特定值的选项。</li></ol><h2 id="一些套接字选项"><a href="#一些套接字选项" class="headerlink" title="一些套接字选项"></a>一些套接字选项</h2><h3 id="SO-RCVBUF-amp-SO-SNDBUF：I-O-缓冲大小相关"><a href="#SO-RCVBUF-amp-SO-SNDBUF：I-O-缓冲大小相关" class="headerlink" title="SO_RCVBUF &amp; SO_SNDBUF：I/O 缓冲大小相关"></a>SO_RCVBUF &amp; SO_SNDBUF：I/O 缓冲大小相关</h3><ul><li>SO_RCVBUF：输入缓冲大小相关可选项</li><li>SO_SNDBUF：输出缓冲大小相关可选项</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">220</span> * <span class="number">1024</span>;</span><br><span class="line">setsockapt(sockfd, SOL_SOCKET, SO_RCVBUF, &amp;n, <span class="keyword">sizeof</span>(n));</span><br></pre></td></tr></table></figure><p>对于 TCP 来说，套接字接收缓冲区中可用空间的的大小限定了 TCP 通告对端的窗口大小。TCP 套接字接收缓冲区不可能溢出，因为不允许对端发出超过本端所通告窗口大小的数据。</p><p>UDP 是没有流量控制的：较快地发送端可以很容易地淹没较慢地接收端。</p><h3 id="SO-REUSEADDR：重用端口号"><a href="#SO-REUSEADDR：重用端口号" class="headerlink" title="SO_REUSEADDR：重用端口号"></a>SO_REUSEADDR：重用端口号</h3><p>SO_REUSEADDR 允许 TIME-WAIT 状态下套接字端口号被重用。</p><p>它与四次握手中的 TIME-WAIT 状态有关：若服务器先断开连接，则无法立即重新运行，因为套接字在 TIME-WAIT 状态时相应端口号被占用，bind 会失败。下面的代码解决了这个问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">optlen = <span class="keyword">sizeof</span>(option);  </span><br><span class="line">option = TRUE;  </span><br><span class="line">setsockopt(serv_sock, SOL_SOCKET, SO_RESUREADDR, (<span class="keyword">void</span> *)&amp;option, optlen);  </span><br></pre></td></tr></table></figure><p>7.5.11 P165：所有 TCP 服务器都应该指定本套接字选项，以允许服务器重新启动时 bind 成功。</p><p>补充：为什么需要 TIME-WAIT：</p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110071230195.png" alt="image-20211006174809048" style="zoom: 67%;" /><p>在 TIME-WAIT 状态，A 可以继续接收 B 的信息。如果没有 TIME-WAIT，A 发送 ACK 后立即消除套接字，但是 ACK 丢失了，则 B 永远无法接收到 A 的 ACK，会不断试图重传 FIN（B 认为自己发送的 FIN 没有到达 A）。</p><h3 id="TCP-NODELAY"><a href="#TCP-NODELAY" class="headerlink" title="TCP_NODELAY"></a>TCP_NODELAY</h3><p>Nagle 算法：防止数据包过多造成网络过载。</p><ol><li>立即发送一个数据段，即使发送缓冲区只有一个字节。</li><li>只有收到上一个数据段的确认或者发送缓冲区中数据超过 MSS，才可以发送下一个数据段。</li><li>对于即时性要求高的地方，如，Window方式的鼠标操作，要关闭Nagle 算法。</li></ol><p>禁用 Nagle 算法只需将套接字可选项 TCP_NODELAY 改为 1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> opt_val = <span class="number">1</span>;<span class="comment">// 禁用 Nagle 算法</span></span><br><span class="line"><span class="built_in">setsockopt</span>(sock, IPPROTO_TCP, TCP_NODELAY, (<span class="keyword">void</span> *)&amp;opt_val, <span class="built_in"><span class="keyword">sizeof</span></span>(opt_val));</span><br></pre></td></tr></table></figure><h2 id="fcntl-函数"><a href="#fcntl-函数" class="headerlink" title="fcntl 函数"></a>fcntl 函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ...<span class="comment">/* int arg */</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>fcntl (file control) 可执行各种描述符控制操作，提供了与网络编程相关的如下特性：</p><ul><li>非阻塞式 I/O：通过使用 F_SETFL 命令设置 O_NONBLOCK 文件状态标志，我们可以把一个套接字设置为非阻塞型。</li><li>信号驱动 I/O：通过使用 F_SETFL 命令设置 O_ASYNC 文件状态标志，我们可以把一个套接字设置成一旦其状态发生变化，内核就产生一个 SIGIO 信号。</li><li>F_SETOWN 命令允许我们指定用于接收 SIGIO 和 SIGURG 信号的套接字属主（进程 ID 或进程组 ID）。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>许多 TCP 服务器设置 SO_KEEPALIVE 套接字选项以自动终止一个半开连接。</li><li>SO_LINGER 套接字使得我们能够更好的地控制 close 函数的返回时机，允许我们强制发送 RST 而不是 TCP 的四分组连接终止序列。</li><li>每个 TCP 套接字和 SCTP 套接字都有一个发送缓冲区和接收缓冲区，每个 UDP 套接字都有一个接收缓冲区。SO_SNDBUF 和 SO_RCVBUF 套接字选项允许我们改变这些缓冲区的大小。这两个选项最常见的用途是长肥管道上的批量数据传送。</li></ul><h1 id="基本-UDP-套接字编程"><a href="#基本-UDP-套接字编程" class="headerlink" title="基本 UDP 套接字编程"></a>基本 UDP 套接字编程</h1><h2 id="UDP-客户-服务器原理"><a href="#UDP-客户-服务器原理" class="headerlink" title="UDP 客户/服务器原理"></a>UDP 客户/服务器原理</h2><p>UDP是无连接不可靠的数据报协议。典型的 UDP 客户/服务器程序中，客户不与服务器建立连接，而是只管使用 sendto 给服务器发送数据报；服务器也不接受来自客户的连接，只管调用 recvfrom 函数等待客户数据的到达。</p><p>使用 UDP 编写的一些常见应用程序有：DNS（域名系统）、NFS（网络文件系统）、SNMP（简单网络管理协议）。</p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110071230221.png" alt="image-20211007082454984" style="zoom: 67%;" /><h2 id="recvfrom-和-sendto-函数"><a href="#recvfrom-和-sendto-函数" class="headerlink" title="recvfrom 和 sendto 函数"></a>recvfrom 和 sendto 函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 均返回：若成功则返回读或写的字节大小，若出错则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvform</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buff , <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags, </span></span></span><br><span class="line"><span class="params"><span class="function">struct sockaddr *from , <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buff , <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags, </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">const</span> struct sockaddr *to , <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>前三个参数 sockfd、buff、nbytes 等同于 read 和 write 的三个参数：描述符、指向读入/写出缓冲区的指针、读/写字节数。</li><li>flags：这里暂时把 flags 置为 0。</li><li>recvfrom 的 from：指向一个由该函数返回时候填写的数据报发送者的协议地址的套接字地址结构，填写的字节数在 addrlen（值-结果参数）。recvfrom 的参数 from、addrlen 类似 accept 的最后两个参数。</li><li>sendto 的 to：指向一个含有数据报接收者的协议地址（IP 地址和端口号）的套接字地址结构，大小由 addrlen 参数指定。sendto 的参数 to、addrlen 类似 connect 的最后两个参数。</li></ul><h2 id="UDP-回射服务程序和客户程序"><a href="#UDP-回射服务程序和客户程序" class="headerlink" title="UDP 回射服务程序和客户程序"></a>UDP 回射服务程序和客户程序</h2><p>服务程序 udpcliserv/udpserv01.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../lib/unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dg_echo</span><span class="params">(<span class="keyword">int</span> sockfd, SA *pcliaddr, <span class="keyword">socklen_t</span> clilen)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">socklen_t</span> len;</span><br><span class="line">  <span class="keyword">char</span> mesg[MAXLINE];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    len = clilen;</span><br><span class="line">    n = Recvfrom(sockfd, mesg, MAXLINE, <span class="number">0</span>, pcliaddr, &amp;len);</span><br><span class="line">    Sendto(sockfd, mesg, n, <span class="number">0</span>, pcliaddr, len);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sockfd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line"></span><br><span class="line">  sockfd = Socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">  servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">  Bind(sockfd, (SA *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">  dg_echo(sockfd, (SA *)&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户程序 udpcliserv/udpcli01.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../lib/unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dg_cli</span><span class="params">(FILE *fp, <span class="keyword">int</span> sockfd, <span class="keyword">const</span> SA *pservaddr, <span class="keyword">socklen_t</span> servlen)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">char</span> sendline[MAXLINE], recvline[MAXLINE + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (Fgets(sendline, MAXLINE, fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    Sendto(sockfd, sendline, <span class="built_in">strlen</span>(sendline), <span class="number">0</span>, pservaddr, servlen);</span><br><span class="line">    <span class="comment">// 注意recvfrom的最后两个参数为NULL，不关心数据发送者的协议地址</span></span><br><span class="line">n = Recvfrom(sockfd, recvline, MAXLINE, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    recvline[n] = <span class="number">0</span>; <span class="comment">/* null terminate */</span></span><br><span class="line">    Fputs(recvline, <span class="built_in">stdout</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sockfd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) err_quit(<span class="string">&quot;usage: udpcli &lt;IPaddress&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">  Inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;servaddr.sin_addr);</span><br><span class="line"></span><br><span class="line">  sockfd = Socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  dg_cli(<span class="built_in">stdin</span>, sockfd, (SA *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大多数 TCP 服务器是并发的，大多数 UDP 服务器是迭代的。</p><p>每个 UDP 套接字都有一个接收缓冲区，当进程调用 recvfrom 时，缓冲区中的下一个数据报以 <strong>FIFO</strong> （先进先出）顺序返回给进程。</p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110071230248.png" alt="image-20211007084254165" style="zoom:67%;" /><h2 id="UDP-初始回射程序的问题"><a href="#UDP-初始回射程序的问题" class="headerlink" title="UDP 初始回射程序的问题"></a>UDP 初始回射程序的问题</h2><ol><li><p>数据报丢失<br>数据报丢失导致客户永久阻塞于 recvfrom 调用，设置一个超时可以解决这个问题。</p></li><li><p>验证接收到的响应：<br>重写 dg_cli 函数，分配另一个套接字地址结构用于存放由 recvfrom 返回的结构，然后比较返回的地址。保留来自数据报所发往的服务器的应答，而忽略任何其他数据报。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../lib/unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dg_cli</span><span class="params">(FILE *fp, <span class="keyword">int</span> sockfd, <span class="keyword">const</span> SA *pservaddr, <span class="keyword">socklen_t</span> servlen)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">char</span> sendline[MAXLINE], recvline[MAXLINE + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">socklen_t</span> len;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">preply_addr</span>;</span></span><br><span class="line"></span><br><span class="line">  preply_addr = Malloc(servlen);<span class="comment">// 分配另一个套接字地址结构</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (Fgets(sendline, MAXLINE, fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    Sendto(sockfd, sendline, <span class="built_in">strlen</span>(sendline), <span class="number">0</span>, pservaddr, servlen);</span><br><span class="line"></span><br><span class="line">    len = servlen;</span><br><span class="line">    <span class="comment">// 注意这里与 dg_cli 相比，recvfrom的最后2个参数不为0，设为新分配的套接字地址</span></span><br><span class="line">    n = Recvfrom(sockfd, recvline, MAXLINE, <span class="number">0</span>, preply_addr, &amp;len);</span><br><span class="line">    <span class="comment">// 比较返回的地址</span></span><br><span class="line">    <span class="keyword">if</span> (len != servlen || <span class="built_in">memcmp</span>(pservaddr, preply_addr, len) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;reply from %s (ignored)\n&quot;</span>, Sock_ntop(preply_addr, len));</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    recvline[n] = <span class="number">0</span>; <span class="comment">/* null terminate */</span></span><br><span class="line">    Fputs(recvline, <span class="built_in">stdout</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>服务器进程未运行</p><p>异步错误：服务器主机响应 “port unreachable” ICMP消息，不过这个 ICMP 错误不返回给客户进程，客户永远阻塞于 recvfrom 调用。</p><p>对于一个 UDP 套接字，由它引发的异步错误却并不返回给它，除非它已连接。这需要给 UDP 套接字调用 connect。</p></li></ol><h2 id="UDP-的-connect-函数"><a href="#UDP-的-connect-函数" class="headerlink" title="UDP 的 connect 函数"></a>UDP 的 connect 函数</h2><p>UDP 的 connect 不同于TCP，没有三次握手的过程，内核只是检查是否存在立即可知的错误，记录对端 IP 地址和端口号，然后立即返回到调用进程。对于已连接的 UDP 套接字，与默认未连接的 UDP 套接字相比，有以下 3 个变化：    </p><ol><li>不能再给输出操作指定目的 IP 地址和端口号——不使用 sendto，而改用 write 或 send。</li><li>不必使用 recvfrom 以获悉数据报的发送者，而改用 read、recv 或 recvmsg。</li><li>已连接 UDP 套接字引发的异步错误会返回给它们所在的进程，而未连接的 UDP 套接字不接收任何异步错误。</li></ol><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110071230274.png" alt="image-20211007102512565"></p><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110071230298.png" alt="已连接UDP套接字"></p><p>小结：UDP 客户进程或服务器进程只在使用自己的 UDP 套接字与确定的唯一对端通信时，才可以调用 connect。调用 connect 通常是 UDP 客户。</p><p>将初始的 UDP 客户函数 dg_cli 修改：调用 connect，并以 read 和 write 代替 recvfrom 和 sendto。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dg_cli</span><span class="params">(FILE *fp, <span class="keyword">int</span> sockfd, <span class="keyword">const</span> SA *pservaddr, <span class="keyword">socklen_t</span> servlen)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">char</span> sendline[MAXLINE], recvline[MAXLINE + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  Connect(sockfd, (SA *)pservaddr, servlen);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (Fgets(sendline, MAXLINE, fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    Write(sockfd, sendline, <span class="built_in">strlen</span>(sendline));</span><br><span class="line">    n = Read(sockfd, recvline, MAXLINE);</span><br><span class="line"></span><br><span class="line">    recvline[n] = <span class="number">0</span>; <span class="comment">/* null terminate */</span></span><br><span class="line">    Fputs(recvline, <span class="built_in">stdout</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-select-函数的-TCP-和-UDP-回射服务器程序"><a href="#使用-select-函数的-TCP-和-UDP-回射服务器程序" class="headerlink" title="使用 select 函数的 TCP 和 UDP 回射服务器程序"></a>使用 select 函数的 TCP 和 UDP 回射服务器程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* include udpservselect01 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../lib/unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> listenfd, connfd, udpfd, nready, maxfdp1;</span><br><span class="line">  <span class="keyword">char</span> mesg[MAXLINE];</span><br><span class="line">  <span class="keyword">pid_t</span> childpid;</span><br><span class="line">  fd_set rset;</span><br><span class="line">  <span class="keyword">ssize_t</span> n;</span><br><span class="line">  <span class="keyword">socklen_t</span> len;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> on = <span class="number">1</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>, <span class="title">servaddr</span>;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sig_chld</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* create listening TCP socket */</span></span><br><span class="line">  listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">  servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">  Setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="keyword">sizeof</span>(on)); <span class="comment">// 设置SO_REUSEADDR套接字选项以防该端口已有连接存在。</span></span><br><span class="line">  Bind(listenfd, (SA *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">  Listen(listenfd, LISTENQ);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* create UDP socket */</span></span><br><span class="line">  udpfd = Socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">  servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 无需调用bind之前设置SO_REUSEADDR套接字选项，因为TCP端口独立于UDP端口</span></span><br><span class="line">  Bind(udpfd, (SA *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">  <span class="comment">/* end udpservselect01 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* include udpservselect02 */</span></span><br><span class="line">  Signal(SIGCHLD, sig_chld); <span class="comment">/* must call waitpid() */</span></span><br><span class="line"></span><br><span class="line">  FD_ZERO(&amp;rset);</span><br><span class="line">  maxfdp1 = max(listenfd, udpfd) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    FD_SET(listenfd, &amp;rset);</span><br><span class="line">    FD_SET(udpfd, &amp;rset);</span><br><span class="line">    <span class="keyword">if</span> ((nready = select(maxfdp1, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">/* back to for() */</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        err_sys(<span class="string">&quot;select error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FD_ISSET(listenfd, &amp;rset)) &#123;</span><br><span class="line">      len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">      connfd = Accept(listenfd, (SA *)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((childpid = Fork()) == <span class="number">0</span>) &#123; <span class="comment">/* child process */</span></span><br><span class="line">        Close(listenfd);              <span class="comment">/* close listening socket */</span></span><br><span class="line">        str_echo(connfd);             <span class="comment">/* process the request */</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      Close(connfd); <span class="comment">/* parent closes connected socket */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FD_ISSET(udpfd, &amp;rset)) &#123;</span><br><span class="line">      len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">      n = Recvfrom(udpfd, mesg, MAXLINE, <span class="number">0</span>, (SA *)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">      Sendto(udpfd, mesg, n, <span class="number">0</span>, (SA *)&amp;cliaddr, len);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* end udpservselect02 */</span></span><br></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul><li><p>UDP 套接字可能产生异步错误（分组发送完一段时间后才报告的错误），TCP 套接字总是给应用进程报告这些错误，但是 UDP 套接字必须已连接才能接收这些错误。</p></li><li><p>UDP 没有流量控制，但这一般不成问题，因为许多 UDP 应用程序是用请求-应答模式构造的，而且不用传送大量数据。</p></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://wuhlan3.gitee.io/wuhlan3/2021/08/06/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%83%EF%BC%89">https://wuhlan3.gitee.io/wuhlan3/2021/08/06/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%83%EF%BC%89</a></p><p><a href="https://blog.csdn.net/zzxiaozhao/article/details/102662861">https://blog.csdn.net/zzxiaozhao/article/details/102662861</a></p><p><a href="https://www.cnblogs.com/Anker/p/3265058.html">https://www.cnblogs.com/Anker/p/3265058.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;网络编程笔记-四-套接字选项和-UDP&quot;&gt;&lt;a href=&quot;#网络编程笔记-四-套接字选项和-UDP&quot; class=&quot;headerlink&quot; title=&quot;网络编程笔记(四)-套接字选项和 UDP&quot;&gt;&lt;/a&gt;网络编程笔记(四)-套接字选项和 UDP&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考《UNIX网络编程》第 7、8 章，《TCP/IP 网络编程》 第 9 章。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://tommyplayer-c.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="linux 网络编程" scheme="https://tommyplayer-c.github.io/tags/linux-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>网络编程笔记(二)-TCP客户服务器示例</title>
    <link href="https://tommyplayer-c.github.io/2021/10/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-2021-10-04-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%BA%8C-TCP%E5%AE%A2%E6%88%B7%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A4%BA%E4%BE%8B/"/>
    <id>https://tommyplayer-c.github.io/2021/10/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-2021-10-04-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%BA%8C-TCP%E5%AE%A2%E6%88%B7%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A4%BA%E4%BE%8B/</id>
    <published>2021-10-04T07:57:03.000Z</published>
    <updated>2021-10-05T06:47:56.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络编程笔记-二-TCP客户-服务器示例"><a href="#网络编程笔记-二-TCP客户-服务器示例" class="headerlink" title="网络编程笔记(二)-TCP客户/服务器示例"></a>网络编程笔记(二)-TCP客户/服务器示例</h1><blockquote><p>参考《UNIX网络编程》第 5 章，《TCP/IP 网络编程》 第 10 章。</p></blockquote><span id="more"></span><h2 id="回射（echo）客户-服务器原理概述"><a href="#回射（echo）客户-服务器原理概述" class="headerlink" title="回射（echo）客户/服务器原理概述"></a>回射（echo）客户/服务器原理概述</h2><img src="https://gitee.com/qin-haonan/my-picture/raw/master/20211004155907.png" alt="image-20211003215318752" style="zoom:80%;" /><p>并发服务器端实现模型和方法：</p><ol><li>多进程服务器：通过创建多个进程提供服务。</li><li>多路复用服务器：通过捆绑并统一管理 I/O 对象提供服务（select 和 epoll）。</li><li>多线程服务器：通过生成与客户端等量的线程提供服务。</li></ol><p>这里学习第一种——多进程服务器。</p><p>需要用到的 linux 命令：</p><ol><li> <code>ps au</code> ：查看进程 ID 和状态。</li><li><code>./可执行文件 &amp;</code>：后台运行某个进程。</li></ol><p>原始并发服务器的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTENQ 5</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_echo</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> listenfd, connfd;</span><br><span class="line"><span class="keyword">pid_t</span> childpid;</span><br><span class="line"><span class="keyword">socklen_t</span> clilen;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>, <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (listenfd == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">error_handling(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">servaddr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bind(listenfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) == <span class="number">-1</span>)</span><br><span class="line">error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (listen(listenfd, LISTENQ) == <span class="number">-1</span>)</span><br><span class="line">error_handling(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;)</span><br><span class="line">&#123;</span><br><span class="line">clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;clilen);</span><br><span class="line"><span class="keyword">if</span> (connfd == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;new client %d... \n&quot;</span>, connfd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((childpid = fork()) == <span class="number">0</span>)</span><br><span class="line">&#123;  <span class="comment">/* child process */</span></span><br><span class="line">close(listenfd);  <span class="comment">/* close listening socket */</span></span><br><span class="line">str_echo(connfd); <span class="comment">/* process the request */</span></span><br><span class="line"><span class="comment">// close(connfd);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d client disconnected...&quot;</span>, connfd);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (childpid == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">close(connfd);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;fail to fork&quot;</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(connfd); <span class="comment">/* parent closes connected socket */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_echo</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">ssize_t</span> n;</span><br><span class="line"><span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((n = read(sockfd, buf, BUF_SIZE)) &gt; <span class="number">0</span>)</span><br><span class="line">write(sockfd, buf, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);  </span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;\n&quot;</span>,<span class="built_in">stderr</span>);  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *sendline)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_cli</span><span class="params">(FILE *fp, <span class="keyword">int</span> sockfd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sockfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_addr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connect(sockfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr)) == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;connect() error\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Connected....\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    str_cli(<span class="built_in">stdin</span>, sockfd); <span class="comment">/* do it all */</span></span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_cli</span><span class="params">(FILE *fp, <span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> str_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> sendline[BUF_SIZE], recvline[BUF_SIZE];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Input sendline(Q to quit):\n&quot;</span>);</span><br><span class="line">        fgets(sendline, BUF_SIZE, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(sendline, <span class="string">&quot;q\n&quot;</span>) || !<span class="built_in">strcmp</span>(sendline, <span class="string">&quot;Q\n&quot;</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        write(sockfd, sendline, <span class="built_in">strlen</span>(sendline));</span><br><span class="line">        str_len = read(sockfd, sendline, BUF_SIZE - <span class="number">1</span>);</span><br><span class="line">        sendline[str_len] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sendline from server : %s \n&quot;</span>, sendline);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *sendline)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(sendline, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;\n&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="POSIX-信号处理"><a href="#POSIX-信号处理" class="headerlink" title="POSIX 信号处理"></a>POSIX 信号处理</h2><h3 id="信号的定义"><a href="#信号的定义" class="headerlink" title="信号的定义"></a>信号的定义</h3><p><strong>信号</strong>（signal）就是告知某个进程发生了某个事件的通知；信号通常是<strong>异步</strong>发生的，也就是说接受信号的进程不知道信号的准确发生时刻。</p><p>信号可以：</p><ol><li>一个进程发给另一个进程；</li><li>内核发给某个进程。</li></ol><h3 id="信号的处置"><a href="#信号的处置" class="headerlink" title="信号的处置"></a>信号的处置</h3><p>每个信号都有一个与之关联的<strong>处置</strong>，即收到特定信号时的处理方法；可以通过调用 <code>sigaction</code> 函数来设定一个信号的处置。</p><p>处置方法有三种选择：</p><ol><li><p>提供一个函数，只要有特定信号发生它就被调用。这样的函数称为<strong>信号处理函数</strong>（signal handler），这种行为称为捕获（catching）信号。有两个信号 SIGKILL 和 SIGSTOP 不能被捕获。信号处理函数由信号值这个<strong>单一的整数参数</strong>来调用，且<strong>没有返回值</strong>，其函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> signo)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>可以把某个信号的处置方法设定为 SIG_IGN 来忽略（ignore）它。SIDKILL 和 SIDSTOP 这两个信号不能被忽略；</p></li><li><p>可以把某个信号的处置方法设定为 SIG_DEF 来启用它的默认（default）处置，默认初值通常是收到信号后终止进程。另有个别信号的默认处置为忽略，如 SIGCHLD 和 SIGURG。</p></li></ol><h4 id="第一种处置方法"><a href="#第一种处置方法" class="headerlink" title="第一种处置方法"></a>第一种处置方法</h4><p><u>建立信号处置的 POSIX 方法就是调用 sigaction 函数</u>，但比较复杂（简单方法是调用自带的 signal 函数）。POSIX 明确规定了调用 sigaction 时的语义定义。解决方法是定义自己 signal——只是调用 sigaction 函数，以所期望的 POSIX 语义提供一个简单的接口。</p><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/20211004155917.png" alt="1249281-20190411173750561-1353468742"></p><p>UNIX 系统自带的 signal 函数，历史悠久，不太稳定，也叫<strong>信号注册函数</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：返回之前注册的函数指针。</span></span><br><span class="line"><span class="comment">// 参数：int signo，void (*func)(int)</span></span><br><span class="line"><span class="comment">// 返回类型：参数为int型，返回为void型函数指针</span></span><br><span class="line"><span class="keyword">void</span> (*signal(<span class="keyword">int</span> signo, <span class="keyword">void</span> (*func)(<span class="keyword">int</span>)))(<span class="keyword">int</span>);  </span><br></pre></td></tr></table></figure><p>一些常见的信号值：</p><ul><li>SIGALARM：已到通过 alarm 函数注册的时间</li><li>SIGINT：输入 CTRL + C</li><li>SIGCHILID：子进程终止</li></ul><p>利用 sigaction 函数进行信号处理，可以代替 signal，也更加稳定（POSIX 明确规定了调用 sigaction 时的信号语义）。<u>signal 函数在 UNIX 的不同系列操作系统中可能存在区别，但是 sigaction 完全相同</u>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">signo：传递的信号  </span></span><br><span class="line"><span class="comment">act：对应于第一个参数的信号处理函数  </span></span><br><span class="line"><span class="comment">oldact：获取之前注册的信号处理函数指针，若不需要则传递0</span></span><br><span class="line"><span class="comment">返回值：成功返回0，失败返回-1</span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signo, <span class="keyword">const</span> struct sigaction *act, struct sigaction *oldact)</span></span>;  </span><br></pre></td></tr></table></figure><p>声明并初始化结构体以调用上述函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span>  </span><br><span class="line"><span class="keyword">void</span> (* sa_handler)(<span class="keyword">int</span>);<span class="comment">// 保存信号处理函数的指针</span></span><br><span class="line"><span class="keyword">sigset_t</span> sa_mask;  <span class="comment">// 可初始化为0</span></span><br><span class="line"><span class="keyword">int</span> sa_flags;  <span class="comment">// 可初始化为0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="第二种处置方法"><a href="#第二种处置方法" class="headerlink" title="第二种处置方法"></a>第二种处置方法</h4><p>把某个信号的处置方法设定为 SIG_IGN 来忽略（ignore）它。SIDKILL 和 SIDSTOP 这两个信号不能被忽略。</p><h4 id="第三种处置方法"><a href="#第三种处置方法" class="headerlink" title="第三种处置方法"></a>第三种处置方法</h4><p>可以把某个信号的处置方法设定为 SIG_DEF 来启用它的默认（default）处置，默认处置通常是收到信号后终止进程。有个别信号的默认处置为忽略，如 SIGCHLD 和 SIGURG。</p><h2 id="处理-SIGCHLD-信号（僵死进程）"><a href="#处理-SIGCHLD-信号（僵死进程）" class="headerlink" title="处理 SIGCHLD 信号（僵死进程）"></a>处理 SIGCHLD 信号（僵死进程）</h2><h3 id="僵死进程的概念"><a href="#僵死进程的概念" class="headerlink" title="僵死进程的概念"></a>僵死进程的概念</h3><p>进程 ID：创建时进程都会从操作系统获得进程 ID，其值为大于 2 的整数（1 为分配给操作系统启动后的首个进程）。</p><p>通过 fork 函数创建进程：复制正在运行的、调用 fork 函数的进程，父子进程拥有完全独立的内存结构。两个进程都执行 fork 函数以后的语句，<strong>共享同一代码</strong>。</p><p>初始服务器的代码存在僵死进程问题。</p><p>僵死进程：目的是为了维护子进程的信息（进程ID，终止状态，资源利用信息），以便父进程在以后某个时候存取。<u>如果父进程未主动要求获得子进程的结束状态值，操作系统将让子进程长时间处于僵死状态</u>。僵死进程占用内存中的空间，最终可能导致耗尽内核资源。</p><p>启动初始服务器：</p><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/20211004155944.png" alt="image-20210925215239185"></p><p>启动初始客户端并连接服务器，可以看到，断开连接后出现僵死进程（Z）：</p><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/20211004155947.png" alt="image-20210925215528420"></p><h3 id="销毁僵死进程的方法"><a href="#销毁僵死进程的方法" class="headerlink" title="销毁僵死进程的方法"></a>销毁僵死进程的方法</h3><h4 id="wait-函数"><a href="#wait-函数" class="headerlink" title="wait 函数"></a>wait 函数</h4><p>利用 wait 函数销毁僵死进程的原理：父进程主动请求获取子进程的返回值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值：成功时返回终止的子进程ID，失败返回-1 </span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> * statloc)</span></span>;</span><br></pre></td></tr></table></figure><p>wait 和 waitpid 均返回两个值：已终止子进程的进程 ID 号，以及通过 statloc 指针返回的子进程终止状态（一个整数）。子进程终止状态需要通过下列宏分离：</p><ul><li><p>WIFEXITED：子进程正常终止时返回 TRUE。</p></li><li><p>WEXITSTATUS：返回子进程的返回值。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wait</span>(&amp;status);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status))&#123;  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Child pass num : %d&quot;</span>, <span class="built_in">WEXITSTATUS</span>(status));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="waitpid-函数"><a href="#waitpid-函数" class="headerlink" title="waitpid 函数"></a>waitpid 函数</h4><p>wait 的局限性：调用 wait 函数时，如果没有已终止的子进程，那么程序将阻塞（Blocking）直到有子进程终止。wait 函数不能处理客户端与服务器同时建立多个连接的情况（《UNIX 网络编程》P109-111）</p><p>wait 函数会引起程序阻塞，但 waitpid 函数不会阻塞，而且可以指定等待的目标子进程，options 指定为 WNOHANG 时没有终止子进程也不会阻塞。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">pid：等待终止的目标子进程ID，若传递-1，则与wait函数相同，等待任意子进程  </span></span><br><span class="line"><span class="comment">statloc：与wait函数的statloc参数一致</span></span><br><span class="line"><span class="comment">options：传递头文件sys/wait.h中声明的常量 WNOHANG，即使没有终止子进程也不会阻塞，而是返回0并退出函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 返回值：成功时返回终止子进程ID，失败返回-1 </span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> * statloc, <span class="keyword">int</span> options)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example:</span></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">waitpid</span>(<span class="number">-1</span>, &amp;status, WNOHANG))&#123;  </span><br><span class="line"><span class="built_in">sleep</span>(<span class="number">1</span>);  </span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;sleep 1sec.&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status))&#123;  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;child send %d \n&quot;</span>,<span class="built_in">WEXITSTATUS</span>(status));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-signal-消除僵死进程"><a href="#使用-signal-消除僵死进程" class="headerlink" title="使用 signal 消除僵死进程"></a>使用 signal 消除僵死进程</h4><ol><li><p>在服务器程序中调用 listen 之后添加信号注册函数 signal：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">signal</span>(SIGCHLD, sig_chld);</span><br></pre></td></tr></table></figure></li><li><p>编写信号处理函数 sig_chld：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本1：使用 wait</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_chld</span><span class="params">(<span class="keyword">int</span> signo)</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span>   stat;</span><br><span class="line">    pid = <span class="built_in">wait</span>(&amp;stat);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child %d terminated\n&quot;</span>,pid);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 版本2，使用 waitpid</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_chld</span><span class="params">(<span class="keyword">int</span> signo)</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span>   stat;</span><br><span class="line">    <span class="keyword">while</span>( (pid = <span class="built_in">waitpid</span>(<span class="number">-1</span>, &amp;stat, WHOHANG)) &gt; <span class="number">0</span> )</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child %d terminated\n&quot;</span>,pid);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>可以看到，没有僵死进程：</p><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/20211004155924.png" alt="image-20210925224832301"></p><h4 id="使用-sigaction-消除僵死进程"><a href="#使用-sigaction-消除僵死进程" class="headerlink" title="使用 sigaction 消除僵死进程"></a>使用 sigaction 消除僵死进程</h4><p>类似 signal，在服务器程序中调用 listen 之后添加以下代码，使用同样的信号处理函数 sig_chlid。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理僵死进程</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line"><span class="keyword">int</span> state;</span><br><span class="line">act.sa_handler = sig_chld;</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    state = <span class="built_in">sigaction</span>(SIGCHLD, &amp;act, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="使用-waitpid-而不是-wait-的原因——UNIX-信号不排队"><a href="#使用-waitpid-而不是-wait-的原因——UNIX-信号不排队" class="headerlink" title="使用 waitpid 而不是 wait 的原因——UNIX 信号不排队"></a>使用 waitpid 而不是 wait 的原因——UNIX 信号不排队</h4><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/20211004155927.png" alt="image-20210928220057244"></p><p>一个客户与并发服务器建立 5 个连接时，建立一个信号处理函数并在其中调用的 wait 不足以防止出现僵死进程（只能终止一个进程）。原因：所有 5 个信号都在信号处理函数执行之前产生，而信号处理函数只执行了一次，因为 Unix 信号一般是<strong>不排队的</strong>。正确的解决方法是调用 waitpid 而不是 wait：在一个循环内调用 waitpid，以获取所有已终止子进程的状态。WHOHANG 告知 waitpid 没有已终止子进程时也不要阻塞。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_chld</span><span class="params">(<span class="keyword">int</span> signo)</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span>   stat;</span><br><span class="line">    <span class="keyword">while</span>( (pid = waitpid(<span class="number">-1</span>, &amp;stat, WHOHANG)) &gt; <span class="number">0</span> )</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child %d terminated\n&quot;</span>,pid);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol><li>当 fork 子进程时，必须捕获 SIGCHLD 信号。</li><li>当捕获信号时，必须处理被中断的系统调用。(P107)</li><li>SIGCHLD 的信号处理函数必须正确编写，应使用 waitpid 函数以免留下僵死进程。</li></ol><h2 id="服务器进程终止"><a href="#服务器进程终止" class="headerlink" title="服务器进程终止"></a>服务器进程终止</h2><p>复习 TCP 四次握手关闭连接的过程：</p><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/20211004155931.png" alt="image-20210930093254244"></p><p>模拟服务器进程崩溃时，客户端会发生什么：</p><ol><li><p>找到服务器子进程的进程 ID，并执行 kill 命令杀死它。此时被杀死的服务器子进程的<u>所有打开着的描述符都将关闭</u>。这就导致服务器向客户端发送一个 FIN，而客户端会向服务器响应一个 ACK。是四次握手关闭连接的前半部分。</p></li><li><p><strong>SIGCHLD 信号</strong>被发送给服务器父进程，僵死子进程得到正确处理。然而问题是客户进程此时<strong>阻塞在 fgets 函数</strong>上，等待从终端接收一行文本。</p></li><li><p>此时在另一个窗口运行 netstat 命令，可以看到 TCP 连接终止序列的前半部分已经完成。</p><p>服务器终端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[qhn@Tommy tcpcliserv]$ ps au</span><br><span class="line">USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root       1910  0.1  0.3 341764  7732 tty1     Ssl+ 19:26   0:04 /usr/bin/X :0 -background none -noreset -audit 4 -verbose -auth /run</span><br><span class="line">qhn        3840  0.0  0.1 117096  2772 pts/0    Ss   19:44   0:00 /usr/bin/bash</span><br><span class="line">qhn        6772  0.0  0.0   6388   544 pts/0    S    20:30   0:00 ./tcpserv04</span><br><span class="line">qhn        7240  0.0  0.1 116968  3184 pts/1    Ss   20:32   0:00 /usr/bin/bash</span><br><span class="line">qhn        8104  0.0  0.0   6396   396 pts/1    S+   20:39   0:00 ./tcpcli01 127.0.0.1</span><br><span class="line">qhn        8105  0.0  0.0   6388   104 pts/0    S    20:39   0:00 ./tcpserv04</span><br><span class="line">qhn        8159  0.0  0.0 155448  1872 pts/0    R+   20:39   0:00 ps au</span><br><span class="line">[qhn@Tommy tcpcliserv]$ kill 8105</span><br><span class="line">[qhn@Tommy tcpcliserv]$ child 8105 terminated</span><br><span class="line"></span><br><span class="line">[qhn@Tommy tcpcliserv]$ netstat -a | grep 9877</span><br><span class="line">tcp        0      0 0.0.0.0:9877            0.0.0.0:*               LISTEN     </span><br><span class="line">tcp        0      0 localhost:9877          localhost:51616         FIN_WAIT2  </span><br><span class="line">tcp        1      0 localhost:51616         localhost:9877          CLOSE_WAIT </span><br></pre></td></tr></table></figure></li><li><p>此时，在客户端键入一行文本 “another line”，str_cli 调用 written，客户 TCP 将数据发送给服务器（<u>FIN 的接收并没有告知客户 TCP 服务器进程已经终止</u>，但实际上在本例中服务器进程已经被杀死了）。由于服务器先前打开的连接套接字已经终止，于是响应以一个 RST。</p></li><li><p>客户进程<strong>之前阻塞在 fgets</strong> 上，看不到这个 RST。客户发送 “another line” 后立即调用 readline，直接收到终止符 EOF（因为之前客户端收到了 FIN），这是客户未预期的，所以客户端会提示以出错信息 “server terminated prematurely”（服务器过早终止）退出。</p><p>客户端终端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[qhn@Tommy tcpcliserv]$ ./tcpcli01 127.0.0.1</span><br><span class="line">hello</span><br><span class="line">hello</span><br><span class="line">hi</span><br><span class="line">hi</span><br><span class="line">another line</span><br><span class="line">str_cli: server terminated prematurely</span><br><span class="line">[qhn@Tommy tcpcliserv]$ </span><br></pre></td></tr></table></figure><p>本例的问题在于：当 FIN 到达客户套接字时，<u>客户正阻塞在 fgets 调用上，不能够及时处理</u>。客户端实际上在<strong>应对两个描述符——套接字和用户输入</strong>。它不能单纯阻塞在这两个源中某个特定源的输入上，而是应该<strong>同时阻塞</strong>在这两个源的输入上。这正是 <strong>select</strong> 和 <strong>poll</strong> 这两个函数的目的之一。</p></li></ol><h2 id="服务器主机崩溃"><a href="#服务器主机崩溃" class="headerlink" title="服务器主机崩溃"></a>服务器主机崩溃</h2><p>在不同的主机上运行服务器和客户端，先启动服务器，再启动客户端，确定它们正常启动后，从网络上断开服务器主机，并在客户键入一行文本。</p><ol><li>当服务器主机崩溃后（不是由操作员执行命令关机），已有的网络连接上不再发出任何东西。</li><li>此时客户键入一行文本，文本由 writen 写入内核，再由客户 TCP 作为一个数据分节发出。然后客户阻塞在 readline 调用，等待服务器回射应答。</li><li>此时用 tcpdump 就会发现，客户 TCP 持续重传数据分节，试图从服务器上接收一个 ACK。</li><li>既然客户阻塞在 readline 调用上，该调用会返回一个错误：<ul><li>假设服务器已经崩溃，对客户的数据分节根本没有响应，返回错误 <strong>ETIMEDOUT</strong>；</li><li>如果某个中间路由器判定服务器已不可达，则该路由器会响应一个 “destination unreachable” （目的地不可达）ICMP 消息，返回错误为 **EHOSTUNREACH **或 <strong>ENETUNREACH</strong>。</li></ul></li></ol><p>本例的问题在于：想要知道服务器主机是否崩溃，只能通过客户向服务器主机发送数据来检验。如果想不发送数据就检测出服务器主机是否崩溃，需要使用 <strong>SO_KEEPALIVE</strong> 套接字选项。</p><h2 id="服务器主机崩溃并重启"><a href="#服务器主机崩溃并重启" class="headerlink" title="服务器主机崩溃并重启"></a>服务器主机崩溃并重启</h2><p>服务器主机崩溃并重启时，在客户上键入一行文本。重启后，服务器 TCP 丢失了崩溃前所有连接信息，因此 TCP 对客户响应一个 RST（重置连接）。当客户 TCP 收到该 RST 时，客户正阻塞于 readline 调用，导致该调用返回 ECONNRESET 错误。</p><h2 id="服务器主机关机"><a href="#服务器主机关机" class="headerlink" title="服务器主机关机"></a>服务器主机关机</h2><p>服务器主机被操作员<strong>关机</strong>将会发生什么：Unix 系统关机时，init 进程会给<strong>所有进程</strong>发送一个 SIGTERM 信号（该信号可被捕获），等待一段固定时间（5~12s），然后给所有仍在运行的程序发送给一个 SIGKILL（该信号不能被捕获）。这么做的目的是，留出一小段时间给所有运行的进程来清除与终止。</p><p>如果不捕获 SIGTERM 信号并终止，服务器将由 SIGKILL 信号终止。当服务器子进程终止时，它的所有打开着的描述符都被关闭，这样又回到了<a href="##%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2">服务器进程终止</a>的问题。</p><h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><p>在客户与服务器之间传递<strong>二进制值</strong>时，如果字节序不一样或所支持的长整数的大小不一致，将会出错。</p><p>3 个问题：</p><ol><li> 不同的实现以不同的格式存储二进制数——大端字节序与小端字节序。</li><li>不同的实现在存储相同的 C 数据类型上可能存在差异——大多数 32 位 Unix 系统使用 32 位表示长整数，而 64 位系统一般使用 64 位表示长整数。</li><li><strong>不同的实现给结构打包的方式存在差异</strong>。因此，穿越套接字传送二进制结构绝不是明智的。</li></ol><p>解决方法：</p><ol><li><strong>把所有的数值数据作为文本串来传递</strong>。</li><li>显式定义所支持数据类型的二进制格式（位数、大端或小端字节序），并以这样的格式在客户与服务器之间传递所有数据。远程过程调用（RPC）通常使用这种技术。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从简单的 echo 服务器开始，解决了以下问题：</p><ul><li>处理僵死子进程——采用信号处理（signal，sigaction）。</li><li>服务器进程终止时，客户进程收到 FIN 但并不知道终止——使用 select、poll。</li><li>服务器主机崩溃时，必须通过客户向服务器发送数据才能检验—— SO_KEEPALIVE 套接字选项。</li><li>穿越套接字传送二进制结构绝不是明智的——把所有的数值数据作为文本串来传递。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/soldierback/p/10690783.html">https://www.cnblogs.com/soldierback/p/10690783.html</a></p><p><a href="https://blog.csdn.net/zzxiaozhao/article/details/102662861">https://blog.csdn.net/zzxiaozhao/article/details/102662861</a></p><p><a href="https://wuhlan3.gitee.io/wuhlan3/2021/08/03/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%94%EF%BC%89">https://wuhlan3.gitee.io/wuhlan3/2021/08/03/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%94%EF%BC%89</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;网络编程笔记-二-TCP客户-服务器示例&quot;&gt;&lt;a href=&quot;#网络编程笔记-二-TCP客户-服务器示例&quot; class=&quot;headerlink&quot; title=&quot;网络编程笔记(二)-TCP客户/服务器示例&quot;&gt;&lt;/a&gt;网络编程笔记(二)-TCP客户/服务器示例&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考《UNIX网络编程》第 5 章，《TCP/IP 网络编程》 第 10 章。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://tommyplayer-c.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="linux 网络编程" scheme="https://tommyplayer-c.github.io/tags/linux-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>网络编程笔记(三)-I/O复用：select和poll函数</title>
    <link href="https://tommyplayer-c.github.io/2021/10/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-2021-10-06-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%B8%89-IO%E5%A4%8D%E7%94%A8%EF%BC%9Aselect%E5%92%8Cpoll%E5%87%BD%E6%95%B0/"/>
    <id>https://tommyplayer-c.github.io/2021/10/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-2021-10-06-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%B8%89-IO%E5%A4%8D%E7%94%A8%EF%BC%9Aselect%E5%92%8Cpoll%E5%87%BD%E6%95%B0/</id>
    <published>2021-10-04T07:57:03.000Z</published>
    <updated>2021-10-30T01:45:27.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络编程笔记-三-I-O复用：select和poll函数"><a href="#网络编程笔记-三-I-O复用：select和poll函数" class="headerlink" title="网络编程笔记(三)-I/O复用：select和poll函数"></a>网络编程笔记(三)-I/O复用：select和poll函数</h1><blockquote><p>参考《UNIX网络编程》第 6 章，《TCP/IP 网络编程》 第 7、12 章。</p></blockquote><span id="more"></span><h1 id="I-O-模型"><a href="#I-O-模型" class="headerlink" title="I/O 模型"></a>I/O 模型</h1><p>I/O 复用的场合：</p><ol><li><p>当客户处理多个描述符时（一般是交互式输入和网络套接字），必须使用I/O复用。</p></li><li><p>当客户同时处理多个套接字时，这种情况很少出现。</p></li><li><p>如果一个 TCP 服务器既要处理监听套接字，又要处理已连接套接字，一般就要使用 I/O 复用。</p></li><li><p>如果一个服务器既要处理 TCP，又要处理 UDP，一般就要使用 I/O 复用。</p></li><li><p>如果一个服务器要处理多个服务或多个协议，一般就要使用 I/O 复用。</p></li></ol><p>UNIX 下可用的 5 种 I/O 模型：</p><ul><li>阻塞式 I/O；</li><li>非阻塞式 I/O；</li><li>I/O 复用（select 和 poll）；</li><li>信号驱动式 I/O（SIGIO）；</li><li>异步 I/O（POSIX 的 aio_系列函数）。</li></ul><p>输入操作的 2 个阶段：</p><ol><li>等待数据准备好（一般是等待数据从网络中到达，到达时被数据被复制到内核中的缓冲区）；</li><li>从内核向进程复制数据（把数据从内核缓冲区复制到应用进程缓冲区）。</li></ol><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110061602905.png" alt="image-20211006154807013" style="zoom: 67%;" /><p>前四种为同步 I/O，因为真正的 I/O 操作将阻塞进程。</p><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110061602943.png" alt="image-20211006154849809"></p><h1 id="select-函数"><a href="#select-函数" class="headerlink" title="select 函数"></a>select 函数</h1><h2 id="定义和功能"><a href="#定义和功能" class="headerlink" title="定义和功能"></a>定义和功能</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">maxfd：监视对象文件描述符数量（最大文件描述符+1）</span></span><br><span class="line"><span class="comment">readset：是否存在待读取数据的文件描述符  </span></span><br><span class="line"><span class="comment">writeset：是否可传输无阻塞数据的文件描述符  </span></span><br><span class="line"><span class="comment">exceptset：是否发生异常的文件描述符  </span></span><br><span class="line"><span class="comment">timeout：超时信息 （如果select发生了阻塞，那么就通过设置timeout防止这种情况）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 返回值：若有就绪描述符则返回其数目，超时返回 0，失败返回 -1  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfd, fd_set *readset, fd_set *writeset, fd_set *exceptset,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">const</span> struct timeval * timeout)</span>  </span></span><br></pre></td></tr></table></figure><ol><li>可读：是否存在套接字接收数据。</li><li>可写：无需阻塞传输数据的套接字有哪些。</li><li>异常：哪些套接字发生异常。</li></ol><p>select 函数调用过程：</p><ol><li>设置文件描述符，指定监视范围，设置超时。</li><li>调用 select 函数。</li><li>查看调用结果。</li></ol><h2 id="fd-set：设置文件描述符"><a href="#fd-set：设置文件描述符" class="headerlink" title="fd_set：设置文件描述符"></a>fd_set：设置文件描述符</h2><p>fd_set 数据类型的操作以<strong>位</strong>为单位进行。注册和更改值得操作由下列宏完成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;<span class="comment">// 将fd_set变量得所有位初始化为0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;<span class="comment">// 注册：将文件描述符fd置1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;<span class="comment">// 清除：将文件描述符fd置0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;<span class="comment">// 判断文件描述符fd是否被设置为1</span></span><br></pre></td></tr></table></figure><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110061602973.png" alt="image-20211005210216231" style="zoom: 67%;" /><h2 id="maxfd-和中间-3-个描述符集参数"><a href="#maxfd-和中间-3-个描述符集参数" class="headerlink" title="maxfd 和中间 3 个描述符集参数"></a>maxfd 和中间 3 个描述符集参数</h2><p>maxfd：指定待测试的描述符个数（待测试的最大描述符 +1，+1 是因为从 0 开始），描述符 0, 1, 2, … 一直到 maxfd - 1 都将被测试。</p><p>如果我们对 readset、writeset、exceptset 中的某一个条件不感兴趣，就可以把它设为空指针。</p><p>描述符集参数是<strong>值-结果参数</strong>。原来为 1 的所有位均变为 0，但发生变化的文件描述符对应位除外——值仍为 1 的文件描述符发生了变化。select 返回后使用 FD_ISSET 宏来测试 fd_set 数据类型。因此，每<u>次重新调用 select 函数时，都得再次把所有描述符集内所关心的位置为 1</u>。</p><h2 id="struct-timeval：超时时间"><a href="#struct-timeval：超时时间" class="headerlink" title="struct timeval：超时时间"></a>struct timeval：超时时间</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> tv_sec; <span class="comment">// sec  </span></span><br><span class="line">    <span class="keyword">long</span> tv_usec;<span class="comment">// microsec</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个参数有三种选择：</p><ol><li>永远等待下去：仅在有一个描述符准备好 I/O 时才返回。为此要将该参数设置为空。</li><li>等待一段固定时间（等待时间不超过这个固定时间）。为此要设置秒数和微秒数。</li><li>根本不等待：检查描述符后立即返回，这称为<strong>轮询</strong>（polling）。为此要设置秒数和微秒数均为 0。</li></ol><h2 id="描述符就绪条件"><a href="#描述符就绪条件" class="headerlink" title="描述符就绪条件"></a>描述符就绪条件</h2><p>对于每一列满足任何一行，该列的表头就准备好了。</p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110061602003.png" alt="image-20211005211636197" style="zoom:67%;" /><h1 id="str-cli-的两次修改"><a href="#str-cli-的两次修改" class="headerlink" title="str_cli 的两次修改"></a>str_cli 的两次修改</h1><p>初始的 str_cli 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_cli</span><span class="params">(FILE *fp, <span class="keyword">int</span> sockfd)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> sendline[MAXLINE], recvline[MAXLINE];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (Fgets(sendline, MAXLINE, fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    Writen(sockfd, sendline, <span class="built_in">strlen</span>(sendline));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Readline(sockfd, recvline, MAXLINE) == <span class="number">0</span>)</span><br><span class="line">      err_quit(<span class="string">&quot;str_cli: server terminated prematurely&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Fputs(recvline, <span class="built_in">stdout</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第一次修改"><a href="#第一次修改" class="headerlink" title="第一次修改"></a>第一次修改</h2><p>初始的 str_cli 问题是：当套接字发生某些事情时，客户可能阻塞与 fgets 调用。新版本改为阻塞于 select 调用——<strong>或是等待标准输入可读，或是等待套接字可读</strong>。</p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110061602033.png" alt="image-20211005225618326" style="zoom: 67%;" /><ol><li>如果对端 TCP 发送数据，那么该套接字变为可读，并且 read 返回一个大于 0 的值（即读入数据的字节数）</li><li>如果对端 TCP 发送一个 FIN（对端进程终止），那么该套接字变为可读，并且read 返回 0（EOF）</li><li>如果对端 TCP 发送一个 RST（对端主机崩溃并重新启动），那么该套接字变为可读，并且 read 返回 -1，errno 含有确切的错误码。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../lib/unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_cli</span><span class="params">(FILE *fp, <span class="keyword">int</span> sockfd)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> maxfdp1;</span><br><span class="line">  fd_set rset;<span class="comment">// readset: 读描述符集</span></span><br><span class="line">  <span class="keyword">char</span> sendline[MAXLINE], recvline[MAXLINE];</span><br><span class="line"></span><br><span class="line">  FD_ZERO(&amp;rset);</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    FD_SET(fileno(fp), &amp;rset);<span class="comment">// 打开标准IO文件指针fp</span></span><br><span class="line">    FD_SET(sockfd, &amp;rset);<span class="comment">// 打开套接字描述符</span></span><br><span class="line">    maxfdp1 = max(fileno(fp), sockfd) + <span class="number">1</span>;</span><br><span class="line">    Select(maxfdp1, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset)) &#123; <span class="comment">/* socket is readable */</span></span><br><span class="line">      <span class="keyword">if</span> (Readline(sockfd, recvline, MAXLINE) == <span class="number">0</span>) <span class="comment">// EOF</span></span><br><span class="line">        err_quit(<span class="string">&quot;str_cli: server terminated prematurely&quot;</span>);</span><br><span class="line">      Fputs(recvline, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FD_ISSET(fileno(fp), &amp;rset)) &#123;                  <span class="comment">/* input is readable */</span></span><br><span class="line">      <span class="keyword">if</span> (Fgets(sendline, MAXLINE, fp) == <span class="literal">NULL</span>) <span class="keyword">return</span>; <span class="comment">/* all done */</span></span><br><span class="line">      Writen(sockfd, sendline, <span class="built_in">strlen</span>(sendline));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个版本的 str_cli 存在两个问题：</p><ol><li><p>批量输入时，标准输入的 EOF 并不意味着同时也完成了从套接字的读入（套接字上还有数据在传送）。</p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110061602062.png" alt="image-20211005230804040" style="zoom:67%;" /></li><li><p>混合使用 stdio 和 select 导致错误——select 并不知道 stdio 使用了缓冲区。fgets 返回一行写给服务器，随后 select 被调用以等待新的工作，而不管 stdio 缓冲区还有额外的输入待消费。</p></li></ol><h2 id="shutdown-函数"><a href="#shutdown-函数" class="headerlink" title="shutdown 函数"></a>shutdown 函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值：成功返回0，出错返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> howto)</span></span></span><br></pre></td></tr></table></figure><p>close 和 shutdown 对比：</p><ol><li>close 把描述符的引用计数减 1，仅在该计数变为 0 时才关闭套接字。 shutdown 可以不管引用计数，直接激发 TCP 的正常连接终止序列（四次握手）。</li><li>close 终止读和写两个方向的数据传输。shutdown 可以告诉对方自己已经完成了数据发送，即使对端仍有数据要发送。shutdown 可以只关闭其中一个流，而非同时断开两个流。</li></ol><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110061602092.png" alt="image-20211006144931823" style="zoom:67%;" /><p>shutdown 的行为依赖于 howto 参数：</p><ul><li>SHUT_RD：断开输入流，关闭连接的读这一半——套接字中不再有数据可接收，进程不能再对这样的套接字调用任何读函数。可以把第二个参数指定为 SHUT_RD 防止环回复制。<br>关闭SO_USELOOPBACK套接字选项也能防止回环</li><li>SHUT_WR：断开输出流：关闭连接的写这一半（半关闭，half-close）进程不能再对这样的套接字调用任何写函数。</li><li>SHUT_RDWR：同时断开 I/O 流，连接的读半部和写半部都关闭，等效于调用两次 shutdown。</li></ul><h2 id="第二次修改"><a href="#第二次修改" class="headerlink" title="第二次修改"></a>第二次修改</h2><ul><li>使用 select：服务器关闭它那一段的连接就会通知我们。</li><li>使用 shutdown：废弃了以文本行为中心的代码，改而针对缓冲区操作。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../lib/unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_cli</span><span class="params">(FILE *fp, <span class="keyword">int</span> sockfd)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> maxfdp1, stdineof; <span class="comment">// stdineof是一个初始化为0的新标志，只要该标志为0，每次在主循环我们总是select标准输入的可读性。</span></span><br><span class="line">  fd_set rset;</span><br><span class="line">  <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">  stdineof = <span class="number">0</span>;</span><br><span class="line">  FD_ZERO(&amp;rset);</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (stdineof == <span class="number">0</span>) FD_SET(fileno(fp), &amp;rset); <span class="comment">// select标准输入的可读性</span></span><br><span class="line">    FD_SET(sockfd, &amp;rset);</span><br><span class="line">    maxfdp1 = max(fileno(fp), sockfd) + <span class="number">1</span>;</span><br><span class="line">    Select(maxfdp1, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset)) &#123; <span class="comment">/* socket is readable */</span></span><br><span class="line">      <span class="keyword">if</span> ((n = Read(sockfd, buf, MAXLINE)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stdineof == <span class="number">1</span>)  <span class="comment">// 在套接字读到EOF时，如果我们已在标准输入上遇到 EOF，那就是正常的终止</span></span><br><span class="line">          <span class="keyword">return</span>; <span class="comment">/* normal termination */</span></span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">// 如果没有在标准输入上遇到 EOF，那就是服务器进程已经过早终止。</span></span><br><span class="line">          err_quit(<span class="string">&quot;str_cli: server terminated prematurely&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Write(fileno(<span class="built_in">stdout</span>), buf, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FD_ISSET(fileno(fp), &amp;rset)) &#123; <span class="comment">/* input is readable */</span></span><br><span class="line">      <span class="keyword">if</span> ((n = Read(fileno(fp), buf, MAXLINE)) == <span class="number">0</span>) &#123;</span><br><span class="line">        stdineof = <span class="number">1</span>; <span class="comment">// 标准输入上碰到EOF，将新标志置为1</span></span><br><span class="line">        Shutdown(sockfd, SHUT_WR); <span class="comment">/* send FIN */</span></span><br><span class="line">        FD_CLR(fileno(fp), &amp;rset);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Writen(sockfd, buf, n); <span class="comment">// read和write：对缓冲区而不是文本行进行操作。</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="TCP-回射服务器程序（修订版）"><a href="#TCP-回射服务器程序（修订版）" class="headerlink" title="TCP 回射服务器程序（修订版）"></a>TCP 回射服务器程序（修订版）</h1><p>服务器使用 select 的版本，避免了为每个客户创建一个新进程。</p><p>《TCP/IP网络编程》P203-P205</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> serv_sock, clnt_sock;</span><br><span class="line">  <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clnt_adr</span>;</span></span><br><span class="line">  <span class="keyword">socklen_t</span> adr_sz;</span><br><span class="line">  fd_set reads, cpy_reads;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">  <span class="keyword">int</span> fd_max, str_len, fd_num, i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (serv_sock == <span class="number">-1</span>) &#123;</span><br><span class="line">    error_handling(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">  serv_adr.sin_family = AF_INET;</span><br><span class="line">  serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">  serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bind(serv_sock, (struct sockaddr *)&amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">    error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (listen(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">    error_handling(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  FD_ZERO(&amp;reads);</span><br><span class="line">  FD_SET(serv_sock, &amp;reads);<span class="comment">// 初始时，监听套接字是描述集中唯一的非0项</span></span><br><span class="line">  fd_max = serv_sock;<span class="comment">// 这里不加1，下面select时就要加1，因为从0到fd_max-1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    cpy_reads = reads;</span><br><span class="line">    timeout.tv_sec = <span class="number">5</span>;</span><br><span class="line">    timeout.tv_usec = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd_num = select(fd_max + <span class="number">1</span>, &amp;cpy_reads, <span class="number">0</span>, <span class="number">0</span>, &amp;timeout)) == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (fd_num == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; fd_max + <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (FD_ISSET(i, &amp;cpy_reads)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == serv_sock) &#123;  <span class="comment">// connection request</span></span><br><span class="line">          adr_sz = <span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line">          clnt_sock = accept(serv_sock, (struct sockaddr *)&amp;clnt_adr, &amp;adr_sz);</span><br><span class="line">          FD_SET(clnt_sock, &amp;reads);<span class="comment">// 注册与客户端连接的套接字文件描述符</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (fd_max &lt; clnt_sock) &#123;</span><br><span class="line">            fd_max = clnt_sock;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;connected client : %d \n&quot;</span>, clnt_sock);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// read message</span></span><br><span class="line">          str_len = read(i, buf, BUF_SIZE);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (str_len == <span class="number">0</span>) &#123;  <span class="comment">// close</span></span><br><span class="line">            FD_CLR(i, &amp;reads);</span><br><span class="line">            close(i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;closed client %d \n&quot;</span>, i);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            write(i, buf, str_len);  <span class="comment">// echo</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  close(serv_sock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">  <span class="built_in">fputs</span>(<span class="string">&quot;\n&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>《UNIX 网络编程》P138 - P142</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* include fig01 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../lib/unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, maxi, maxfd, listenfd, connfd, sockfd;</span><br><span class="line">  <span class="keyword">int</span> nready, client[FD_SETSIZE];<span class="comment">// client数组，记录客户套接字</span></span><br><span class="line">  <span class="keyword">ssize_t</span> n;</span><br><span class="line">  fd_set rset, allset;</span><br><span class="line">  <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">  <span class="keyword">socklen_t</span> clilen;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>, <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">  listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">  servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">  Bind(listenfd, (SA *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">  Listen(listenfd, LISTENQ);</span><br><span class="line"></span><br><span class="line">  maxfd = listenfd; <span class="comment">/* initialize */</span></span><br><span class="line">  maxi = <span class="number">-1</span>;        <span class="comment">/* index into client[] array */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++)</span><br><span class="line">    client[i] = <span class="number">-1</span>; <span class="comment">/* -1 indicates available entry */</span></span><br><span class="line">  FD_ZERO(&amp;allset);</span><br><span class="line">  FD_SET(listenfd, &amp;allset);</span><br><span class="line">  <span class="comment">/* end fig01 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* include fig02 */</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    rset = allset; <span class="comment">/* structure assignment */</span></span><br><span class="line">    nready = Select(maxfd + <span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FD_ISSET(listenfd, &amp;rset)) &#123; <span class="comment">/* new client connection */</span></span><br><span class="line">      clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">      connfd = Accept(listenfd, (SA *)&amp;cliaddr, &amp;clilen);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++)</span><br><span class="line">        <span class="keyword">if</span> (client[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          client[i] = connfd; <span class="comment">/* save descriptor */</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (i == FD_SETSIZE) err_quit(<span class="string">&quot;too many clients&quot;</span>);</span><br><span class="line"></span><br><span class="line">      FD_SET(connfd, &amp;allset);            <span class="comment">/* add new descriptor to set */</span></span><br><span class="line">      <span class="keyword">if</span> (connfd &gt; maxfd) maxfd = connfd; <span class="comment">/* for select */</span></span><br><span class="line">      <span class="keyword">if</span> (i &gt; maxi) maxi = i;             <span class="comment">/* max index in client[] array */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">/* no more readable descriptors */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= maxi; i++) &#123; <span class="comment">/* check all clients for data */</span></span><br><span class="line">      <span class="keyword">if</span> ((sockfd = client[i]) &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n = Read(sockfd, buf, MAXLINE)) == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">/*connection closed by client */</span></span><br><span class="line">          Close(sockfd);</span><br><span class="line">          FD_CLR(sockfd, &amp;allset);</span><br><span class="line">          client[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">          Writen(sockfd, buf, n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">/* no more readable descriptors */</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* end fig02 */</span></span><br></pre></td></tr></table></figure><h1 id="pselect-函数"><a href="#pselect-函数" class="headerlink" title="pselect 函数"></a>pselect 函数</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值：若有就绪描述符则为其数目，若超时则为0，若出错则为-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pselect</span><span class="params">(<span class="keyword">int</span> maxfdpl, fd_set *readset, fd_set *writeset, fd_set *execptset, </span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> struct timespec *timeout, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *sigmask)</span></span>;</span><br></pre></td></tr></table></figure><ol><li><p>pselect 使用 timespec 结构，而不使用 timeval 结构.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line"><span class="keyword">time_t</span> tv_sec; <span class="comment">// seconds</span></span><br><span class="line"><span class="keyword">long</span> tv_nsec; <span class="comment">// nanoseconds，指定纳秒而不是微秒</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>pselect 函数增加了第六个参数——一个指向信号掩码的指针。该参数允许先禁止递交某些信号，再测试由这些当前被禁止的信号处理函数设置全局变量，然后调用 pselect，告诉它重新设置信号掩码。</p></li></ol><h1 id="poll-函数"><a href="#poll-函数" class="headerlink" title="poll 函数"></a>poll 函数</h1><p>poll 提供的功能与 select 类似，不过在处理流设备时，它能提供额外信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值：若有就绪描述符则为其数目，若超时则为0，若出错则为-1</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">fd: 第一个参数是指向一个结构数组第一个元素的指针。每个数组元素都是一个pollfd结构，用于指定测试某个给定描述符fd的条件。</span></span><br><span class="line"><span class="comment">nfds: 指定结构结构数组中的元素个数。</span></span><br><span class="line"><span class="comment">timeout: 指定poll函数在返回前等待多长时间。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fd, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>要测试的条件由 events 指定，poll 函数在相应的 revents 成员中返回该描述符的状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">　　<span class="keyword">int</span> fd;          <span class="comment">// 被监视的文件描述符</span></span><br><span class="line">　　<span class="keyword">short</span> events;    <span class="comment">// 请求的事件</span></span><br><span class="line">　　<span class="keyword">short</span> revents;   <span class="comment">// 实际发生的事件</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>events 和 revents 的一些常值：第一部分处理输入，第二部分处理输出，第三部分处理错误（只能在 revents 中设定）。poll 识别三类数据：普通（normal），优先级带（priority band），高优先级（high priority）。</p><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110061602119.png" alt="image-20211006152607217"></p><p>timeout 值：</p><ul><li>INFTIM：永远等待；</li><li>0：立即返回，不阻塞进程；</li><li>＞0：等待指定数目的毫秒数。</li></ul><p>使用poll()和select()不一样，你不需要显式地请求异常情况报告。</p><ul><li>POLLIN | POLLPRI等价于select()的读事件.</li><li>POLLOUT |POLLWRBAND等价于select()的写事件。</li><li>POLLIN等价于POLLRDNORM |POLLRDBAND</li><li>而POLLOUT则等价于POLLWRNORM。</li></ul><p>例如，要同时监视一个文件描述符是否可读和可写，我们可以设置 events为POLLIN |POLLOUT。在poll返回时，我们可以检查revents中的标志，对应于文件描述符请求的events结构体。如果POLLIN事件被设置，则文件描述符可以被读取而不阻塞。如果POLLOUT被设置，则文件描述符可以写入而不导致阻塞。这些标志并不是互斥的：它们可能被同时设置，表示这个文件描述符的读取和写入操作都会正常返回而不阻塞。</p><p>使用 poll 函数改写 TCP 回射服务器程序：《UNIX 网络编程》P146-P148</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>5 种 I/O 模型，这里只讨论 I/O 复用模型。</li><li>I/O 复用最常用的函数是 select。批量输入时，即使用户输入结束，仍然有可能有数据残留在服务器和客户间的管道上（2个方向），需要使用 shutdown 函数以利用其半关闭特性。</li><li>混合使用 stdio 和 read/write 有危险，需要针对缓冲区而不是文本行进行操作。</li><li>poll 函数功能类似 select，但它能为流设备提供额外信息</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://wuhlan3.gitee.io/wuhlan3/2021/08/04/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E5%85%AD%EF%BC%89">https://wuhlan3.gitee.io/wuhlan3/2021/08/04/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E5%85%AD%EF%BC%89</a></p><p><a href="https://www.cnblogs.com/Anker/p/3258674.html">IO多路复用之select总结</a></p><p><a href="https://www.cnblogs.com/Anker/p/3261006.html">IO多路复用之poll总结</a></p><p><a href="https://blog.csdn.net/lixungogogo/article/details/52226434">https://blog.csdn.net/lixungogogo/article/details/52226434</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;网络编程笔记-三-I-O复用：select和poll函数&quot;&gt;&lt;a href=&quot;#网络编程笔记-三-I-O复用：select和poll函数&quot; class=&quot;headerlink&quot; title=&quot;网络编程笔记(三)-I/O复用：select和poll函数&quot;&gt;&lt;/a&gt;网络编程笔记(三)-I/O复用：select和poll函数&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考《UNIX网络编程》第 6 章，《TCP/IP 网络编程》 第 7、12 章。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://tommyplayer-c.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="linux 网络编程" scheme="https://tommyplayer-c.github.io/tags/linux-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>网络编程笔记(一)-基本TCP套接字编程</title>
    <link href="https://tommyplayer-c.github.io/2021/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%B8%80-%E5%9F%BA%E6%9C%ACTCP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/"/>
    <id>https://tommyplayer-c.github.io/2021/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%B8%80-%E5%9F%BA%E6%9C%ACTCP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/</id>
    <published>2021-09-29T16:00:00.000Z</published>
    <updated>2021-10-24T09:01:24.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络编程笔记-一-基本TCP套接字编程"><a href="#网络编程笔记-一-基本TCP套接字编程" class="headerlink" title="网络编程笔记(一)-基本TCP套接字编程"></a>网络编程笔记(一)-基本TCP套接字编程</h1><blockquote><p> 参考《UNIX网络编程》1 - 4 章，《TCP/IP网络编程》1 - 5 章。</p></blockquote><span id="more"></span><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><p><strong>守护进程</strong>（daemon）：一般认为 Web 服务器程序是一个长时间运行的程序，它只在响应来自网络的请求时才发送网络消息。守护进程能在后台运行且不跟任何终端关联。</p></li><li><p>TCP 套接字的花哨名字：网际（AF_INET）字节流（SOCK_STREAM）套接字</p></li><li><p>时间获取服务器的众所周知端口：13</p></li><li><p>协议无关性：</p><p>将 IPv4 修改为 IPv6 协议</p><ul><li>sockaddr_in ——&gt; sockaddr_in6</li><li>AF_INET ——&gt; AF_INET6</li><li>sin_port ——&gt; sin6_port</li></ul><p>更好的做法是编写协议无关程序。</p></li><li><p>包裹函数</p><p>weapper function。在本书中，约定包裹函数名是实际函数名的首字母<strong>大写形式</strong>。每个包裹函数完成实际的函数调用，检查返回值，并在错误时终止进程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Socket</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span>( (n = <span class="built_in">socket</span>(family, type, protocol)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Unix <strong>errno</strong> 值：只要有一个 UNIX 函数中有错误发生，全局变量 errno 就被置为一个指明该错误类型的正值，函数本身则通常返回 -1。err_sys（作者定义的）查看 errno 变量的值并输出相应的出错信息。</p></li><li><p>服务器种类：</p><ul><li><p>迭代服务器：对于每个客户都迭代执行一次</p></li><li><p>并发服务器：同时处理多个客户（Unix 的 fork 函数，用线程替代 fork 等）</p></li></ul></li><li><p>国际标准化组织（International Organization for Standardization，ISO）的计算机通信开放系统互连模型（open systems interconnection，OSI），是一个七层模型。</p><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091547452.png" alt="image-20211004151149492"><br>物理层/数据链路层：随系统提供的设备驱动程序和网络硬件。</p><p>网络层：由 IPv4 和 IPv6 这两个协议处理。在附录 A 中讲述。</p><p>传输层：即本书所讲的套接字编程接口，从应用层(上3层)进入传输层的接口。</p><p>会话层/表示层/应用层：OSI 的顶上三层被合并为一层，称为应用层。Web 客户端（浏览器)、Telnet 客户、web 服务器、FTP 服务器等在这层。</p><p>《Unix 网络编程》讲述的套接字编程接口是从顶上三层（网际协议的应用层）进入传输层的接口，重点关注如何使用套接字编写使用 TCP 或 UDP 的网络应用程序。</p><p>套接字提供的是从OSI模型的顶上三层进入传输层的接口，这里设计有两个原因：</p><ul><li>理由一：顶上三层处理具体网络应用（如 FTP、Telnet 或 HTTP）的所有细节，却对通信细节了解很少；底下四层对具体网络应用了解不多，却处理所有的通信细节：发送数据，等待确认，给无序到达的数据排序，计算并验证校验和等等。</li><li>理由二：顶上三层通常构成所谓的用户进程（user process），底下四层却通常作为操作系统内核的一部分提供。Unix 与其他现代操作系统都提供分隔用户进程与内核进程的机制。由此可见，<u>第 4 层和第 5 层之间的接口是构建 API 的自然位置</u>。</li></ul></li><li><p>POSIX（Portable  Operating System Interface，可移植操作系统接口）</p><ul><li>64 位体系结构：LP64 模型中，长整数（L）和指针（P）都占用 64 位。</li></ul></li></ul><h3 id="相关-linux-指令"><a href="#相关-linux-指令" class="headerlink" title="相关 linux 指令"></a>相关 linux 指令</h3><ol><li><p><code>netstat -ni</code>：提供网络接口信息，-n 输出数值地址而不是反向解析为名字。其中 loopback 接口称为 lo，以太网接口称为 eth0（这里是 ens33）。</p><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548958.png" alt="image-20211004152710613"></p></li><li><p><code>netstat -nr</code>：查看路由表</p><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548322.png" alt="image-20211004153659445"></p></li><li><p><code>ifconfig ens33</code>：获得 ens33 以太网接口的详细信息</p><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548850.png" alt="image-20211004153901168"></p></li><li><p><code> ping -b 192.168.200.255</code>：对本地接口的广播地址执行 ping ，可以找到本地网络中其他主机的 IP 地址。</p></li><li><p>Linux ps（英文全拼：process status）命令用于显示当前进程的状态，类似于 windows 的任务管理器</p></li></ol><ol start="6"><li>grep：Global regular expression print</li></ol><h3 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h3><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548054.png" alt="image-20211009090554559"></p><ul><li><p>TCP 提供面向连接的、可靠的、排序、流量控制、全双工的数据传送服务。</p></li><li><p>UDP 提供无连接的、不可靠的、尽力服务。发送给接收进程的数据有可能丢失，也有可能错序。</p></li><li><p>SCTP：流控制传输协议。提供可靠全双工<strong>关联</strong>的面向连接的协议。</p><p>使用关联来指代 SCTP 的连接：一个连接只涉及两个 IP 地址之间的通信，一个关联指代两个系统之间的一次通信。</p><ul><li>SCTP 是<strong>多宿</strong>的，单个 SCTP 端点能够支持多个 IP 地址。</li><li>SCTP 面向消息，它提供各个记录的按序递送服务。</li></ul></li></ul><h4 id="TCP-的建立和终止"><a href="#TCP-的建立和终止" class="headerlink" title="TCP 的建立和终止"></a>TCP 的建立和终止</h4><p>TCP 三路握手建立连接：</p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548474.png" alt="image-20211009092049576" style="zoom: 67%;" /><ol><li>服务器<strong>被动打开</strong> (passive open)：服务器调用 socket、bind、litsen 函数，准备好接受外来连接。</li><li>客户<strong>主动打开</strong> (active open)：客户调用 connext，发送 SYN 报文，告诉对方初始序号。通常 SYN 报文不携带数据，其所在的 IP 数据报只包含一个 IP 首部、一个 TCP 首部和可能有的TCP选项。</li><li>服务器必须确认（ACK）客户的 SYN：服务器在单个分节中，发送自己要发送数据的初始序列号 SYN 和对客户 SYN 的确认（ACK）。</li><li>客户必须确认服务器的 SYN，发送 ACK。</li></ol><p>TCP选项：</p><ul><li>MSS 选项：通告对端自己的最大报文段长度（maximum segment size）</li><li>窗口规模选项：通告对端的最大窗口大小（advertised window size）为 65535(16 bits)，但现在要求更大的窗口，必须左移 0~14 位。</li><li>时间戳选项：防止失而复现的分组可能造成的数据损坏。窗口规模选项和时间戳选项也称<strong>长肥管道选项</strong>。</li></ul><p>TCP 四路握手释放连接：</p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548064.png" alt="image-20211009093305378" style="zoom:67%;" /><ol><li><strong>主动关闭</strong> (active close)：某个应用进程首先调用 close，发送一个 FIN 分节表示自己的数据发送完毕。</li><li><strong>被动关闭</strong> (passive close)：TCP 确认这个 FIN，<u>它的接收也作为一个文件结束符（EOF）传递给接收端应用进程</u>（FIN 意味着无额外数据可接收）。</li><li>一段时间后，接收 FIN 的进程将会调用 close 关闭自己的套接字，它的 TCP 也发送一个FIN。</li><li>接收到最终 FIN 的原发送端 TCP 确认这个 FIN。</li></ol><p><strong>半关闭</strong> (half-close)：被动关闭一端向主动关闭一端流动数据。</p><p>当一个 Unix 进程不论自愿地（调用 exit 或从 main 函数返回）还是非自愿地（收到一个终止本进程的信号）终止时，所有打开的描述符都被关闭，这也导致仍然打开的任何 TCP 连接上也发出一个 FIN。</p><h4 id="TCP-状态转移图"><a href="#TCP-状态转移图" class="headerlink" title="TCP 状态转移图"></a>TCP 状态转移图</h4><p>理解状态转换图是使用 netstat 命令诊断网络问题的基础。</p><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548077.png" alt="image-20211009122724708"></p><h4 id="TIME-WAIT状态"><a href="#TIME-WAIT状态" class="headerlink" title="TIME_WAIT状态"></a>TIME_WAIT状态</h4><p>TIME_WAIT：停留在这个状态的持续时间是最长报文段生命期（maximum segment lifetime，MSL）的两倍，也称 2MSL。</p><p>TIME_WAIT 状态存在的两个理由：</p><ol><li>可靠地实现 TCP 全双工连接的终止：最终的 ACK 需要维护状态，比如 ACK 丢失需要重传，否则会响应 RST</li><li>允许老的重复报文段在网络中消逝：正确处理重复的分组——迷途的重复分组/漫游的重复分组。</li></ol><h4 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h4><p>端口的作用：</p><ol><li><p>  让应用层的各种应用进程将其数据通过端口 向下 交付给传输层</p></li><li><p>让传输层知道应当将其报文段中的数据 向上 通过端口交付给应用层相应的进程</p><p>  端口是传输层的服务访问点 (SAP)：数据链路层的 SAP 是 MAC 地址，网络层的 SAP 是 IP 地址，传输层的 SAP 是端口</p></li></ol><p>端口号：标识计算机应用层中的各进程</p><p>UDP 协议和 TCP 协议如何知道把收到的数据段交给哪个上层进程呢？利用数据段 (segment) 中的<strong>目的端口号</strong> (2个字节)</p><p>端口号分类：</p><ol><li><p>IANA 的<strong>知名端口</strong>（Well-known ports，也称众所周知端口）0~1023<br>为提供知名网络服务的系统进程所用。 例如: <u>20-ftp Data，21-ftp Control，23-telnet，</u><br><u>25-SMTP，53-DNS，69-TFTP，80-HTTP，110-POP3，161-SNMP</u>。</p><p>Unix 系统的保留端口（reserved port）指的是小于 1024 的任何端口，所有知名端口都是保留端口。</p></li><li><p>注册端口（Registered ports）1024~49151。在 IANA 注册的专用端口号，为企业软件所用。    </p></li><li><p>动态端口（Private ports）49152~65535。没有规定用途的端口号，一般用户可以随意使用。也称为私用或暂用端口号。</p></li></ol><h4 id="套接字-Socket"><a href="#套接字-Socket" class="headerlink" title="套接字 (Socket)"></a>套接字 (Socket)</h4><p>(1) 通过IP地址或域名找到主机： <a href="http://www.baidu.com-&gt;36.152.44.96/">www.baidu.com-&gt;36.152.44.96</a></p><p>(2) 通过端口号找到主机上的进程</p><p>套接字是网络数据传输用的软件设备，网络编程又称套接字编程。</p><p>套接字函数是 TCP 协议的编程接口，每个 TCP 套接字都有自己的接收缓冲区和发送缓冲区。</p><p>一个 TCP 的套接字对是一个定义该连接的两个端点的四元组：本地 IP 地址、本地 TCP 端口号、外地 IP 地址、外地 TCP 端口号。<u>标识每个端点的两个值（IP 地址和端口号）通常称为一个<strong>套接字</strong></u>。</p><h4 id="TCP-端口号与并发服务器"><a href="#TCP-端口号与并发服务器" class="headerlink" title="TCP 端口号与并发服务器"></a>TCP 端口号与并发服务器</h4><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548683.png" alt="STEP1" style="zoom:67%;" /><p>STEP1：该服务器主机是多宿的。<code>*:*</code> 表示监听套接字。</p><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548944.png" alt="STEP2"></p><p>STEP2：客户主机选择临时端口 1500 连接服务器。</p><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548558.png" alt="STEP3"></p><p>STEP3：我们必须区分已连接套接字和监听套接字。注意已连接套接字使用与监听套接字相同的本地端口（21）</p><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548420.png" alt="STEP4"></p><p>STEP4：客户主机另一个客户使用临时端口 1501 连接同一个服务器。注意第一个连接的套接字对与第二个连接的套接字对不同，因为客户选择的临时端口号不同。</p><blockquote><p>必须查看套接字对的所有 4 个元素才能确定由哪个端点接收某个到达的分节，图 2-14 对于同一个本地端口（21）存在 3 个套接字。</p></blockquote><h2 id="网络地址结构"><a href="#网络地址结构" class="headerlink" title="网络地址结构"></a>网络地址结构</h2><h3 id="IPv4-套接字地址结构"><a href="#IPv4-套接字地址结构" class="headerlink" title="IPv4 套接字地址结构"></a>IPv4 套接字地址结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来存放因特网的 IP 地址和端口号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>sin_family;<span class="comment">// 地址族（Address Family）</span></span><br><span class="line">    <span class="keyword">uint16_t</span> sin_port;<span class="comment">// 16位TCP/UDP端口号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span><span class="comment">// 32位IP地址</span></span><br><span class="line">    <span class="keyword">char</span> sin_zero[<span class="number">8</span>];<span class="comment">// 不使用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">in_addr_t</span> s_addr<span class="comment">// 32位IPv4地址，整数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用的套接字地址结构，经常将sockaddr_in强制转换为sockaddr，它是bind函数的指针参数之一</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin_family;<span class="comment">// 地址族（Address Family）</span></span><br><span class="line">    <span class="keyword">char</span>sa_data[<span class="number">14</span>];<span class="comment">// 地址信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example:</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span><span class="comment">// 直接向 sockaddr 填充地址信息很麻烦（要填充0）</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 类型强制转换    </span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">bind</span>(serv_sock, (struct sockaddr *)&amp;serv_addr, <span class="built_in"><span class="keyword">sizeof</span></span>(serv_addr)) == <span class="number">-1</span>)</span><br><span class="line">    <span class="built_in">error_handling</span>(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>sockaddr_in 参数分析：</p><ol><li>sin_family：地址族，AF_INET（IPV4网络协议中使用的地址族），AF_INET6（IPV6网络协议中使用的地址族），AF_LOCAL（本地通信中采用的UNIX协议的地址族）。</li><li>sin_port：以网络字节序保存 <strong>16</strong> 位端口号。</li><li>sin_addr：以网络字节序保存 <strong>32</strong> 位地址信息。</li><li>sin_zero：使结构体 sockaddr_in 的大小与结构体 <strong>sockaddr</strong> 保持一致而插入的成员，<strong>必须填充 0</strong>.</li></ol><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548687.png" alt="image-20210920085002811"></p><p>注意点：</p><ul><li><p>32 位 IPv4 地址存在两种不同访问方法：</p><ul><li> <code>serv.sin_addr</code> 按照 <code>in_addr</code> <strong>结构</strong>来引用地址。</li><li> <code>serv.sin_addr.s_addr</code>  按照 <code>in_addr_t</code>（通常是一个无符号位的 32 位<strong>整数</strong>）来引用地址。</li></ul><p>必须正确使用 IPv4 地址，尤其是它作为函数参数时，因为编译器对<strong>传递结构</strong>和<strong>传递整数</strong>的处理是完全不同的。</p></li><li><p>sin_zero 字段未曾使用，总是把它置为 0。按照惯例，我们总是在填写结构体之前，把整个结构体都置为 0。<u>使用 <code>bzero()</code> 函数</u></p></li><li><p>socket 地址结构仅在给定主机上使用：虽然某些字段（例如IP地址和端口号）用在不同主机之间的通信中，<u>但是结构本身是不会在主机上传递的</u>。</p></li></ul><h3 id="IPv6-套接字地址结构"><a href="#IPv6-套接字地址结构" class="headerlink" title="IPv6 套接字地址结构"></a>IPv6 套接字地址结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span>&#123;</span></span><br><span class="line">    <span class="keyword">unit8_t</span>s6_addr[<span class="number">16</span>];<span class="comment">/* 128位IPv6地址 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIN6_LEN</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span><span class="title">sockaddr_in6</span>&#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span>sin6_len;<span class="comment">// 结构体长度（28）</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>sin6_family;<span class="comment">// AF_INET6</span></span><br><span class="line">    <span class="keyword">in_port_t</span>sin6_port;</span><br><span class="line">    <span class="keyword">uint32_t</span>sin6_flowinfo;<span class="comment">// 流信息，它的使用依然是一个课题</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span><span class="title">sin6_addr</span>;</span><span class="comment">// IPv6地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span>sin6_scope_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新的通用的套接字地址结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span>&#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span>ss_len;</span><br><span class="line">    <span class="keyword">sa_family_t</span>ss_family;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>新的 struct sockaddr_storage <u>足以容纳系统所支持的任意套接字地址结构</u>。</p><ol><li><p>如果系统支持的任何套接字地址结构有对齐需要，那么 sockaddr_storage 能够满足最苛刻的对齐要求。</p></li><li><p>sockaddr_storage 足够大，能够容纳系统支持的任何套接字地址结构。</p></li></ol><p>注：除了上面呈现的两个字段外，其他字段对于用户是透明的，需要对 sockaddr_storage 进行类型强制转换后才能够访问其他字段。</p><h3 id="网络字节序和主机字节序"><a href="#网络字节序和主机字节序" class="headerlink" title="网络字节序和主机字节序"></a>网络字节序和主机字节序</h3><h4 id="字节排序函数"><a href="#字节排序函数" class="headerlink" title="字节排序函数"></a>字节排序函数</h4><p>主机字节序（Host Byte Order）——CPU 在内存中存储数据的方式：</p><ul><li><p>大端序（Big Endian）：高位字节存放到低位地址。</p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548376.png" alt="image-20210920090820279" style="zoom: 67%;" /></li><li><p>小端序（Little Endian）：高位字节存放到高位地址。</p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548125.png" alt="image-20210920090842486" style="zoom:67%;" /></li></ul><p>因特网的<strong>网络字节序</strong> (Network Byte Order) 采用大端序，即<strong>先发送高位字节</strong>。例如，发送 0x66020304 的网络序为 04 03 02 66（最右边的最先发送）</p><p><strong>字节序转换</strong>（Endian Conversations）：在填充 sockaddr_in 结构体前，先要将数据转换为网络字节序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h：主机字节序，n：网络字节序</span></span><br><span class="line"><span class="comment">// s代表short，16位，用于端口号转换。</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="title">htons</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> host)</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> net)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// l代表long，32位，用于IP地址转换。</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">htonl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> host)</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> net)</span></span></span><br></pre></td></tr></table></figure><h4 id="字节操纵函数"><a href="#字节操纵函数" class="headerlink" title="字节操纵函数"></a>字节操纵函数</h4><p>名字以 b 开头的第一组函数起源于 4.2BSD：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：把目标字符串中指定数目的字节置为0，经常使用该函数把一个套接字地址结构初始化为0.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bzero</span> <span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bcopy</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">void</span> *dest, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bcmp</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr1, <span class="keyword">const</span> <span class="keyword">void</span> *ptr2, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure><p>名字以 mem 开头的第二组函数起源于 ANSI C 标准：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">// 记忆方法：dest = src;长度参数总是最后一个参数。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span> <span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">int</span> c, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span> <span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">memcmp</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr1, <span class="keyword">const</span> <span class="keyword">void</span> *ptr2, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="地址转换函数"><a href="#地址转换函数" class="headerlink" title="地址转换函数"></a>地址转换函数</h4><p>点分十进制的字符串 –》32位网络字节序的二进制整数值：n 代表数值（numeric），a 代表地址（address）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：将转换结果（32位IP地址）直接保存在 in_addr 结构体中</span></span><br><span class="line"><span class="comment">// 返回值：成功时（字符串有效）返回1，失败时返回0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * string, struct in_addr * addr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：把 点分十进制的IP地址 转化为 32位IP地址。</span></span><br><span class="line"><span class="comment">// 返回值：成功时返回32位大端型整数值，失败时返回-1，可以检测无效的IP地址</span></span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * string)</span></span>;</span><br></pre></td></tr></table></figure><p>注意：inet_addr 已被废弃：该函数出错时返回 INADDR_NONE常值（通常是一个32位均为1的值），<u>有线广播地址 255.255.255.255 不能被该函数处理</u>！</p><p>32位网络字节序的二进制整数值 –》点分十进制的字符串：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：把 32位IP地址 转化为 点分十进制的IP地址</span></span><br><span class="line"><span class="comment">// 返回值：成功时返回转换后的 点分十进制数串的指针，失败时返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">inet_ntoa</span><span class="params">(struct in_addt adr)</span></span>;</span><br></pre></td></tr></table></figure><p>可用于 IPv4 和 IPv6 的地址转换函数：p 代表表达（presentation），n 代表数值（numeric）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：将strptr所指的字符串转换为数值，并通过addrptr指针存放二进制结果。</span></span><br><span class="line"><span class="comment">// 返回值：若成功则为1，若输入不是有效的表达格式则为0，若出错则为-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">const</span> <span class="keyword">char</span> *strptr, <span class="keyword">void</span> *addrptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：从数值格式（addrptr）转换到表达格式（strptr）</span></span><br><span class="line"><span class="comment">// 参数：len-目标存储单元的大小。</span></span><br><span class="line"><span class="comment">// 返回值：若成功则为指向结果的指针，若出错则为NULL</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">const</span> <span class="keyword">void</span> *addrptr, <span class="keyword">char</span> *strptr, <span class="keyword">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure><p>注：两个函数的 family 参数既可以是 AF_INET，也可以是 AF_INET6；如果以不被支持的地址族作为 family 参数，这两个函数就都返回一个错误，并将 errno 置为 EAFNOSUPPORT；</p><p>inet_ntop 函数的 strptr 参数不可以是一个空指针，调用者必须为目标存储单元分配内存并指定其大小，调用成功时，这个指针就是该函数的返回值。</p><h4 id="网络地址初始化"><a href="#网络地址初始化" class="headerlink" title="网络地址初始化"></a>网络地址初始化</h4><p>客户端：声明 sockaddr_in 结构体，并初始化要连接的服务器端套接字的 IP 地址和端口号，然后调用 connect 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line"><span class="keyword">char</span> *serv_ip = <span class="string">&quot;211.217.168.13&quot;</span></span><br><span class="line"><span class="keyword">char</span> *serv_port = <span class="string">&quot;9190&quot;</span>   </span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));<span class="comment">// 结构体变量的所有成员初始化为0</span></span><br><span class="line">serv_addr.sin_family = AF_INET;<span class="comment">// 指定地址族</span></span><br><span class="line">serv_addr.sin_addr.s_addr = inet_addr(serv_ip);</span><br><span class="line">serv_addr.sin_port = htons(atoi(serv_port));<span class="comment">// atoi--把ascii转化为int，htons—主机序到网络序</span></span><br></pre></td></tr></table></figure><p>服务器：声明 sockaddr_in 结构体，初始化服务器端 IP 和端口号，可以使用 <strong>INADDR_ANY</strong> 自动获取服务器端的 IP 地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line"><span class="keyword">char</span> *serv_port = <span class="string">&quot;9190&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));<span class="comment">// 结构体变量的所有成员初始化为0</span></span><br><span class="line">serv_addr.sin_family = AF_INET;<span class="comment">// 指定地址族</span></span><br><span class="line">serv_addr.sin_addr.s_addr = inet_addr(INADDR_ANY);<span class="comment">// INADDR_ANY: 监听所有(接口的)IP地址</span></span><br><span class="line">serv_addr.sin_port = htons(atoi(serv_port));<span class="comment">// atoi--把ascii转化为int，htons—主机序到网络序</span></span><br></pre></td></tr></table></figure><h2 id="值-结果参数"><a href="#值-结果参数" class="headerlink" title="值-结果参数"></a>值-结果参数</h2><p>当向一个套接字函数传递一个套接字地址结构时，总是以引用传递，即传递的是一个<strong>指向结构的指针</strong>。该结构的长度也作为参数来传递，其传递的方式取决于该结构的传递的方向：从进程到内核，还是从内核到进程。</p><ol><li><p>从进程到内核传递的套接字结构有 3 个函数：bind、connect、sendto，这三个函数的一个参数是<u>指向套接字结构的指针，另一个是结构的大小</u>，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv</span>;</span></span><br><span class="line">connect(sockfd, (SA *)&amp;serv, <span class="keyword">sizeof</span>(serv));</span><br></pre></td></tr></table></figure><p>指针和指针所指内容的大小都传递给了内核，于是内核知道需要从进程复制多少数据进来。</p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548355.png" alt="image-20210920172240912" style="zoom:67%;" /></li><li><p>从内核到进程传递的套接字地址结构有四个函数：accept、recvfrom、getsockname、getpeername，这些函数其中两个参数是：<u>指向套接字结构的指针和指向表示结构大小的指针</u>，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cli</span>;</span></span><br><span class="line"><span class="keyword">socklen_t</span> len;</span><br><span class="line"></span><br><span class="line">len = <span class="keyword">sizeof</span>(cli);</span><br><span class="line">getpeername(unixfd, (SA *)&amp;cli, &amp;len);</span><br></pre></td></tr></table></figure><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091549622.png" alt="image-20210920172555963" style="zoom:67%;" /><p>这种参数类型叫做<strong>值-结果参数</strong>：</p><ul><li>当函数被调用时，结构大小是一个<strong>值</strong>（value），它告诉<strong>内核</strong>该结构大小，这样内核在写该结构时不至于越界）。</li><li>当函数返回时，结构大小又是一个<strong>结果</strong>（result），它告诉<strong>进程内核</strong>在该结构中存储了多少信息。</li></ul><p>总结：当一个套接字函数需要填写一个结构时，该结构的长度也以引用形式传递，这样它的值也可以被函数更改。我们把这样的参数叫做值-结果参数。</p></li></ol><h2 id="书中自定义的读写函数"><a href="#书中自定义的读写函数" class="headerlink" title="书中自定义的读写函数"></a>书中自定义的读写函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span><span class="title">readn</span> <span class="params">(<span class="keyword">int</span> fildes, <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">written</span> <span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">const</span> <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readline</span> <span class="params">(<span class="keyword">int</span> fileds, <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> maxlen)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="readn-函数："><a href="#readn-函数：" class="headerlink" title="readn 函数："></a>readn 函数：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：从一个描述符读n字节</span></span><br><span class="line"><span class="comment">// 参数：fd-文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readn</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> nleft;<span class="comment">// 剩余字节数</span></span><br><span class="line">    <span class="keyword">ssize_t</span> nread;<span class="comment">// 一次read读取的字节数</span></span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">    ptr = buf;</span><br><span class="line">    nleft = n;</span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (nread = read(fd, ptr, nleft)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">                nread = <span class="number">0</span>; <span class="comment">/* call read() again */</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;         <span class="comment">/* EOF */</span></span><br><span class="line">        &#125;</span><br><span class="line">        nleft -= nread;</span><br><span class="line">        ptr += nread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (n - nleft);<span class="comment">/*return &gt;= 0*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="writen-函数："><a href="#writen-函数：" class="headerlink" title="writen 函数："></a>writen 函数：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：往一个描述符写n字节</span></span><br><span class="line"><span class="comment">// 参数：fd-文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">writen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> nleft;</span><br><span class="line">    <span class="keyword">ssize_t</span> nwritten;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">    ptr = vptr;</span><br><span class="line">    nleft = n;</span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (nwritten = write(fd, ptr, nleft)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nwritten &lt; <span class="number">0</span> &amp;&amp; errno == EINTR) &#123;</span><br><span class="line">                nwritten = <span class="number">0</span>; <span class="comment">/* call write() again */</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="number">-1</span>); <span class="comment">/* error */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        nleft -= nwritten;</span><br><span class="line">        ptr   += nwritten;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (n - nwritten);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="readline-函数："><a href="#readline-函数：" class="headerlink" title="readline 函数："></a>readline 函数：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：从一个描述符读文本行，一次一个字节，极端地慢</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readline</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> maxlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> n, rc;</span><br><span class="line">    <span class="keyword">char</span> c, *ptr;</span><br><span class="line"></span><br><span class="line">    ptr = vptr;</span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt;= maxlen; n++) &#123;</span><br><span class="line">        again:</span><br><span class="line">        <span class="keyword">if</span> ( (rc = read(fd, &amp;c, <span class="number">1</span>)) == <span class="number">1</span>) &#123;</span><br><span class="line">            *ptr++ = c;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">            *ptr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> (n - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">                <span class="keyword">goto</span> again;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *ptr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ((maxlen == (n<span class="number">-1</span>))?(n<span class="number">-1</span>):n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EINTR 错误：表示系统调用被一个捕获的信号中断，如果发生该错误则继续进行读/写操作。</p><p>注意，这个 readline 函数每读一个字节的数据就调用一次系统的 read 函数。这是非常低效的。改用标准I/O函数库可以解决性能问题，但是会引发许多后勤问题，因为 stdio 缓冲区的状态是不可见的。</p><p>下面是一个 readline 函数较快速的版本。但这会导致新的问题：使用静态变量实现跨域相继函数调用的状态信息维护，使函数变得<strong>不可重入</strong>或者说<strong>非线程安全</strong>了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> read_cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *read_ptr;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> read_buf[MAXLINE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">my_read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (read_cnt &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        again:</span><br><span class="line">        <span class="keyword">if</span> ( (read_cnt = read(fd, read_buf, <span class="keyword">sizeof</span>(read_buf))) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">                <span class="keyword">goto</span> again;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">-1</span>);            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (read_cnt == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        read_ptr = read_buf;</span><br><span class="line">    &#125;</span><br><span class="line">    read_cnt--;</span><br><span class="line">    *ptr = *read_ptr++;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readline</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> maxlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> n, rc;</span><br><span class="line">    <span class="keyword">char</span> c, *ptr;</span><br><span class="line"></span><br><span class="line">    ptr = vptr;</span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt; maxlen; n++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (rc = my_read(fd, &amp;c)) == <span class="number">1</span>) &#123;</span><br><span class="line">            *ptr++ = c;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            *ptr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> (n - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *ptr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readlinebuf</span><span class="params">(<span class="keyword">void</span> **vptrptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (read_cnt) &#123;</span><br><span class="line">        *vptrptr = read_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (read_cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本-TCP-套接字编程"><a href="#基本-TCP-套接字编程" class="headerlink" title="基本 TCP 套接字编程"></a>基本 TCP 套接字编程</h2><h3 id="socket-函数"><a href="#socket-函数" class="headerlink" title="socket 函数"></a>socket 函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：创建套接字（安装电话机）</span></span><br><span class="line"><span class="comment">// 返回值：成功时返回文件描述符，失败是返回-1。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example:</span></span><br><span class="line"><span class="keyword">int</span> tcp_socket = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"><span class="keyword">int</span> udp_socket = <span class="built_in">socket</span>(PF_INET, SOCK_DGRAM, IPPROTO_UDP);</span><br></pre></td></tr></table></figure><p>固定电话和套接字其实并无太大区别，下面会利用电话机讲解套接字的创建和使用方法。</p><p>输入参数：</p><ol><li><p>family：套接字中使用的地址簇 (Address Family) 或协议簇 (Protocol Family) 信息。 </p><ol><li>PF_UNSPEC (未定义)</li><li>PF_INET：IPv4</li><li>PF_INET6：IPv6</li><li>PF_LOCAL：本地通信的 UNIX 协议簇</li><li>PF_PACKET：底层套接字的协议簇</li></ol><p>注：PF 或 AF 开头的是相同的</p></li><li><p>type：套接字数据传输类型。</p><ol><li>SOCK_STREAM：流式（stream），面向连接的套接字，收发数据的套接字内部有缓冲（buffer，就是字节数组），用于 <strong>TCP 套接字</strong>。<ul><li>可靠的：传输过程中数据不会消失。</li><li>按序传递的：按序传输数据。</li><li>基于字节的：传输的数据<strong>不存在数据边界</strong>。</li></ul></li><li>SOCK_DGRAM：数据报（datagram），面向消息的套接字，不存在连接的概念，用于 <strong>UDP 套接字</strong>。<ul><li>不按序传递的，以数据的高速传输为目的：强调快速传输而非传输顺序。</li><li>不可靠的：传输的数据可能丢失也可能损毁。</li><li>传输的数据<strong>有数据边界</strong>。</li><li>限制每次传输的数据大小。</li></ul></li><li>SOCK_RAW (原始)</li></ol></li><li><p>protocol：计算机间通信使用的协议信息地址簇中的协议号。</p><ol><li>IPPROTO_TCP (TCP的协议号6) </li><li>IPPROTO_UDP (UDP的协议号17) </li><li>IPPROTO_ICMP (ICMP的协议号1)</li></ol></li></ol><h3 id="connect-函数"><a href="#connect-函数" class="headerlink" title="connect 函数"></a>connect 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：（客户端）建立与TCP服务器的连接</span></span><br><span class="line"><span class="comment">// 返回值：成功时返回0，失败时返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr * servaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>connect 函数导致当前套接字从 CLOSED 状态转移到 SYN_SENT 状态，若成功则再转移到 ESTABLISHED 状态。</p><h3 id="bind-函数"><a href="#bind-函数" class="headerlink" title="bind 函数"></a>bind 函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：将初始化后的地址信息绑定到套接字</span></span><br><span class="line"><span class="comment">// 参数：sockfd—套接字文件描述符，myaddr-存有地址信息的结构体变量地址，addrlen-结构体变量的长度</span></span><br><span class="line"><span class="comment">// 返回值：成功时返回0，失败时返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr * myaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>bind 把一个本地协议地址赋予一个套接字。<u>调用 bind 函数可以指定一个端口号，可以指定一个 IP 地址，也可以两者都指定，还可以都不指定</u>。</p><ul><li><p>如果指定端口号为 0，则内核在 bind 被调用时选择一个临时端口；</p></li><li><p>如果 IP 地址为通配地址，那么内核将等到套接字已连接（TCP）或已在套接字上发出数据报（UDP）时才选择一个本地 IP 地址。</p><p>通配地址由常值 INADDR_ANY 来指定，其值一般为 0，它告知内核去选择 IP 地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IPv4</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IPv6</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> <span class="title">serv</span>;</span></span><br><span class="line">serv.sin6_addr = in6addr_any;</span><br></pre></td></tr></table></figure></li></ul><h3 id="listen-函数（由-TCP-服务器调用）"><a href="#listen-函数（由-TCP-服务器调用）" class="headerlink" title="listen 函数（由 TCP 服务器调用）"></a>listen 函数（由 TCP 服务器调用）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：服务器进入等待连接请求的状态</span></span><br><span class="line"><span class="comment">// 参数：sock-一个未连接的套接字，将被转换为被动套接字，指示内核应接受指向该套接字的连接请求</span></span><br><span class="line"><span class="comment">//backlog-连接请求队列的长度</span></span><br><span class="line"><span class="comment">// 返回值：成功时返回0，失败时返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091549617.png" alt="image-20210920142453244" style="zoom: 67%;" /><p>listen 把一个未连接的套接字转换成被动套接字，指示内核应接受指向该套接字的连接请求。调用 listen 导致套接字从 CLOSED 状态转移到 LISTEN。</p><p>对于参数 backlog：</p><ol><li>backlog 被定义为两队列总和的最大值。</li><li>不想接受连接时，关闭套接字，不要把 backlog 定义为 0.</li></ol><h3 id="accept-函数（由-TCP-服务器调用）"><a href="#accept-函数（由-TCP-服务器调用）" class="headerlink" title="accept 函数（由 TCP 服务器调用）"></a>accept 函数（由 TCP 服务器调用）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：从已完成连接队列队头返回下一个已完成连接。如果已完成连接队列为空，那么进程进入睡眠状态（套接字阻塞方式）</span></span><br><span class="line"><span class="comment">// 参数：sockfd-监听套接字，cliaddr-客户进程的地址，addrlen-该地址的大小</span></span><br><span class="line"><span class="comment">// 返回值：成功时返回已连接套接字，失败时返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *cliaddr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数最多返回三个值：</p><ul><li>一个既可能是新套接字描述符也可能是出错指示的整数</li><li>客户进程的协议地址（由 cliaddr 所指）</li><li>该地址的大小（由 addrlen 所指的）</li></ul><p>如果我们对返回客户协议地址不感兴趣，可以把后两个参数都设为空指针。</p><h3 id="fork-和-exec-函数（并发编程基础）"><a href="#fork-和-exec-函数（并发编程基础）" class="headerlink" title="fork 和 exec 函数（并发编程基础）"></a>fork 和 exec 函数（并发编程基础）</h3><p>**<u>fork 是 Unix 中派生新进程的唯一方法</u>**。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><u>fork 的特点是调用它一次，它却返回两次</u>：</p><ul><li>它在调用进程（父进程）中返回新派生进程（子进程）的 ID。</li><li>它在子进程中返回 0。</li></ul><p>任何子进程只有一个父进程，子进程总是可以通过调用 getppid 取得父进程的进程 ID。</p><p>fork 的 2 种典型用法：</p><ol><li>一个进程创建一个自身的副本：这样每个副本都<u>可以在另一个副本执行其他任务的同时处理各自的操作</u>（网络服务器的典型用法）。</li><li>一个进程想要执行另一个程序：先调用 fork 创建出一个自身的副本，<u>然后其中一个副本（通常为子进程）调用 exec 把自身替换成新的程序</u>（shell 之类程序的典型用法）。</li></ol><p>exec：<u>将当前<strong>进程映像</strong>替换成新的程序文件，而且该新程序通常从 main 函数开始执行</u>。进程 ID 并不改变。我们称调用 exec 的进程为调用进程（calling process），称新执行的程序为新程序（new program）。下面是  6 个 exec 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *arg0, ... <span class="comment">/* (char *)0 */</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *argv[] )</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *arg0, ... <span class="comment">/* (char *)0, char *const envp[]  */</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[] )</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *arg0, ... <span class="comment">/* (char *)0 */</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091549099.png" alt="image-20210920231718927"></p><p>这 6 个 exec 函数的区别在于：</p><ol><li>待执行的程序文件是由文件名（filename）还是由路径名（pathname）指定；</li><li>新程序的参数是一一列出还是由一个指针数组来引用；</li><li>把调用进程的环境传递给新程序还是给新程序指定新的环境。</li></ol><h3 id="并发服务器原理（重点）"><a href="#并发服务器原理（重点）" class="headerlink" title="并发服务器原理（重点）"></a>并发服务器原理（重点）</h3><p>Unix 编写并发服务器最简单的方法就是 fork 一个子进程来服务每个客户。下面是一个典型的并发服务器的轮廓。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">int</span>listenfd, connfd;</span><br><span class="line">listenfd = Socket( ... );</span><br><span class="line"><span class="comment">/* fill in sockaddr_in&#123;&#125; with server&#x27;s well known port */</span></span><br><span class="line">Bind(listenfd, ... );</span><br><span class="line">Listen(listenfd, LISTENQ);</span><br><span class="line"><span class="keyword">for</span>( ; ; )&#123;</span><br><span class="line">    connfd = Accept(listen, ... );<span class="comment">/* probably blocks*/</span></span><br><span class="line">    <span class="keyword">if</span>( (pid = Fork()) == <span class="number">0</span>)&#123;</span><br><span class="line">        Close(listenfd);<span class="comment">// 子进程关闭监听套接字</span></span><br><span class="line">        doit(connfd);<span class="comment">// 处理请求</span></span><br><span class="line">        Close(connfd);<span class="comment">// 完成客户端的请求后，子进程显式地关闭连接套接字</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">// 上一个Close其实不是必须的，因为exit（进程终止）会关闭所有由内核打开的描述符。</span></span><br><span class="line">    &#125;</span><br><span class="line">    Close(connfd);<span class="comment">// 父进程关闭已连接套接字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个连接建立时，accept 返回，服务器接着调用 fork，然后由子进程通过已连接套接字 connfd 服务客户，父进程则通过监听套接字 listenfd 等待另一个连接。<u>既然新的客户由子进程提供服务，父进程就关闭已连接套接字</u>。</p><blockquote><p>为什么父进程对 connfd 调用 close 没有终止它与客户的连接呢？</p><p>原因：每个文件或套接字都有一个在文件表项中维护的<strong>引用计数</strong>，它是当前打开着的引用该文件或套接字的描述符的个数。fork 返回后，listenfd 和 connfd 这两个描述符在父进程和子进程间共享，它们各自的访问计数值都为 2。因此，当父进程关闭 connfd 时，只是将引用计数值从 2 减为 1，不会清理和释放该套接字的资源。 </p></blockquote><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091549464.jpg" alt="并发服务器原理" style="zoom: 25%;" /><h3 id="close-函数"><a href="#close-函数" class="headerlink" title="close 函数"></a>close 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：关闭套接字，终止TCP连接，导致相应的文件描述符引用值减1.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br></pre></td></tr></table></figure><p>如果确实想要在某个TCP连接上发送一个FIN，那么可以使用shtdown函数替换close函数。</p><h3 id="getsockname-和-getpeername-函数"><a href="#getsockname-和-getpeername-函数" class="headerlink" title="getsockname 和 getpeername 函数"></a>getsockname 和 getpeername 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：返回与某个套接字关联的本地协议地址</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，出错返回-1.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockname</span> <span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *localaddr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：返回与某个套接字关联的外地协议地址（peer）</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，出错返回-1.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpeername</span> <span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *peeraddr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>这两个函数的最后一个参数都是<strong>值-结果参数</strong>。</p><p>需要这两个函数的理由：</p><ul><li><p>TCP 客户没有调用 bind 函数，connect 成功返回后，getsockname 用于返回由内核赋予该连接的<strong>本地</strong> IP 地址和本地端口号。</p></li><li><p>在以端口号 0 调用 bind （告知内核去选择本地端口号）后，getsockname 用于返回由内核赋予的本地端口号。</p></li><li><p>getsockname 可用于获取某个套接字的地址族。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sockfd_to_family</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">ss</span>;</span><span class="comment">// 新的通用套接字地址结构</span></span><br><span class="line">    <span class="keyword">socklen_t</span> len;</span><br><span class="line">    </span><br><span class="line">    len = <span class="keyword">sizeof</span>(ss);</span><br><span class="line">    <span class="keyword">if</span> (getsockname(sockfd, (SA*)&amp;ss, &amp;len) &lt; <span class="number">0</span>) <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> (ss.ss_family);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在一个以通配 IP 地址调用 bind 的 TCP 服务器上，与某个客户的连接一旦连接，getsockname 就可以用于返回由内核赋予的本地 IP 地址。</p></li><li><p>当一个服务器是由调用过 accept 的某个进程通过调用 exec 执行程序时，<u>它能够获取客户身份的唯一途径时调用 getpeername</u>.（P95）</p></li></ul><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091549688.png" alt="image-20210921092948127" style="zoom: 67%;" /><h2 id="Linux-文件函数"><a href="#Linux-文件函数" class="headerlink" title="Linux 文件函数"></a>Linux 文件函数</h2><p>Linux 系统不区分文件和套接字。</p><p>文件描述符 fd：系统分配给文件或套接字的整数。从 3 开始以由小到大的顺序编号（numbering），这是因为0、1、2 分别分配给标准输入、标准输出、标准错误。</p><h3 id="open-函数"><a href="#open-函数" class="headerlink" title="open 函数"></a>open 函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：打开文件</span></span><br><span class="line"><span class="comment">// 输入：path——文件名的字符串信息，flag——文件打开模式信息</span></span><br><span class="line"><span class="comment">// 返回值：成功时返回为文件描述符，失败时返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> flag)</span></span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>打开模式</th><th>含义</th></tr></thead><tbody><tr><td>O_CREAT</td><td>必要时创建文件</td></tr><tr><td>O_TRUNC</td><td>删除全部现有数据</td></tr><tr><td>O_APPEND</td><td>维持现有数据，保存到其后面</td></tr><tr><td>O_RDONLY</td><td>只读打开</td></tr><tr><td>O_WRONLY</td><td>只写打开</td></tr><tr><td>O_RDWR</td><td>读写打开</td></tr></tbody></table><h3 id="close-函数-1"><a href="#close-函数-1" class="headerlink" title="close 函数"></a>close 函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：关闭文件</span></span><br><span class="line"><span class="comment">// 输入：fd-需要关闭的文件或套接字的文件描述符</span></span><br><span class="line"><span class="comment">// 返回值：成功时返回0，失败时返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br></pre></td></tr></table></figure><h3 id="write-函数"><a href="#write-函数" class="headerlink" title="write 函数"></a>write 函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：将数据写入文件</span></span><br><span class="line"><span class="comment">// 输入：fd-显示数据传输对象的文件描述符，buf-保存要传输数据的缓冲地址值，nbytes-要传输的数据字节数。ssizet是通过typdef声明的signed int类型。</span></span><br><span class="line"><span class="comment">// 返回值：成功时返回写入的字节数，失败时返回-1</span></span><br><span class="line"><span class="function">ssizet <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> * buf, <span class="keyword">size_t</span> nbytes)</span></span></span><br></pre></td></tr></table></figure><h3 id="read-函数"><a href="#read-函数" class="headerlink" title="read 函数"></a>read 函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：读取文件中的数据</span></span><br><span class="line"><span class="comment">// 输入：fd-显示数据接收对象的文件描述符，buf-保存要接收数据的缓冲地址值，nbytes-要接收数据的最大字节数。ssizet是通过typdef声明的signed int类型。</span></span><br><span class="line"><span class="comment">// 返回值：成功时返回写入的字节数，失败时返回-1</span></span><br><span class="line"><span class="function">ssizet <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> * buf, <span class="keyword">size_t</span> nbytes)</span></span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/zzxiaozhao/article/details/102637708">https://blog.csdn.net/zzxiaozhao/article/details/102637708</a></p><p><a href="https://wuhlan3.gitee.io/wuhlan3/2021/07/29/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89">https://wuhlan3.gitee.io/wuhlan3/2021/07/29/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;网络编程笔记-一-基本TCP套接字编程&quot;&gt;&lt;a href=&quot;#网络编程笔记-一-基本TCP套接字编程&quot; class=&quot;headerlink&quot; title=&quot;网络编程笔记(一)-基本TCP套接字编程&quot;&gt;&lt;/a&gt;网络编程笔记(一)-基本TCP套接字编程&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; 参考《UNIX网络编程》1 - 4 章，《TCP/IP网络编程》1 - 5 章。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://tommyplayer-c.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="linux 网络编程" scheme="https://tommyplayer-c.github.io/tags/linux-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Dijkstra 算法</title>
    <link href="https://tommyplayer-c.github.io/2021/08/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-2021-08-30-Dijkstra%E7%AE%97%E6%B3%95/"/>
    <id>https://tommyplayer-c.github.io/2021/08/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-2021-08-30-Dijkstra%E7%AE%97%E6%B3%95/</id>
    <published>2021-08-30T14:24:51.000Z</published>
    <updated>2021-10-05T06:48:11.909Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dijkstra-算法复习小结"><a href="#Dijkstra-算法复习小结" class="headerlink" title="Dijkstra 算法复习小结"></a>Dijkstra 算法复习小结</h1><h2 id="一、Dijkstra-算法的基本思想"><a href="#一、Dijkstra-算法的基本思想" class="headerlink" title="一、Dijkstra 算法的基本思想"></a>一、Dijkstra 算法的基本思想</h2><p>Dijkstra 算法是解决<strong>单源最短路径</strong>问题的一般方法，它是一种贪心算法，要求图中所有边的权重<strong>非负</strong>。它的基本思想是：从一个起始顶点开始向外扩张，持续不断地将生成的图扩展到<strong>已知距离和最短路径</strong>的区域。简单地说，就是先加入最近的顶点，然后加入更远一些的顶点。</p><span id="more"></span><p>Dijkstra 算法类似广度优先搜索，扩展也是按照阶段进行的。设图的顶点集为 V，边集为 E，已知最短路径的顶点集为 R，（R 是 V 的一个子集） ，起始顶点为 s。在每个阶段，Dijkstra 算法从集合 V-R 中选择最短路径估计最小的顶点 v（<strong>在 V-R 中距离 s 最近的顶点</strong>），将 v 加入已知区域 R，<strong>然后对 v 的邻接点的最短距离进行调整更新（松弛）</strong>。</p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/20210830222540.png" alt="image-20210514195943982" style="zoom:67%;" /><p>下面给出拓展 R 的伪代码：</p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/20210830222546.png" alt="image-20210514200000659" style="zoom:67%;" /><h2 id="二、算法要点"><a href="#二、算法要点" class="headerlink" title="二、算法要点"></a>二、算法要点</h2><p>该算法的有几个要点。</p><ol><li><p>图的存储方式。这里使用邻接表较为简单。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; adj[<span class="number">1501</span>];  <span class="comment">// adj[i].first为邻接点的编号，adj[i].second为到边距离。</span></span><br></pre></td></tr></table></figure></li><li><p>每个结点需要建立一个结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">int</span> known;</span><br><span class="line">    <span class="keyword">int</span> dist;</span><br><span class="line">    <span class="keyword">int</span> path;</span><br><span class="line">    <span class="built_in">Vertex</span>() : <span class="built_in">index</span>(<span class="number">-1</span>), <span class="built_in">known</span>(<span class="number">0</span>), <span class="built_in">dist</span>(INT_MAX), <span class="built_in">path</span>(<span class="number">-1</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Vertex table[<span class="number">1501</span>];</span><br></pre></td></tr></table></figure><ul><li>index 为图中结点的编号（可有可无）</li><li>known 用来标记该节点的最短路径是否已知（true 已知，false 未知）。true 表明该节点属于已知区域 R，false 表明该节点属于 V - R。</li><li>dist 表示起始顶点 s 到该节点的距离。如果 known 为 true，则 d 为<strong>最短距离</strong>。</li><li>path 表示起始顶点 s 到该结点路径中的上一个结点（前驱），它用来打印路径。</li></ul></li><li><p>核心部分（参考伪代码写出）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    table[start].dist = <span class="number">0</span>;<span class="comment">// 起始顶点的距离为0。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="built_in">findmin</span>(n);<span class="comment">// 找到V-R中距离s最近的顶点。</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span>)<span class="comment">// 所有的顶点都已知最短路径了，即V=R。</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        table[k].known = <span class="number">1</span>;<span class="comment">// 将该节点加入已知区域R中。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新当前节点的所有邻接点的最短路径（松弛）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[k].<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = adj[k][i].first;</span><br><span class="line">            <span class="keyword">if</span> (table[v].known == <span class="number">0</span> &amp;&amp; table[v].dist &gt; table[k].dist + adj[k][i].second)</span><br><span class="line">            &#123;</span><br><span class="line">                table[v].dist = table[k].dist + adj[k][i].second;</span><br><span class="line">                table[v].path = k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果节点v最短路径未知，且经过当前顶点k的路径，能够使得从源节点s到结点v的最短路径的权重比当前的估计值更小，则我们对结点v的估计值dist和前驱path进行更新。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体细节在注释。在 main 函数中已经使用 Initiate 进行初始化（其实也不需要，因为 Vertex 类的默认构造函数已经初始化了）。</p><p>对于 findmin，可以使用优先队列，但是本人水平有限，就使用暴力搜索的方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int findmin(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int min = INT_MAX, key = -1;</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!table[i].known &amp;&amp; table[i].dist &lt; min)</span><br><span class="line">        &#123;</span><br><span class="line">            min = table[i].dist;</span><br><span class="line">            key = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="三、证明算法的正确性"><a href="#三、证明算法的正确性" class="headerlink" title="三、证明算法的正确性"></a>三、证明算法的正确性</h2><p>从 s 到 v 的最短路径即为这样一条路径——它是基于一条已知最短路径中的某条边的扩展路径，选择这些拓展路径的最短路径就可以确定v。</p><h2 id="四、时间复杂度"><a href="#四、时间复杂度" class="headerlink" title="四、时间复杂度"></a>四、时间复杂度</h2><p>If we use a vector to store “distance” information for all vertices, then finding the smallest value takes O(|V|) time, and the total updating takes O(|E|) time, and the running time is O(|V|2).</p><p>这里我使用了数组来存储结点 dist 的信息，所以 findmin 操作（找到 V-R 中 dist 最小值的顶点）会花费 O(|V|) 时间，松弛操作又花费 O(|E|) 时间，所以运行时间为 O(|V|^2)。</p><p>If we use a binary heap to store “distance” information, the finding the smallest takes O(log|V|) time and every updating also takes O(log|V|) time, so the total running time is   </p><p>​    O(|V|) + O(|V|log|V|) +O(|E|log|V|) = O(|E|log|V|).</p><p>补充：采用不同数据结构时间复杂度</p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/20210830222552.png" alt="image-20210514212832823" style="zoom: 80%;" /><h2 id="五、测试代码"><a href="#五、测试代码" class="headerlink" title="五、测试代码"></a>五、测试代码</h2><p>最后给出测试代码，如果有错请指出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; adj[<span class="number">1501</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">int</span> known;</span><br><span class="line">    <span class="keyword">int</span> dist;</span><br><span class="line">    <span class="keyword">int</span> path;</span><br><span class="line">    <span class="built_in">Vertex</span>() : <span class="built_in">index</span>(<span class="number">-1</span>), <span class="built_in">known</span>(<span class="number">0</span>), <span class="built_in">dist</span>(INT_MAX), <span class="built_in">path</span>(<span class="number">-1</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Vertex table[<span class="number">1501</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initiate</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        table[i].index = i;</span><br><span class="line">        table[i].known = <span class="number">0</span>;</span><br><span class="line">        table[i].dist = INT_MAX;</span><br><span class="line">        table[i].path = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        adj[i].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findmin</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = INT_MAX, key = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!table[i].known &amp;&amp; table[i].dist &lt; min)</span><br><span class="line">        &#123;</span><br><span class="line">            min = table[i].dist;</span><br><span class="line">            key = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    table[start].dist = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="built_in">findmin</span>(n);</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        table[k].known = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新当前节点的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[k].<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = adj[k][i].first;</span><br><span class="line">            <span class="keyword">if</span> (table[v].known == <span class="number">0</span> &amp;&amp; table[v].dist &gt; table[k].dist + adj[k][i].second)</span><br><span class="line">            &#123;</span><br><span class="line">                table[v].dist = table[k].dist + adj[k][i].second;</span><br><span class="line">                table[v].path = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(table[i].known == <span class="number">1</span>)</span><br><span class="line">            cout &lt;&lt; start &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; table[i].dist &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_path</span><span class="params">(Vertex v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.path != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">print_path</span>(table[v.path]);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; to &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; v.index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;   <span class="comment">// 样例数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;      <span class="comment">// 顶点数，边数</span></span><br><span class="line">        <span class="built_in">Initiate</span>(n);</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">            adj[u].<span class="built_in">push_back</span>(&#123;v, w&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> src;</span><br><span class="line">        cin &gt;&gt; src;</span><br><span class="line">        <span class="built_in">Dijkstra</span>(src, n);</span><br><span class="line">        <span class="built_in">Print</span>(src, n);      <span class="comment">// 输出从源点到其他点的最短路径</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">1</span><br><span class="line">100 198</span><br><span class="line">1 40 6</span><br><span class="line">1 88 3</span><br><span class="line">2 16 5</span><br><span class="line">3 51 2</span><br><span class="line">4 36 7</span><br><span class="line">4 64 3</span><br><span class="line">4 81 2</span><br><span class="line">5 94 3</span><br><span class="line">6 8 3</span><br><span class="line">7 63 3</span><br><span class="line">7 87 8</span><br><span class="line">7 99 5</span><br><span class="line">8 32 10</span><br><span class="line">8 51 1</span><br><span class="line">8 64 3</span><br><span class="line">8 66 5</span><br><span class="line">8 71 5</span><br><span class="line">8 98 8</span><br><span class="line">9 12 2</span><br><span class="line">9 40 5</span><br><span class="line">10 31 4</span><br><span class="line">10 45 4</span><br><span class="line">10 55 4</span><br><span class="line">11 24 4</span><br><span class="line">11 63 4</span><br><span class="line">12 46 2</span><br><span class="line">12 81 4</span><br><span class="line">12 97 6</span><br><span class="line">13 24 6</span><br><span class="line">15 47 10</span><br><span class="line">15 83 6</span><br><span class="line">15 100 1</span><br><span class="line">16 54 1</span><br><span class="line">16 71 6</span><br><span class="line">17 51 4</span><br><span class="line">17 90 8</span><br><span class="line">18 70 10</span><br><span class="line">18 96 9</span><br><span class="line">19 67 3</span><br><span class="line">21 47 3</span><br><span class="line">21 93 1</span><br><span class="line">21 99 3</span><br><span class="line">22 36 2</span><br><span class="line">23 21 9</span><br><span class="line">23 30 10</span><br><span class="line">23 74 4</span><br><span class="line">24 89 10</span><br><span class="line">25 71 1</span><br><span class="line">26 5 9</span><br><span class="line">26 33 10</span><br><span class="line">26 47 8</span><br><span class="line">26 73 3</span><br><span class="line">26 97 2</span><br><span class="line">27 67 2</span><br><span class="line">28 96 2</span><br><span class="line">29 64 5</span><br><span class="line">29 81 4</span><br><span class="line">30 96 5</span><br><span class="line">31 1 9</span><br><span class="line">31 35 7</span><br><span class="line">32 81 6</span><br><span class="line">33 21 9</span><br><span class="line">33 100 5</span><br><span class="line">34 4 2</span><br><span class="line">34 59 2</span><br><span class="line">34 68 3</span><br><span class="line">34 95 3</span><br><span class="line">38 24 9</span><br><span class="line">39 7 6</span><br><span class="line">39 14 6</span><br><span class="line">39 45 10</span><br><span class="line">39 90 4</span><br><span class="line">39 92 10</span><br><span class="line">41 71 6</span><br><span class="line">41 95 4</span><br><span class="line">42 43 10</span><br><span class="line">42 52 4</span><br><span class="line">42 62 5</span><br><span class="line">42 64 6</span><br><span class="line">43 9 8</span><br><span class="line">43 65 9</span><br><span class="line">43 66 10</span><br><span class="line">43 96 8</span><br><span class="line">44 13 4</span><br><span class="line">44 22 9</span><br><span class="line">44 61 3</span><br><span class="line">44 81 9</span><br><span class="line">45 52 6</span><br><span class="line">46 26 8</span><br><span class="line">47 28 1</span><br><span class="line">47 52 2</span><br><span class="line">47 70 7</span><br><span class="line">48 31 9</span><br><span class="line">48 33 2</span><br><span class="line">50 32 5</span><br><span class="line">50 43 10</span><br><span class="line">52 43 3</span><br><span class="line">52 83 8</span><br><span class="line">53 1 8</span><br><span class="line">53 4 8</span><br><span class="line">53 33 4</span><br><span class="line">53 41 2</span><br><span class="line">53 59 6</span><br><span class="line">54 58 9</span><br><span class="line">54 88 3</span><br><span class="line">56 39 3</span><br><span class="line">57 2 5</span><br><span class="line">57 23 7</span><br><span class="line">57 44 10</span><br><span class="line">59 19 9</span><br><span class="line">60 82 1</span><br><span class="line">61 22 1</span><br><span class="line">62 20 9</span><br><span class="line">62 74 6</span><br><span class="line">63 21 8</span><br><span class="line">63 98 3</span><br><span class="line">64 9 2</span><br><span class="line">64 50 8</span><br><span class="line">65 73 3</span><br><span class="line">66 24 4</span><br><span class="line">66 44 4</span><br><span class="line">67 20 10</span><br><span class="line">67 34 7</span><br><span class="line">67 68 8</span><br><span class="line">67 72 8</span><br><span class="line">67 83 8</span><br><span class="line">67 98 8</span><br><span class="line">68 8 6</span><br><span class="line">68 25 7</span><br><span class="line">68 67 5</span><br><span class="line">69 7 1</span><br><span class="line">69 85 5</span><br><span class="line">70 16 6</span><br><span class="line">70 34 6</span><br><span class="line">70 61 8</span><br><span class="line">70 84 1</span><br><span class="line">70 93 5</span><br><span class="line">71 13 3</span><br><span class="line">71 15 2</span><br><span class="line">71 67 9</span><br><span class="line">71 83 10</span><br><span class="line">71 100 5</span><br><span class="line">72 61 5</span><br><span class="line">73 6 2</span><br><span class="line">73 64 1</span><br><span class="line">74 16 5</span><br><span class="line">74 69 5</span><br><span class="line">76 14 3</span><br><span class="line">77 31 5</span><br><span class="line">77 86 1</span><br><span class="line">78 12 4</span><br><span class="line">78 59 2</span><br><span class="line">78 66 6</span><br><span class="line">79 12 5</span><br><span class="line">79 22 10</span><br><span class="line">79 57 10</span><br><span class="line">79 88 9</span><br><span class="line">80 3 3</span><br><span class="line">81 18 9</span><br><span class="line">81 32 1</span><br><span class="line">81 87 5</span><br><span class="line">82 23 7</span><br><span class="line">82 49 2</span><br><span class="line">83 5 5</span><br><span class="line">83 74 6</span><br><span class="line">83 93 10</span><br><span class="line">84 42 8</span><br><span class="line">84 52 6</span><br><span class="line">84 74 4</span><br><span class="line">84 99 8</span><br><span class="line">85 7 6</span><br><span class="line">85 60 5</span><br><span class="line">86 7 10</span><br><span class="line">88 26 5</span><br><span class="line">88 60 10</span><br><span class="line">89 18 4</span><br><span class="line">91 11 4</span><br><span class="line">91 35 5</span><br><span class="line">91 53 6</span><br><span class="line">92 44 6</span><br><span class="line">93 28 4</span><br><span class="line">93 37 5</span><br><span class="line">93 48 6</span><br><span class="line">93 87 4</span><br><span class="line">94 42 6</span><br><span class="line">94 59 8</span><br><span class="line">94 83 4</span><br><span class="line">95 28 6</span><br><span class="line">96 62 4</span><br><span class="line">97 42 6</span><br><span class="line">98 2 4</span><br><span class="line">98 33 2</span><br><span class="line">98 91 7</span><br><span class="line">99 2 8</span><br><span class="line">100 21 5</span><br><span class="line">100 30 6</span><br><span class="line">100 66 10</span><br><span class="line">100 86 7 </span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">10-1:13</span><br><span class="line">10-2:40</span><br><span class="line">10-4:44</span><br><span class="line">10-5:23</span><br><span class="line">10-6:26</span><br><span class="line">10-7:30</span><br><span class="line">10-8:29</span><br><span class="line">10-9:21</span><br><span class="line">10-10:0</span><br><span class="line">10-11:47</span><br><span class="line">10-12:23</span><br><span class="line">10-13:31</span><br><span class="line">10-15:36</span><br><span class="line">10-16:29</span><br><span class="line">10-18:36</span><br><span class="line">10-19:43</span><br><span class="line">10-20:34</span><br><span class="line">10-21:40</span><br><span class="line">10-22:31</span><br><span class="line">10-23:34</span><br><span class="line">10-24:27</span><br><span class="line">10-25:52</span><br><span class="line">10-26:21</span><br><span class="line">10-28:30</span><br><span class="line">10-30:42</span><br><span class="line">10-31:4</span><br><span class="line">10-32:28</span><br><span class="line">10-33:31</span><br><span class="line">10-34:42</span><br><span class="line">10-35:11</span><br><span class="line">10-36:33</span><br><span class="line">10-37:33</span><br><span class="line">10-40:19</span><br><span class="line">10-41:51</span><br><span class="line">10-42:29</span><br><span class="line">10-43:13</span><br><span class="line">10-44:27</span><br><span class="line">10-45:4</span><br><span class="line">10-46:25</span><br><span class="line">10-47:29</span><br><span class="line">10-48:34</span><br><span class="line">10-49:29</span><br><span class="line">10-50:33</span><br><span class="line">10-51:30</span><br><span class="line">10-52:10</span><br><span class="line">10-53:49</span><br><span class="line">10-54:30</span><br><span class="line">10-55:4</span><br><span class="line">10-58:39</span><br><span class="line">10-59:34</span><br><span class="line">10-60:26</span><br><span class="line">10-61:30</span><br><span class="line">10-62:25</span><br><span class="line">10-63:33</span><br><span class="line">10-64:25</span><br><span class="line">10-65:22</span><br><span class="line">10-66:23</span><br><span class="line">10-67:43</span><br><span class="line">10-68:45</span><br><span class="line">10-69:29</span><br><span class="line">10-70:36</span><br><span class="line">10-71:34</span><br><span class="line">10-72:51</span><br><span class="line">10-73:24</span><br><span class="line">10-74:24</span><br><span class="line">10-81:27</span><br><span class="line">10-82:27</span><br><span class="line">10-83:18</span><br><span class="line">10-84:37</span><br><span class="line">10-85:34</span><br><span class="line">10-86:43</span><br><span class="line">10-87:32</span><br><span class="line">10-88:16</span><br><span class="line">10-89:37</span><br><span class="line">10-91:43</span><br><span class="line">10-93:28</span><br><span class="line">10-94:26</span><br><span class="line">10-95:45</span><br><span class="line">10-96:21</span><br><span class="line">10-97:23</span><br><span class="line">10-98:36</span><br><span class="line">10-99:35</span><br><span class="line">10-100:36</span><br></pre></td></tr></table></figure><h2 id="六、参考文献"><a href="#六、参考文献" class="headerlink" title="六、参考文献"></a>六、参考文献</h2><ol><li><em>算法概论</em> 作者: Sanjoy Dasgupta / Christos Papadimitriou / Umesh Vazirani 出版社: <em>清华大学出版社</em>，P127-P129</li><li>算法导论 第三版，P383-P385</li></ol><h2 id="七、推荐题目"><a href="#七、推荐题目" class="headerlink" title="七、推荐题目"></a>七、推荐题目</h2>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Dijkstra-算法复习小结&quot;&gt;&lt;a href=&quot;#Dijkstra-算法复习小结&quot; class=&quot;headerlink&quot; title=&quot;Dijkstra 算法复习小结&quot;&gt;&lt;/a&gt;Dijkstra 算法复习小结&lt;/h1&gt;&lt;h2 id=&quot;一、Dijkstra-算法的基本思想&quot;&gt;&lt;a href=&quot;#一、Dijkstra-算法的基本思想&quot; class=&quot;headerlink&quot; title=&quot;一、Dijkstra 算法的基本思想&quot;&gt;&lt;/a&gt;一、Dijkstra 算法的基本思想&lt;/h2&gt;&lt;p&gt;Dijkstra 算法是解决&lt;strong&gt;单源最短路径&lt;/strong&gt;问题的一般方法，它是一种贪心算法，要求图中所有边的权重&lt;strong&gt;非负&lt;/strong&gt;。它的基本思想是：从一个起始顶点开始向外扩张，持续不断地将生成的图扩展到&lt;strong&gt;已知距离和最短路径&lt;/strong&gt;的区域。简单地说，就是先加入最近的顶点，然后加入更远一些的顶点。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://tommyplayer-c.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="图论" scheme="https://tommyplayer-c.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Kruscal 算法</title>
    <link href="https://tommyplayer-c.github.io/2021/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-2021-08-29-Kruscal%E7%AE%97%E6%B3%95/"/>
    <id>https://tommyplayer-c.github.io/2021/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-2021-08-29-Kruscal%E7%AE%97%E6%B3%95/</id>
    <published>2021-08-29T09:44:34.000Z</published>
    <updated>2021-10-05T06:48:21.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kruscal-算法（C-）"><a href="#Kruscal-算法（C-）" class="headerlink" title="Kruscal 算法（C++）"></a>Kruscal 算法（C++）</h2><h3 id="1-Kruscal-算法简介"><a href="#1-Kruscal-算法简介" class="headerlink" title="1. Kruscal 算法简介"></a>1. Kruscal 算法简介</h3><p>Kruscal 最小生成树算法起始于一个空的图，并按照以下规则从边集中选择边。</p><blockquote><p>不断重复地选择未被选中的边中<strong>权重最轻</strong>且<strong>不会形成环</strong>的一条。</p></blockquote><p>Kruscal 算法通过逐条增加边来构造最小生成树。在保证不出现环的同时，它总简单地选择当前所余的权重最轻的边。<strong>这是一个典型的贪心算法，即每次决策都对应于最明显的即时利益。</strong></p><span id="more"></span><p>下面是《算法概论》一书中给出的伪代码。</p><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/20210830221137.png" alt="image-20210520212843524"></p><h3 id="2-代码部分"><a href="#2-代码部分" class="headerlink" title="2. 代码部分"></a>2. 代码部分</h3><p>下面将伪代码改写成 C++ 程序。</p><ol><li><p>确定图的表示方式</p><p>这里我选择建立一个结构体表示边的信息，u、v、w 分别表示边的 2 个端点和边权。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">&#125;;</span><br><span class="line">Edge graph[MAXN];</span><br></pre></td></tr></table></figure></li><li><p>编写 _find 和 _union</p><p>有两种方法，分别是<strong>基于等级的合并</strong>和<strong>路径压缩</strong>，这里先把它看做黑箱，接下来再详细阐述。</p><p>但这两种方法都要使用 Rank 数组，下面先给出一些要用到的全局变量以及初始化 Rank 的 makeset 函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m;   <span class="comment">// n个结点，m条无向边</span></span><br><span class="line"><span class="keyword">int</span> parent[MAXN], Rank[MAXN];<span class="comment">// 基于等级的合并</span></span><br><span class="line"><span class="keyword">int</span> min_weight = <span class="number">0</span>;      <span class="comment">// 最小生成树的权值</span></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;            <span class="comment">// 统计最小生成树的边数，判断是否连通</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeset</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    parent[x] = x;</span><br><span class="line">    Rank[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Kruscal 核心代码——参照伪代码写出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">makeset</span>(i); <span class="comment">// 初始化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(graph, graph + m, [](<span class="keyword">const</span> Edge &amp;a, <span class="keyword">const</span> Edge &amp;b) -&gt; <span class="keyword">bool</span></span><br><span class="line">         &#123; <span class="keyword">return</span> a.w &lt; b.w; &#125;);<span class="comment">// 这里使用C++11的lambda，也可以写一个cmp函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = _find(graph[i].u), y = _find(graph[i].v);</span><br><span class="line">        <span class="keyword">if</span> (x != y) <span class="comment">// 第i条边的两个端点u、v属于不同集合</span></span><br><span class="line">        &#123;</span><br><span class="line">            min_weight += graph[i].w;</span><br><span class="line">            _union(x, y);</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//if (cnt == n-1) break;    // 选了n-1条边就结束了，也可以不加，因为剩下的边的顶点肯</span></span><br><span class="line">        <span class="comment">// 定都在最小生成树内了，接下来的循环中if总是判断为假。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-并查集的编写方式"><a href="#3-并查集的编写方式" class="headerlink" title="3. 并查集的编写方式"></a>3. 并查集的编写方式</h3><h4 id="3-1-基于等级的合并"><a href="#3-1-基于等级的合并" class="headerlink" title="3.1 基于等级的合并"></a>3.1 基于等级的合并</h4><p>存储集合的方法之一是采用<strong>有向树</strong>，树的结点对应集合中的元素，每个结点都包含一个父指针（使用parent数组实现）。父指针使得结点一级级相连并最终指向树的根，<strong>我们用树根元素来代表整个集合</strong>。</p><p>与其他元素不同，树根的父指针指向该元素自身，所以我们使用 makeset 初始化时将每个元素的 parent 初始化为自身。对于节点的等级信息，我们将其解释为<strong>其下悬挂的子树的高度</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeset</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    parent[x] = x;</span><br><span class="line">    Rank[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>find 函数的实现很简单，只需要沿着节点的父指针找到树的根。**_find 的执行时间和树的高度成正比**。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> _find(<span class="keyword">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (x != parent[x])</span><br><span class="line">        x = parent[x];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合并两个树（集合）的过程也很简单，只需要将一个树的根（的父指针）指向另一个树的根。由于树的高度影响计算效率，我们应该尽可能使树的高度小一点。因此，我们选择让较低的树的根指向较高的树的根，这样一来，除非将要合并的树等高，否则不会使合并后的树总高度增加。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _union(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> rx = _find(x);</span><br><span class="line">    <span class="keyword">int</span> ry = _find(y);</span><br><span class="line">    <span class="keyword">if</span> (rx == ry)</span><br><span class="line">        <span class="keyword">return</span>;             <span class="comment">// x和y的根相同，已经在同一个集合中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Rank[rx] &gt; Rank[ry])</span><br><span class="line">    &#123;</span><br><span class="line">        parent[ry] = rx;    <span class="comment">// 让较低的树根指向较高的树根</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        parent[rx] = ry;</span><br><span class="line">        <span class="keyword">if</span> (Rank[rx] == Rank[ry])<span class="comment">// 两个树等高的情形</span></span><br><span class="line">            ++Rank[ry];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是合并的具体过程。</p><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/20210830221145.png" alt="image-20210521105630889"></p><h4 id="3-2-路径压缩"><a href="#3-2-路径压缩" class="headerlink" title="3.2 路径压缩"></a>3.2 路径压缩</h4><p>由上文易知，find 操作的时间复杂度为 O(logh)，h 为树高，采用路径压缩可以将总的代价分摊，由 O(logh) 下降到略微超过 O(1)。在每次 find 操作中，当沿着一系列的父指针找到树根后，我们可将这些父指针<strong>直接指向树根</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> _find(<span class="keyword">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (x != parent[x]) parent[x] = _find(parent[x]);</span><br><span class="line"><span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h3><p>测试题目，<a href="https://www.luogu.com.cn/problem/P3366">洛谷 P3366 【模板】最小生成树</a> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;                       <span class="comment">// n个结点，m条无向边</span></span><br><span class="line"><span class="keyword">int</span> parent[MAXN], Rank[MAXN];</span><br><span class="line"><span class="keyword">int</span> min_weight = <span class="number">0</span>;             <span class="comment">// 最小生成树的权值</span></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;                    <span class="comment">// 统计最小生成树的边数，判断是否连通</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">&#125;;</span><br><span class="line">Edge graph[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeset</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    parent[x] = x;</span><br><span class="line">    Rank[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _find(<span class="keyword">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (x != parent[x])</span><br><span class="line">        x = parent[x];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _union(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> rx = _find(x);</span><br><span class="line">    <span class="keyword">int</span> ry = _find(y);</span><br><span class="line">    <span class="keyword">if</span> (rx == ry)</span><br><span class="line">        <span class="keyword">return</span>;             <span class="comment">// x和y的根相同，已经在同一个集合中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Rank[rx] &gt; Rank[ry])</span><br><span class="line">    &#123;</span><br><span class="line">        parent[ry] = rx;    <span class="comment">// 让较低的树根指向较高的树根</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        parent[rx] = ry;</span><br><span class="line">        <span class="keyword">if</span> (Rank[rx] == Rank[ry])       <span class="comment">// 两个树等高的情形</span></span><br><span class="line">            ++Rank[ry];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">makeset</span>(i); <span class="comment">// 初始化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(graph, graph + m, [](<span class="keyword">const</span> Edge &amp;a, <span class="keyword">const</span> Edge &amp;b) -&gt; <span class="keyword">bool</span></span><br><span class="line">         &#123; <span class="keyword">return</span> a.w &lt; b.w; &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = _find(graph[i].u), y = _find(graph[i].v);</span><br><span class="line">        <span class="keyword">if</span> (x != y)             <span class="comment">// 第i条边的两个端点u、v属于不同集合</span></span><br><span class="line">        &#123;</span><br><span class="line">            min_weight += graph[i].w;</span><br><span class="line">            _union(x, y);</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if (cnt == n-1) break;        // 选了n-1条边就结束了，也可以不加，因为剩下的边的顶点肯</span></span><br><span class="line">            <span class="comment">// 定都在最小生成树内了，接下来的循环中if总是判断为假</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; graph[i].u &gt;&gt; graph[i].v &gt;&gt; graph[i].w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">kruskal</span>();</span><br><span class="line">    <span class="keyword">if</span> (cnt != n - <span class="number">1</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;orz&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; min_weight &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Kruscal-算法（C-）&quot;&gt;&lt;a href=&quot;#Kruscal-算法（C-）&quot; class=&quot;headerlink&quot; title=&quot;Kruscal 算法（C++）&quot;&gt;&lt;/a&gt;Kruscal 算法（C++）&lt;/h2&gt;&lt;h3 id=&quot;1-Kruscal-算法简介&quot;&gt;&lt;a href=&quot;#1-Kruscal-算法简介&quot; class=&quot;headerlink&quot; title=&quot;1. Kruscal 算法简介&quot;&gt;&lt;/a&gt;1. Kruscal 算法简介&lt;/h3&gt;&lt;p&gt;Kruscal 最小生成树算法起始于一个空的图，并按照以下规则从边集中选择边。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不断重复地选择未被选中的边中&lt;strong&gt;权重最轻&lt;/strong&gt;且&lt;strong&gt;不会形成环&lt;/strong&gt;的一条。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Kruscal 算法通过逐条增加边来构造最小生成树。在保证不出现环的同时，它总简单地选择当前所余的权重最轻的边。&lt;strong&gt;这是一个典型的贪心算法，即每次决策都对应于最明显的即时利益。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://tommyplayer-c.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="图论" scheme="https://tommyplayer-c.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu 18.04 配置静态IP</title>
    <link href="https://tommyplayer-c.github.io/2021/08/13/Linux-ubuntu-18-04-%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/"/>
    <id>https://tommyplayer-c.github.io/2021/08/13/Linux-ubuntu-18-04-%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/</id>
    <published>2021-08-13T01:45:00.000Z</published>
    <updated>2021-10-06T12:12:00.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ubuntu-18-04-配置静态IP"><a href="#ubuntu-18-04-配置静态IP" class="headerlink" title="ubuntu 18.04 配置静态IP"></a>ubuntu 18.04 配置静态IP</h1><span id="more"></span><ol><li><p>使用命令 <code>ipconfig</code> 查看网卡名字<br><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110062011519.png"></p></li><li><p>进入目录 <code>cd /etc/netplan</code></p></li><li><p>使用 vim 修改/创建文件：<code>sudo vim 50-cloud-init.yaml</code><br> 按以下格式配置文件：</p></li></ol>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">network:</span><br><span class="line">    ethernets:</span><br><span class="line">        wlp7s0: <span class="comment">#第1步得到的网卡名称</span></span><br><span class="line">            addresses: [192.168.10.3/24]  <span class="comment">#IP地址</span></span><br><span class="line">            dhcp4: no  <span class="comment">#关闭DHCP服务，使用静态IP</span></span><br><span class="line">            dhcp6: no</span><br><span class="line">            gateway4:  192.168.10.1  <span class="comment">#网关</span></span><br><span class="line">            nameservers:</span><br><span class="line">                addresses: [192.168.10.1] <span class="comment">#DNS地址</span></span><br><span class="line">    version: 2</span><br></pre></td></tr></table></figure><ol start="4"><li>使用 <code>sudo netplan apply</code> 命令</li><li>使用 <code>service networking restart</code> 命令</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;ubuntu-18-04-配置静态IP&quot;&gt;&lt;a href=&quot;#ubuntu-18-04-配置静态IP&quot; class=&quot;headerlink&quot; title=&quot;ubuntu 18.04 配置静态IP&quot;&gt;&lt;/a&gt;ubuntu 18.04 配置静态IP&lt;/h1&gt;</summary>
    
    
    
    <category term="linux" scheme="https://tommyplayer-c.github.io/categories/linux/"/>
    
    
    <category term="linux 配置" scheme="https://tommyplayer-c.github.io/tags/linux-%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>SQL必知必会第四版——linux下创建书中用的数据表</title>
    <link href="https://tommyplayer-c.github.io/2021/08/01/%E6%95%B0%E6%8D%AE%E5%BA%93-SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%AC%AC%E5%9B%9B%E7%89%88%E2%80%94%E2%80%94linux%E4%B8%8B%E5%88%9B%E5%BB%BA%E4%B9%A6%E4%B8%AD%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A1%A8/"/>
    <id>https://tommyplayer-c.github.io/2021/08/01/%E6%95%B0%E6%8D%AE%E5%BA%93-SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%AC%AC%E5%9B%9B%E7%89%88%E2%80%94%E2%80%94linux%E4%B8%8B%E5%88%9B%E5%BB%BA%E4%B9%A6%E4%B8%AD%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A1%A8/</id>
    <published>2021-07-31T16:00:00.000Z</published>
    <updated>2021-10-06T12:11:14.332Z</updated>
    
    <content type="html"><![CDATA[<p>本人使用的是虚拟机 Centos7.6，MySQL；</p><span id="more"></span><p>步骤：</p><ol><li><p>终端下登录 mysql：<code>mysql -u root -p</code> </p></li><li><p>创建数据表（名为 crashcourse）：<code>create database crashcourse;</code></p></li><li><p>选择刚刚创建的数据库 crashcourse：<code>use crashcourse;</code></p></li><li><p>使用官方提供的脚本生成表格：<code>source /home/tom/rashcourse/create.sql</code> <code>source /home/tom/rashcourse/populate.sql</code><br>create.sql</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- -----------------------------------------</span></span><br><span class="line"><span class="comment">-- Sams Teach Yourself SQL in 10 Minutes</span></span><br><span class="line"><span class="comment">-- http://forta.com/books/0672336073/</span></span><br><span class="line"><span class="comment">-- Example table creation scripts for MySQL.</span></span><br><span class="line"><span class="comment">-- -----------------------------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------</span></span><br><span class="line"><span class="comment">-- Create Customers table</span></span><br><span class="line"><span class="comment">-- ----------------------</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Customers</span><br><span class="line">(</span><br><span class="line">  cust_id      <span class="type">char</span>(<span class="number">10</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  cust_name    <span class="type">char</span>(<span class="number">50</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  cust_address <span class="type">char</span>(<span class="number">50</span>)  <span class="keyword">NULL</span> ,</span><br><span class="line">  cust_city    <span class="type">char</span>(<span class="number">50</span>)  <span class="keyword">NULL</span> ,</span><br><span class="line">  cust_state   <span class="type">char</span>(<span class="number">5</span>)   <span class="keyword">NULL</span> ,</span><br><span class="line">  cust_zip     <span class="type">char</span>(<span class="number">10</span>)  <span class="keyword">NULL</span> ,</span><br><span class="line">  cust_country <span class="type">char</span>(<span class="number">50</span>)  <span class="keyword">NULL</span> ,</span><br><span class="line">  cust_contact <span class="type">char</span>(<span class="number">50</span>)  <span class="keyword">NULL</span> ,</span><br><span class="line">  cust_email   <span class="type">char</span>(<span class="number">255</span>) <span class="keyword">NULL</span> </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- -----------------------</span></span><br><span class="line"><span class="comment">-- Create OrderItems table</span></span><br><span class="line"><span class="comment">-- -----------------------</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> OrderItems</span><br><span class="line">(</span><br><span class="line">  order_num  <span class="type">int</span>          <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  order_item <span class="type">int</span>          <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  prod_id    <span class="type">char</span>(<span class="number">10</span>)     <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  quantity   <span class="type">int</span>          <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  item_price <span class="type">decimal</span>(<span class="number">8</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- -------------------</span></span><br><span class="line"><span class="comment">-- Create Orders table</span></span><br><span class="line"><span class="comment">-- -------------------</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders</span><br><span class="line">(</span><br><span class="line">  order_num  <span class="type">int</span>      <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  order_date datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  cust_id    <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ---------------------</span></span><br><span class="line"><span class="comment">-- Create Products table</span></span><br><span class="line"><span class="comment">-- ---------------------</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Products</span><br><span class="line">(</span><br><span class="line">  prod_id    <span class="type">char</span>(<span class="number">10</span>)      <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  vend_id    <span class="type">char</span>(<span class="number">10</span>)      <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  prod_name  <span class="type">char</span>(<span class="number">255</span>)     <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  prod_price <span class="type">decimal</span>(<span class="number">8</span>,<span class="number">2</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  prod_desc  text          <span class="keyword">NULL</span> </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- --------------------</span></span><br><span class="line"><span class="comment">-- Create Vendors table</span></span><br><span class="line"><span class="comment">-- --------------------</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Vendors</span><br><span class="line">(</span><br><span class="line">  vend_id      <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  vend_name    <span class="type">char</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  vend_address <span class="type">char</span>(<span class="number">50</span>) <span class="keyword">NULL</span> ,</span><br><span class="line">  vend_city    <span class="type">char</span>(<span class="number">50</span>) <span class="keyword">NULL</span> ,</span><br><span class="line">  vend_state   <span class="type">char</span>(<span class="number">5</span>)  <span class="keyword">NULL</span> ,</span><br><span class="line">  vend_zip     <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">NULL</span> ,</span><br><span class="line">  vend_country <span class="type">char</span>(<span class="number">50</span>) <span class="keyword">NULL</span> </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- -------------------</span></span><br><span class="line"><span class="comment">-- Define primary keys</span></span><br><span class="line"><span class="comment">-- -------------------</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Customers <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY (cust_id);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> OrderItems <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY (order_num, order_item);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Orders <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY (order_num);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Products <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY (prod_id);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Vendors <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY (vend_id);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- -------------------</span></span><br><span class="line"><span class="comment">-- Define foreign keys</span></span><br><span class="line"><span class="comment">-- -------------------</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> OrderItems <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> FK_OrderItems_Orders <span class="keyword">FOREIGN</span> KEY (order_num) <span class="keyword">REFERENCES</span> Orders (order_num);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> OrderItems <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> FK_OrderItems_Products <span class="keyword">FOREIGN</span> KEY (prod_id) <span class="keyword">REFERENCES</span> Products (prod_id);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Orders <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> FK_Orders_Customers <span class="keyword">FOREIGN</span> KEY (cust_id) <span class="keyword">REFERENCES</span> Customers (cust_id);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Products <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> FK_Products_Vendors <span class="keyword">FOREIGN</span> KEY (vend_id) <span class="keyword">REFERENCES</span> Vendors (vend_id);</span><br></pre></td></tr></table></figure><p>populate.sql</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- -------------------------------------------</span></span><br><span class="line"><span class="comment">-- Sams Teach Yourself SQL in 10 Minutes</span></span><br><span class="line"><span class="comment">-- http://forta.com/books/0672336073/</span></span><br><span class="line"><span class="comment">-- Example table population scripts for MySQL.</span></span><br><span class="line"><span class="comment">-- -------------------------------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- ------------------------</span></span><br><span class="line"><span class="comment">-- Populate Customers table</span></span><br><span class="line"><span class="comment">-- ------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Customers(cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;1000000001&#x27;</span>, <span class="string">&#x27;Village Toys&#x27;</span>, <span class="string">&#x27;200 Maple Lane&#x27;</span>, <span class="string">&#x27;Detroit&#x27;</span>, <span class="string">&#x27;MI&#x27;</span>, <span class="string">&#x27;44444&#x27;</span>, <span class="string">&#x27;USA&#x27;</span>, <span class="string">&#x27;John Smith&#x27;</span>, <span class="string">&#x27;sales@villagetoys.com&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Customers(cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;1000000002&#x27;</span>, <span class="string">&#x27;Kids Place&#x27;</span>, <span class="string">&#x27;333 South Lake Drive&#x27;</span>, <span class="string">&#x27;Columbus&#x27;</span>, <span class="string">&#x27;OH&#x27;</span>, <span class="string">&#x27;43333&#x27;</span>, <span class="string">&#x27;USA&#x27;</span>, <span class="string">&#x27;Michelle Green&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Customers(cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;1000000003&#x27;</span>, <span class="string">&#x27;Fun4All&#x27;</span>, <span class="string">&#x27;1 Sunny Place&#x27;</span>, <span class="string">&#x27;Muncie&#x27;</span>, <span class="string">&#x27;IN&#x27;</span>, <span class="string">&#x27;42222&#x27;</span>, <span class="string">&#x27;USA&#x27;</span>, <span class="string">&#x27;Jim Jones&#x27;</span>, <span class="string">&#x27;jjones@fun4all.com&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Customers(cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;1000000004&#x27;</span>, <span class="string">&#x27;Fun4All&#x27;</span>, <span class="string">&#x27;829 Riverside Drive&#x27;</span>, <span class="string">&#x27;Phoenix&#x27;</span>, <span class="string">&#x27;AZ&#x27;</span>, <span class="string">&#x27;88888&#x27;</span>, <span class="string">&#x27;USA&#x27;</span>, <span class="string">&#x27;Denise L. Stephens&#x27;</span>, <span class="string">&#x27;dstephens@fun4all.com&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Customers(cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;1000000005&#x27;</span>, <span class="string">&#x27;The Toy Store&#x27;</span>, <span class="string">&#x27;4545 53rd Street&#x27;</span>, <span class="string">&#x27;Chicago&#x27;</span>, <span class="string">&#x27;IL&#x27;</span>, <span class="string">&#x27;54545&#x27;</span>, <span class="string">&#x27;USA&#x27;</span>, <span class="string">&#x27;Kim Howard&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------</span></span><br><span class="line"><span class="comment">-- Populate Vendors table</span></span><br><span class="line"><span class="comment">-- ----------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Vendors(vend_id, vend_name, vend_address, vend_city, vend_state, vend_zip, vend_country)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;BRS01&#x27;</span>,<span class="string">&#x27;Bears R Us&#x27;</span>,<span class="string">&#x27;123 Main Street&#x27;</span>,<span class="string">&#x27;Bear Town&#x27;</span>,<span class="string">&#x27;MI&#x27;</span>,<span class="string">&#x27;44444&#x27;</span>, <span class="string">&#x27;USA&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Vendors(vend_id, vend_name, vend_address, vend_city, vend_state, vend_zip, vend_country)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;BRE02&#x27;</span>,<span class="string">&#x27;Bear Emporium&#x27;</span>,<span class="string">&#x27;500 Park Street&#x27;</span>,<span class="string">&#x27;Anytown&#x27;</span>,<span class="string">&#x27;OH&#x27;</span>,<span class="string">&#x27;44333&#x27;</span>, <span class="string">&#x27;USA&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Vendors(vend_id, vend_name, vend_address, vend_city, vend_state, vend_zip, vend_country)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;DLL01&#x27;</span>,<span class="string">&#x27;Doll House Inc.&#x27;</span>,<span class="string">&#x27;555 High Street&#x27;</span>,<span class="string">&#x27;Dollsville&#x27;</span>,<span class="string">&#x27;CA&#x27;</span>,<span class="string">&#x27;99999&#x27;</span>, <span class="string">&#x27;USA&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Vendors(vend_id, vend_name, vend_address, vend_city, vend_state, vend_zip, vend_country)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;FRB01&#x27;</span>,<span class="string">&#x27;Furball Inc.&#x27;</span>,<span class="string">&#x27;1000 5th Avenue&#x27;</span>,<span class="string">&#x27;New York&#x27;</span>,<span class="string">&#x27;NY&#x27;</span>,<span class="string">&#x27;11111&#x27;</span>, <span class="string">&#x27;USA&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Vendors(vend_id, vend_name, vend_address, vend_city, vend_state, vend_zip, vend_country)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;FNG01&#x27;</span>,<span class="string">&#x27;Fun and Games&#x27;</span>,<span class="string">&#x27;42 Galaxy Road&#x27;</span>,<span class="string">&#x27;London&#x27;</span>, <span class="keyword">NULL</span>,<span class="string">&#x27;N16 6PS&#x27;</span>, <span class="string">&#x27;England&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Vendors(vend_id, vend_name, vend_address, vend_city, vend_state, vend_zip, vend_country)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;JTS01&#x27;</span>,<span class="string">&#x27;Jouets et ours&#x27;</span>,<span class="string">&#x27;1 Rue Amusement&#x27;</span>,<span class="string">&#x27;Paris&#x27;</span>, <span class="keyword">NULL</span>,<span class="string">&#x27;45678&#x27;</span>, <span class="string">&#x27;France&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- -----------------------</span></span><br><span class="line"><span class="comment">-- Populate Products table</span></span><br><span class="line"><span class="comment">-- -----------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Products(prod_id, vend_id, prod_name, prod_price, prod_desc)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;BR01&#x27;</span>, <span class="string">&#x27;BRS01&#x27;</span>, <span class="string">&#x27;8 inch teddy bear&#x27;</span>, <span class="number">5.99</span>, <span class="string">&#x27;8 inch teddy bear, comes with cap and jacket&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Products(prod_id, vend_id, prod_name, prod_price, prod_desc)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;BR02&#x27;</span>, <span class="string">&#x27;BRS01&#x27;</span>, <span class="string">&#x27;12 inch teddy bear&#x27;</span>, <span class="number">8.99</span>, <span class="string">&#x27;12 inch teddy bear, comes with cap and jacket&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Products(prod_id, vend_id, prod_name, prod_price, prod_desc)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;BR03&#x27;</span>, <span class="string">&#x27;BRS01&#x27;</span>, <span class="string">&#x27;18 inch teddy bear&#x27;</span>, <span class="number">11.99</span>, <span class="string">&#x27;18 inch teddy bear, comes with cap and jacket&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Products(prod_id, vend_id, prod_name, prod_price, prod_desc)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;BNBG01&#x27;</span>, <span class="string">&#x27;DLL01&#x27;</span>, <span class="string">&#x27;Fish bean bag toy&#x27;</span>, <span class="number">3.49</span>, <span class="string">&#x27;Fish bean bag toy, complete with bean bag worms with which to feed it&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Products(prod_id, vend_id, prod_name, prod_price, prod_desc)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;BNBG02&#x27;</span>, <span class="string">&#x27;DLL01&#x27;</span>, <span class="string">&#x27;Bird bean bag toy&#x27;</span>, <span class="number">3.49</span>, <span class="string">&#x27;Bird bean bag toy, eggs are not included&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Products(prod_id, vend_id, prod_name, prod_price, prod_desc)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;BNBG03&#x27;</span>, <span class="string">&#x27;DLL01&#x27;</span>, <span class="string">&#x27;Rabbit bean bag toy&#x27;</span>, <span class="number">3.49</span>, <span class="string">&#x27;Rabbit bean bag toy, comes with bean bag carrots&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Products(prod_id, vend_id, prod_name, prod_price, prod_desc)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;RGAN01&#x27;</span>, <span class="string">&#x27;DLL01&#x27;</span>, <span class="string">&#x27;Raggedy Ann&#x27;</span>, <span class="number">4.99</span>, <span class="string">&#x27;18 inch Raggedy Ann doll&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Products(prod_id, vend_id, prod_name, prod_price, prod_desc)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;RYL01&#x27;</span>, <span class="string">&#x27;FNG01&#x27;</span>, <span class="string">&#x27;King doll&#x27;</span>, <span class="number">9.49</span>, <span class="string">&#x27;12 inch king doll with royal garments and crown&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Products(prod_id, vend_id, prod_name, prod_price, prod_desc)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;RYL02&#x27;</span>, <span class="string">&#x27;FNG01&#x27;</span>, <span class="string">&#x27;Queen doll&#x27;</span>, <span class="number">9.49</span>, <span class="string">&#x27;12 inch queen doll with royal garments and crown&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ---------------------</span></span><br><span class="line"><span class="comment">-- Populate Orders table</span></span><br><span class="line"><span class="comment">-- ---------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Orders(order_num, order_date, cust_id)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20005</span>, <span class="string">&#x27;2012-05-01&#x27;</span>, <span class="string">&#x27;1000000001&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Orders(order_num, order_date, cust_id)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20006</span>, <span class="string">&#x27;2012-01-12&#x27;</span>, <span class="string">&#x27;1000000003&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Orders(order_num, order_date, cust_id)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20007</span>, <span class="string">&#x27;2012-01-30&#x27;</span>, <span class="string">&#x27;1000000004&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Orders(order_num, order_date, cust_id)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20008</span>, <span class="string">&#x27;2012-02-03&#x27;</span>, <span class="string">&#x27;1000000005&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Orders(order_num, order_date, cust_id)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20009</span>, <span class="string">&#x27;2012-02-08&#x27;</span>, <span class="string">&#x27;1000000001&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- -------------------------</span></span><br><span class="line"><span class="comment">-- Populate OrderItems table</span></span><br><span class="line"><span class="comment">-- -------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> OrderItems(order_num, order_item, prod_id, quantity, item_price)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20005</span>, <span class="number">1</span>, <span class="string">&#x27;BR01&#x27;</span>, <span class="number">100</span>, <span class="number">5.49</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> OrderItems(order_num, order_item, prod_id, quantity, item_price)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20005</span>, <span class="number">2</span>, <span class="string">&#x27;BR03&#x27;</span>, <span class="number">100</span>, <span class="number">10.99</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> OrderItems(order_num, order_item, prod_id, quantity, item_price)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20006</span>, <span class="number">1</span>, <span class="string">&#x27;BR01&#x27;</span>, <span class="number">20</span>, <span class="number">5.99</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> OrderItems(order_num, order_item, prod_id, quantity, item_price)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20006</span>, <span class="number">2</span>, <span class="string">&#x27;BR02&#x27;</span>, <span class="number">10</span>, <span class="number">8.99</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> OrderItems(order_num, order_item, prod_id, quantity, item_price)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20006</span>, <span class="number">3</span>, <span class="string">&#x27;BR03&#x27;</span>, <span class="number">10</span>, <span class="number">11.99</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> OrderItems(order_num, order_item, prod_id, quantity, item_price)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20007</span>, <span class="number">1</span>, <span class="string">&#x27;BR03&#x27;</span>, <span class="number">50</span>, <span class="number">11.49</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> OrderItems(order_num, order_item, prod_id, quantity, item_price)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20007</span>, <span class="number">2</span>, <span class="string">&#x27;BNBG01&#x27;</span>, <span class="number">100</span>, <span class="number">2.99</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> OrderItems(order_num, order_item, prod_id, quantity, item_price)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20007</span>, <span class="number">3</span>, <span class="string">&#x27;BNBG02&#x27;</span>, <span class="number">100</span>, <span class="number">2.99</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> OrderItems(order_num, order_item, prod_id, quantity, item_price)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20007</span>, <span class="number">4</span>, <span class="string">&#x27;BNBG03&#x27;</span>, <span class="number">100</span>, <span class="number">2.99</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> OrderItems(order_num, order_item, prod_id, quantity, item_price)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20007</span>, <span class="number">5</span>, <span class="string">&#x27;RGAN01&#x27;</span>, <span class="number">50</span>, <span class="number">4.49</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> OrderItems(order_num, order_item, prod_id, quantity, item_price)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20008</span>, <span class="number">1</span>, <span class="string">&#x27;RGAN01&#x27;</span>, <span class="number">5</span>, <span class="number">4.99</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> OrderItems(order_num, order_item, prod_id, quantity, item_price)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20008</span>, <span class="number">2</span>, <span class="string">&#x27;BR03&#x27;</span>, <span class="number">5</span>, <span class="number">11.99</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> OrderItems(order_num, order_item, prod_id, quantity, item_price)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20008</span>, <span class="number">3</span>, <span class="string">&#x27;BNBG01&#x27;</span>, <span class="number">10</span>, <span class="number">3.49</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> OrderItems(order_num, order_item, prod_id, quantity, item_price)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20008</span>, <span class="number">4</span>, <span class="string">&#x27;BNBG02&#x27;</span>, <span class="number">10</span>, <span class="number">3.49</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> OrderItems(order_num, order_item, prod_id, quantity, item_price)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20008</span>, <span class="number">5</span>, <span class="string">&#x27;BNBG03&#x27;</span>, <span class="number">10</span>, <span class="number">3.49</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> OrderItems(order_num, order_item, prod_id, quantity, item_price)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20009</span>, <span class="number">1</span>, <span class="string">&#x27;BNBG01&#x27;</span>, <span class="number">250</span>, <span class="number">2.49</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> OrderItems(order_num, order_item, prod_id, quantity, item_price)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20009</span>, <span class="number">2</span>, <span class="string">&#x27;BNBG02&#x27;</span>, <span class="number">250</span>, <span class="number">2.49</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> OrderItems(order_num, order_item, prod_id, quantity, item_price)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20009</span>, <span class="number">3</span>, <span class="string">&#x27;BNBG03&#x27;</span>, <span class="number">250</span>, <span class="number">2.49</span>);</span><br></pre></td></tr></table></figure></li></ol><p>注意，这两个文件最好在 linux 下创建，并且编码必须为 UTF-8。如果不是 UTF-8，使用 more 查看该文件时会乱码，并且这一步操作会失败（本人折腾了一个晚上也找不出原因）。</p><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110062011034.png"></p><p>最后发现是 windows 下载的 create.sql 编码格式是 UTF-16！在 vscode 中转为 UTF-8 就可以正常生成数据库的数据了。</p><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110062011608.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本人使用的是虚拟机 Centos7.6，MySQL；&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="https://tommyplayer-c.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://tommyplayer-c.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Vscode ssh 连接失败：Resolver error</title>
    <link href="https://tommyplayer-c.github.io/2021/07/29/Vscode-ssh-%E8%BF%9E%E6%8E%A5%E5%A4%B1%E8%B4%A5%EF%BC%9AResolver-error-Error-Connecting-was-canceled-at-Function-Canceled/"/>
    <id>https://tommyplayer-c.github.io/2021/07/29/Vscode-ssh-%E8%BF%9E%E6%8E%A5%E5%A4%B1%E8%B4%A5%EF%BC%9AResolver-error-Error-Connecting-was-canceled-at-Function-Canceled/</id>
    <published>2021-07-28T16:00:00.000Z</published>
    <updated>2021-10-06T12:15:05.173Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vscode-ssh-连接失败：Resolver-error-Error-Connecting-was-canceled-at-Function-Canceled"><a href="#Vscode-ssh-连接失败：Resolver-error-Error-Connecting-was-canceled-at-Function-Canceled" class="headerlink" title="Vscode ssh 连接失败：Resolver error: Error: Connecting was canceled at Function.Canceled"></a>Vscode ssh 连接失败：Resolver error: Error: Connecting was canceled at Function.Canceled</h1><span id="more"></span><p>由于之前 ssh 连接的电脑没有设置静态 IP，导致连接时选择的系统不匹配（有些是 windows，有些是 linux），可以在设置的 json 文件里修改。<br><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110062011596.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Vscode-ssh-连接失败：Resolver-error-Error-Connecting-was-canceled-at-Function-Canceled&quot;&gt;&lt;a href=&quot;#Vscode-ssh-连接失败：Resolver-error-Error-Connecting-was-canceled-at-Function-Canceled&quot; class=&quot;headerlink&quot; title=&quot;Vscode ssh 连接失败：Resolver error: Error: Connecting was canceled at Function.Canceled&quot;&gt;&lt;/a&gt;Vscode ssh 连接失败：Resolver error: Error: Connecting was canceled at Function.Canceled&lt;/h1&gt;</summary>
    
    
    
    <category term="Vscode" scheme="https://tommyplayer-c.github.io/categories/Vscode/"/>
    
    
  </entry>
  
  <entry>
    <title>Effective STL 笔记-第6章 函数子、函数子类、函数及其他</title>
    <link href="https://tommyplayer-c.github.io/2021/07/20/Effective-STL-6-%E5%87%BD%E6%95%B0%E5%AD%90%E3%80%81%E5%87%BD%E6%95%B0%E5%AD%90%E7%B1%BB%E3%80%81%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E4%BB%96/"/>
    <id>https://tommyplayer-c.github.io/2021/07/20/Effective-STL-6-%E5%87%BD%E6%95%B0%E5%AD%90%E3%80%81%E5%87%BD%E6%95%B0%E5%AD%90%E7%B1%BB%E3%80%81%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E4%BB%96/</id>
    <published>2021-07-19T16:00:00.000Z</published>
    <updated>2021-10-06T08:26:38.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-函数子、函数子类、函数及其他"><a href="#6-函数子、函数子类、函数及其他" class="headerlink" title="6 函数子、函数子类、函数及其他"></a>6 函数子、函数子类、函数及其他</h1><span id="more"></span><h2 id="第-38-条：遵循按值传递的原则来设计函数子类。"><a href="#第-38-条：遵循按值传递的原则来设计函数子类。" class="headerlink" title="第 38 条：遵循按值传递的原则来设计函数子类。"></a>第 38 条：遵循按值传递的原则来设计函数子类。</h2><p>函数指针是按值传递的。</p><p>函数对象往往按值传递和返回。所以，编写的函数对象必须尽可能地<strong>小巧</strong>，否则复制的开销大；函数对象必须是<strong>单态</strong>的（不是多态），不得使用虚函数。</p><p>如果你希望创建一个包含大量数据并且使用了多态性的函数子类，该怎么办呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BPFC</span>:</span><span class="comment">//BPFC = Big Polymorphic</span></span><br><span class="line"><span class="keyword">public</span><span class="comment">// Functor Class</span></span><br><span class="line">        unary_function&lt;T, <span class="keyword">void</span>&gt; &#123;</span><br><span class="line">      </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Widget w;<span class="comment">// 包含大量数据，按值传递效率低</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; val)</span> cosnt</span>;<span class="comment">// 虚函数存在剥离问题        </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么你应该创建一个小巧、单态的类，其中包含一个指针，指向另一个实现类，并且将所有的数据和虚函数都放在实现类中（“Pimpl Idiom”）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BPFCImpl</span>:</span></span><br><span class="line"><span class="keyword">public</span> unary_function&lt;T, <span class="keyword">void</span>&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Widget w;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">BPFCImpl</span>();</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; val)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">BPFC</span>&lt;</span>T&gt;;<span class="comment">// 允许BPFC访问内部数据。        </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BPFC</span>:</span><span class="comment">// 新的BPFC类：短小、单态</span></span><br><span class="line"><span class="keyword">public</span> unary_function&lt;T, <span class="keyword">void</span>&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">BPFCImpl&lt;T&gt; *pImpl;<span class="comment">// BPFC唯一的数据成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; val)</span> <span class="keyword">const</span><span class="comment">// 现在这是一个非虚函数，将调用转到BPFCImpl中</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pImpl-&gt;<span class="built_in"><span class="keyword">operator</span></span>()(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第-39-条：确保判别式是-“纯函数”。"><a href="#第-39-条：确保判别式是-“纯函数”。" class="headerlink" title="第 39 条：确保判别式是 “纯函数”。"></a>第 39 条：确保判别式是 “纯函数”。</h2><p>判别式（predicate）：一个返回值为 bool 类型的函数。</p><p>纯函数：指返回值<strong>仅仅依赖于其参数</strong>的函数。</p><p>判别式类（predicate class）：一个函数子类，它的 operator() 函数是一个判别式（返回 true 或 false）。</p><p>STL 中凡是可以接受一个判别式类对象的地方，也就可以接受一个判别式函数。</p><p>判别式应该是一个纯函数，而纯函数应该没有<strong>状态</strong>。</p><h2 id="第-40-条：若一个类是函数子，则应使它可配接。"><a href="#第-40-条：若一个类是函数子，则应使它可配接。" class="headerlink" title="第 40 条：若一个类是函数子，则应使它可配接。"></a>第 40 条：若一个类是函数子，则应使它可配接。</h2><p>对函数指针，要先应用 ptr_fun 之后再应用 not1 之后才可以工作。</p><p>4 个标准的函数配接器（not1、not2、bind1st、bind2nd）都要求一些特殊的类型定义，提供这些必要类型定义（argument_type、first_argument_type、second_argument_type、result_type）的函数对象被称为可配接（adaptable）的函数对象。</p><p>提供这些类型定义最简单的方法：让函数子从一个基结构继承。</p><ul><li>对于 unary_function，必须指定函数子类 operator() 所带的参数类型，以及 operator() 返回类型。</li><li>对于 binary_function，必须指定 3 个类型：operator() 第一个和第二个参数类型，以及 operator() 返回类型。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MeetsThreshold</span>:</span> <span class="keyword">public</span> std::unary_function&lt;Widget, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> T threshold;<span class="comment">// 包含状态信息，使用类封装。</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MeetsThreshold</span>(<span class="keyword">const</span> T&amp; threshold);</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Widget&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WidgetNameCompare</span>:</span><span class="comment">// STL中所有无状态函数子类一般都被定义成结构。</span></span><br><span class="line"><span class="keyword">public</span> std::binary_function&lt;Widget, Widget, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Widget&amp; lhs, <span class="keyword">const</span> Widget&amp; rhs)</span> <span class="keyword">const</span></span>;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，一般情况下，传递给 binary_function 或 unary_function 的非指针类型需要去掉 const 和应用（&amp;）部分。</p><h2 id="第-41-条：理解-ptr-fun、mem-fun-和-mem-fun-ref-的来由。"><a href="#第-41-条：理解-ptr-fun、mem-fun-和-mem-fun-ref-的来由。" class="headerlink" title="第 41 条：理解 ptr_fun、mem_fun 和 mem_fun_ref 的来由。"></a>第 41 条：理解 ptr_fun、mem_fun 和 mem_fun_ref 的来由。</h2><p>STL语法惯例：函数或者函数对象被调用时，总是使用非成员函数的语法形式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for_each(vw.<span class="built_in">begin</span>(), vw.<span class="built_in">end</span>(), test);<span class="comment">// 调用1：f(x)，f为非成员函数</span></span><br><span class="line">for_each(vw.<span class="built_in">begin</span>(), vw.<span class="built_in">end</span>(), &amp;Widget::test);<span class="comment">// 调用2：x.f()，f为成员函数</span></span><br><span class="line"><span class="comment">// x是一个对象或对象的引用</span></span><br><span class="line">list&lt;Widget *&gt; lpw;</span><br><span class="line">for_each(lpw.<span class="built_in">begin</span>(), lpw.<span class="built_in">end</span>(), &amp;Widgettest);<span class="comment">// 调用3：p-&gt;f()，f为成员函数</span></span><br><span class="line"><span class="comment">// p是一个指向对象x的指针。</span></span><br></pre></td></tr></table></figure><p>mem_fun、mem_fun_t：mem_fun 将语法 3 调整为语法 1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> C&gt;<span class="comment">//该mem_fun声明针对不带参数的非const成员函数</span></span><br><span class="line"><span class="keyword">mem_fun_t</span>&lt;R,C&gt;<span class="comment">//C是类，R是所指向的成员函数返回的类型。</span></span><br><span class="line"><span class="built_in">mem_fun</span>(<span class="built_in">R</span>(C::*pmf));</span><br></pre></td></tr></table></figure><p>mem_fun 带一个指向某个成员函数的指针参数 pmf，并且返回一个 mem_fun_t 类型的对象。</p><p>mem_fun_t 是一个函数子类，它拥有该成员函数的指针，并提供了 operator() 函数，在 operator() 中调用了通过参数传递进来的对象上的该成员函数。</p><p>类似地，mem_fun_ref 将语法 2 调整为语法 1。</p><h2 id="第-42-条：确保-less-lt-T-gt-于-operator-lt-具有相同的语义。"><a href="#第-42-条：确保-less-lt-T-gt-于-operator-lt-具有相同的语义。" class="headerlink" title="第 42 条：确保 less&lt;T&gt; 于 operator&lt; 具有相同的语义。"></a>第 42 条：确保 <code>less&lt;T&gt;</code> 于 operator&lt; 具有相同的语义。</h2><p>尽量避免修改 less 的行为，可能会误导其他程序员。</p><p>如果你使用了 less，无论是显式地还是隐式地，都需要确保它于 operator&lt; 具有相同的意义。</p><p>如果你希望以一种特殊的方式来排列对象，那么最好创建一个<strong>特殊的函数子类</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;6-函数子、函数子类、函数及其他&quot;&gt;&lt;a href=&quot;#6-函数子、函数子类、函数及其他&quot; class=&quot;headerlink&quot; title=&quot;6 函数子、函数子类、函数及其他&quot;&gt;&lt;/a&gt;6 函数子、函数子类、函数及其他&lt;/h1&gt;</summary>
    
    
    
    <category term="C++" scheme="https://tommyplayer-c.github.io/categories/C/"/>
    
    
    <category term="STL" scheme="https://tommyplayer-c.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>Effective STL 笔记-第7章 在程序中使用STL</title>
    <link href="https://tommyplayer-c.github.io/2021/07/20/Effective-STL-7-%E5%9C%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E4%BD%BF%E7%94%A8STL/"/>
    <id>https://tommyplayer-c.github.io/2021/07/20/Effective-STL-7-%E5%9C%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E4%BD%BF%E7%94%A8STL/</id>
    <published>2021-07-19T16:00:00.000Z</published>
    <updated>2021-10-06T08:26:43.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7-在程序中使用STL"><a href="#7-在程序中使用STL" class="headerlink" title="7 在程序中使用STL"></a>7 在程序中使用STL</h1><span id="more"></span><h2 id="第-43-条：算法调用优先于手写的循环。"><a href="#第-43-条：算法调用优先于手写的循环。" class="headerlink" title="第 43 条：算法调用优先于手写的循环。"></a>第 43 条：算法调用优先于手写的循环。</h2><p>调用算法优于手写循环：</p><ul><li>效率：算法比手写的循环效率更高。</li><li>正确性：手写循环比使用算法容易出错。</li><li>可维护性：使用算法的代码更加简洁明了。</li></ul><p>例子：P155，</p><p>算法的名称表明了它的功能，而 for、while、do 循环不能。</p><p>手写循环需要维护迭代器的有效性。</p><h2 id="第-44-条：容器的成员函数优先于同名的算法。"><a href="#第-44-条：容器的成员函数优先于同名的算法。" class="headerlink" title="第 44 条：容器的成员函数优先于同名的算法。"></a>第 44 条：容器的成员函数优先于同名的算法。</h2><p>原因：</p><ol><li>成员函数往往速度快。</li><li>成员函数通常与容器结合得更加紧密。（同样的名称做不同的事情）</li></ol><p>对于 map 和 multimap 而言</p><ol><li>成员函数可以获得对数时间的性能。</li><li>成员函数的相同是等价，而算法是相等。</li><li>它们的成员函数只统计检查每个 pair 对象的键部分。而算法同时检查键和值/(key,value)对。</li></ol><p>对于 list 而言，list 成员函数只是简单地维护指针，可以提供更好的性能。list 的 remove、remove_if、unqiue 则实实在在的删除了元素。sort 算法不能直接应用于 list，因为 sort 需要随机访问迭代器，而 list 的迭代器是双向迭代器。</p><h2 id="第-45-条：正确区分-count、find、binary-search、lower-bound、upper-bound-和-equal-range。"><a href="#第-45-条：正确区分-count、find、binary-search、lower-bound、upper-bound-和-equal-range。" class="headerlink" title="第 45 条：正确区分 count、find、binary_search、lower_bound、upper_bound 和 equal_range。"></a>第 45 条：正确区分 count、find、binary_search、lower_bound、upper_bound 和 equal_range。</h2><p>存在性测试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">count</span>(lw.<span class="built_in">begin</span>(), lw.<span class="built_in">end</span>(), w) != <span class="number">0</span>) ...</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">find</span>(lw.<span class="built_in">begin</span>(), lw.<span class="built_in">end</span>(), w) != lw.<span class="built_in">end</span>()) ...    </span><br></pre></td></tr></table></figure><p>equal_range 返回一个迭代器，第一个迭代器等于 lower_bound 返回的迭代器，第二个迭代器等于 upper_bound 返回的迭代器。它可以同时完成 find 的工作和 count 的工作。</p><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110061620798.png" alt="image-20210802211107256"></p><h2 id="第-46-条：考虑使用函数对象而不是函数作为-STL-算法的参数。"><a href="#第-46-条：考虑使用函数对象而不是函数作为-STL-算法的参数。" class="headerlink" title="第 46 条：考虑使用函数对象而不是函数作为 STL 算法的参数。"></a>第 46 条：考虑使用函数对象而不是函数作为 STL 算法的参数。</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), doubleGreater);</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), greater&lt;<span class="keyword">double</span>&gt;());</span><br></pre></td></tr></table></figure><p>使用 <code>greater&lt;double&gt;()</code> 的 sort 调用比使用 doubleGreater 的 sort 调用快得多。原因：函数内联，sort 不包含函数调用。</p><p>抽象性利益：C++ 的 sort 算法性能总是优于 C 的 qsort。在运行时，sort 算法以内联方式调用它的比较函数，而 qsort 则通过函数指针调用它的比较函数。</p><p>使用函数对象，可以让你的程序正确地通过编译，避免语言本身的缺陷。</p><h2 id="第-47-条：避免产生-“直写型”-（write-only）的代码。"><a href="#第-47-条：避免产生-“直写型”-（write-only）的代码。" class="headerlink" title="第 47 条：避免产生 “直写型” （write only）的代码。"></a>第 47 条：避免产生 “直写型” （write only）的代码。</h2><p>直写型代码：虽然很容易编写，但是难以阅读和理解。</p><h2 id="第-48-条：总是包含（-include）正确的头文件。"><a href="#第-48-条：总是包含（-include）正确的头文件。" class="headerlink" title="第 48 条：总是包含（#include）正确的头文件。"></a>第 48 条：总是包含（#include）正确的头文件。</h2><ul><li>几乎所有的标准 STL 容器都被声明在与之同名的头文件中。set 和 map 是个例外，<set> 声明了 set 和 multiset，<map> 声明了 map 和 multimap。</li><li>除了 4 个 STL 算法以外，其他所有的算法都被声明在 <algorithm> 中。这 4 个算法是 accumulate、inner_product、adjacent_difference、partial_sum，它们被声明在 <numeric> 中。</li><li>特殊类型的迭代器，包括 istream_interator、istreambuf_interator，被声明在 <iterator> 中。</li><li>标准的函数子和函数子配接器被声明在头文件 <functional> 中。</li></ul><h2 id="第-49-条：学会分析与-STL-相关的编译器诊断信息。"><a href="#第-49-条：学会分析与-STL-相关的编译器诊断信息。" class="headerlink" title="第 49 条：学会分析与 STL 相关的编译器诊断信息。"></a>第 49 条：学会分析与 STL 相关的编译器诊断信息。</h2><h2 id="第-50-条：熟悉与-STL-相关的-web-站点。"><a href="#第-50-条：熟悉与-STL-相关的-web-站点。" class="headerlink" title="第 50 条：熟悉与 STL 相关的 web 站点。"></a>第 50 条：熟悉与 STL 相关的 web 站点。</h2><p><a href="http://www.sgi.com/tech/stl">SGI STL 站点</a></p><p><a href="http://www.stlport.org/">STLport 站点</a></p><p><a href="http://www.boost.org/">Boost 站点</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;7-在程序中使用STL&quot;&gt;&lt;a href=&quot;#7-在程序中使用STL&quot; class=&quot;headerlink&quot; title=&quot;7 在程序中使用STL&quot;&gt;&lt;/a&gt;7 在程序中使用STL&lt;/h1&gt;</summary>
    
    
    
    <category term="C++" scheme="https://tommyplayer-c.github.io/categories/C/"/>
    
    
    <category term="STL" scheme="https://tommyplayer-c.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>Effective STL 笔记-第5章 算法</title>
    <link href="https://tommyplayer-c.github.io/2021/07/19/Effective-STL-5-%E7%AE%97%E6%B3%95/"/>
    <id>https://tommyplayer-c.github.io/2021/07/19/Effective-STL-5-%E7%AE%97%E6%B3%95/</id>
    <published>2021-07-18T16:00:00.000Z</published>
    <updated>2021-10-06T08:26:35.959Z</updated>
    
    <content type="html"><![CDATA[<h1 id="5-算法"><a href="#5-算法" class="headerlink" title="5 算法"></a>5 算法</h1><span id="more"></span><h2 id="第-30-条：确保目标区间足够大。（inserter）"><a href="#第-30-条：确保目标区间足够大。（inserter）" class="headerlink" title="第 30 条：确保目标区间足够大。（inserter）"></a>第 30 条：确保目标区间足够大。（inserter）</h2><p>transform 算法：使用 front_inserter 将导致算法将结果插入到容器的头部，使用 back_inserter 将导致算法将结果插入到容器的尾部。</p><ol><li><p>向容器末尾添加新的对象（使用 back_inserter，适用于所有提供了 push_back 方法的容器（vector,string,deque,list））：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">transmogrify</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">// 该函数根据x生成一个新的值</span></span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; results</span>;</span><br><span class="line"><span class="built_in">transform</span>(values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>(),<span class="comment">// 将transmogrify作用在values的每个对象上</span></span><br><span class="line">         <span class="built_in">back_inserter</span>(results), <span class="comment">// 并将返回值插入到resultes的末尾。</span></span><br><span class="line">         transmogrify);</span><br></pre></td></tr></table></figure></li><li><p>向容器前面添加新的对象（使用 front_inserter，适用于所有提供了 push_front 方法的容器）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">transmogrify</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">// 该函数根据x生成一个新的值</span></span></span><br><span class="line"><span class="function">list&lt;<span class="keyword">int</span>&gt; results</span>;</span><br><span class="line"><span class="built_in">transform</span>(values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>(),<span class="comment">// 将transmogrify作用在values的每个对象上</span></span><br><span class="line">        <span class="built_in">front_inserter</span>(results), <span class="comment">// 并将返回值以逆向顺序</span></span><br><span class="line">         transmogrify);<span class="comment">// 插入到resultes的头部，</span></span><br></pre></td></tr></table></figure></li><li><p>将 transform 的输出结果存放在 results 的前端，同时保留它们在 values 中原有的顺序，只需按照相反方向遍历 values 即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">transmogrify</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">// 该函数根据x生成一个新的值</span></span></span><br><span class="line"><span class="function">list&lt;<span class="keyword">int</span>&gt; results</span>;</span><br><span class="line"><span class="built_in">transform</span>(values.<span class="built_in">rbegin</span>(), values.<span class="built_in">rend</span>(),<span class="comment">// 将transform的结果插入到容器头部，</span></span><br><span class="line">        <span class="built_in">front_inserter</span>(results), <span class="comment">// 并保持相对顺序。</span></span><br><span class="line">         transmogrify);</span><br></pre></td></tr></table></figure></li><li><p>将 transform 的结果插入到容器中特定位置上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">transmogrify</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">// 该函数根据x生成一个新的值</span></span></span><br><span class="line"><span class="function">list&lt;<span class="keyword">int</span>&gt; results</span>;</span><br><span class="line"><span class="built_in">transform</span>(values.<span class="built_in">rbegin</span>(), values.<span class="built_in">rend</span>(),</span><br><span class="line">        <span class="built_in">inserter</span>(results, results.<span class="built_in">begin</span>()+results.<span class="built_in">size</span>()/<span class="number">2</span>), </span><br><span class="line">         transmogrify);<span class="comment">// 将transform的结果插入到容器中间的位置</span></span><br></pre></td></tr></table></figure></li><li><p>如果使用 transform 要覆盖原来的元素，第三个参数可以使用迭代器。</p></li></ol><p>要在算法执行过程中增大目标区间，请使用<strong>插入型迭代器</strong>，比如 ostream_interator、back_inserter、front_inserter。</p><h2 id="第-31-条：与排序有关的的选择。（sort相关）"><a href="#第-31-条：与排序有关的的选择。（sort相关）" class="headerlink" title="第 31 条：与排序有关的的选择。（sort相关）"></a>第 31 条：与排序有关的的选择。（sort相关）</h2><ol><li><p>如果需要对 vector、string、deque 或者数组中的元素执行一次完全排序，可以使用 sort 或 stable_sort。</p></li><li><p>如果有一个 vector、string、deque 或者数组，并且只需要对等价性最前面的 n 个元素进行排序，那么可以使用 <strong>partial_sort</strong>。</p></li><li><p>如果有一个 vector、string、deque 或者数组，并且需要找到第 n 个位置上的元素，或者，需要找到等价性最前面的 n 个元素但又不必对这 n 个元素进行排序，可以使用 <strong>nth_element</strong>。</p></li><li><p>将一个标准序列容器中的元素按照是否满足某个条件区分开来，使用 <strong>partition</strong> 和 <strong>stable_partition</strong>。</p></li><li><p>sort、stable_sort、partial_sort、nth_element 算法都要求<strong>随机访问迭代器</strong>，所以这些算法只能用于 vector、string、deque 和数组。</p></li><li><p>对于 list，可以使用 partition 和 stable_partition，可以用 list::sort 来替代 sort 和 stable_sort 算法。</p><p>实现 partial_sort 和 nth_element，需要通过间接途径。</p></li><li><p>性能排序：partition &gt; stable_partion &gt; nth_element &gt; partial_sort &gt; sort &gt; stable_sort</p></li></ol><h2 id="第-32-条：如果确实需要删除元素，则需要在-remove-这一类算法之后调用-erase。"><a href="#第-32-条：如果确实需要删除元素，则需要在-remove-这一类算法之后调用-erase。" class="headerlink" title="第 32 条：如果确实需要删除元素，则需要在 remove 这一类算法之后调用 erase。"></a>第 32 条：如果确实需要删除元素，则需要在 remove 这一类算法之后调用 erase。</h2><p>remove 是<strong>泛型算法</strong>，不接受容器作为参数，它不知道元素被存放在哪个容器中，也不可能推断出是什么容器（因为无法从迭代器推知对应的容器类型）。只有容器的成员函数才可以删除容器中的元素。</p><blockquote><p>remove 不是真正意义上的删除，因为它做不到！</p></blockquote><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110061618725.png" alt="image-20210801160916442"></p><p>erase-remove 删除方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">...</span><br><span class="line">v.<span class="built_in">erase</span>(<span class="built_in">remove</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">99</span>), v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><p>例外：list 中的 remove 也应该被称为 erase，它可以真正删除元素。</p><p>两个 remove 类算法：remove_if 和 unique。</p><h2 id="第-33-条：对包含指针的容器使用-remove-这一类算法时要特别小心。"><a href="#第-33-条：对包含指针的容器使用-remove-这一类算法时要特别小心。" class="headerlink" title="第 33 条：对包含指针的容器使用 remove 这一类算法时要特别小心。"></a>第 33 条：对包含指针的容器使用 remove 这一类算法时要特别小心。</h2><p>对包含指针的容器使用 remove 这一类算法时要特别警惕，否则就是资源泄露。</p><p>使用智能指针（RSCP，Reference Counting Smart Pointer）就无需考虑这些问题。但智能指针类型（<code>RCSP&lt;Widget&gt;</code>）必须能够隐式地转换为内置指针类型（Widget*）。</p><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110061618305.png" alt="image-20210801165044912"></p><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110061618923.png" alt="image-20210801165134832"></p><h2 id="第-34-条：了解哪些算法要求使用排序的区间作为参数。"><a href="#第-34-条：了解哪些算法要求使用排序的区间作为参数。" class="headerlink" title="第 34 条：了解哪些算法要求使用排序的区间作为参数。"></a>第 34 条：了解哪些算法要求使用排序的区间作为参数。</h2><h3 id="要求排序区间的算法"><a href="#要求排序区间的算法" class="headerlink" title="要求排序区间的算法"></a>要求排序区间的算法</h3><ul><li>binary_search、lower_bound、upper_bound、equal_range：只有当这些算法接收<strong>随机访问迭代器</strong>时，才保证对数时间的查找效率。否则，尽管比较次数依然是区间元素个数的对数，执行过程需要线性时间。<ul><li>set_union、set_intersection、set_difference、set_symmetric_difference：需要排序的区间，这样能够保证线性时间内完成工作。</li></ul></li><li>merge 和 inplace_merge：实现了合并和排序的联合操作，源区间已经排过序则可以线性时间内完成。</li><li>includes：判断一个区间中的所有对象是否都在另一个区间中，如果这两个区间排序则承诺线性时间的效率。</li></ul><h3 id="不一定要求排序区间，但通常情况下会与排序区间一起使用"><a href="#不一定要求排序区间，但通常情况下会与排序区间一起使用" class="headerlink" title="不一定要求排序区间，但通常情况下会与排序区间一起使用"></a>不一定要求排序区间，但通常情况下会与排序区间一起使用</h3><p>unique 通常用于删除一个区间的所有重复值，但并非真正意义上的删除。</p><p>必须为 STL 提供一致的排序信息：如果你为一个算法提供了一个排序的区间，而这个算法也带一个比较函数作为参数，那么，你一定要保证你传递的比较函数与这个排序区间所用的比较函数有一致的行为。</p><p>所有要求排序区间的算法（除了 unique 和 unique_copy）均使用<strong>等价性</strong>来判断两个对象是否“相同”，这与标准的关联容器一致。与此相反的是，unique 和 unique_copy 在默认情况下使用<strong>“相等”</strong>来判断两个对象是否“相同”。</p><h2 id="第-35-条：通过-mismatch-或-lexicographical-compare-实现简单的忽略大小写的字符串比较。"><a href="#第-35-条：通过-mismatch-或-lexicographical-compare-实现简单的忽略大小写的字符串比较。" class="headerlink" title="第 35 条：通过 mismatch 或 lexicographical_compare 实现简单的忽略大小写的字符串比较。"></a>第 35 条：通过 mismatch 或 lexicographical_compare 实现简单的忽略大小写的字符串比较。</h2><h3 id="判断两个字符串是否相同，而不去管它们的大小写（ciCharCompare）"><a href="#判断两个字符串是否相同，而不去管它们的大小写（ciCharCompare）" class="headerlink" title="判断两个字符串是否相同，而不去管它们的大小写（ciCharCompare）"></a>判断两个字符串是否相同，而不去管它们的大小写（ciCharCompare）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ciCharCompare</span><span class="params">(<span class="keyword">char</span> c1, <span class="keyword">char</span> c2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lc1 = <span class="built_in">tolower</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(c1));</span><br><span class="line">    <span class="keyword">int</span> lc2 = <span class="built_in">tolower</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(c2));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (lc1 &lt; lc2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (lc1 &gt; lc2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 C 和 C++ 中，char 可能是有符号的，可能是无符号的。tolower 的参数和返回值都是 int，但是，除非该 int 值是 EOF，否则它的值必须可以用 unsigned char 表示。</p><h3 id="ciStringCompare"><a href="#ciStringCompare" class="headerlink" title="ciStringCompare"></a>ciStringCompare</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ciStringCompareImpl</span><span class="params">(<span class="keyword">const</span> string &amp;s1, <span class="keyword">const</span> string &amp;s2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ciStringCompare</span><span class="params">(<span class="keyword">const</span> string &amp;s1, <span class="keyword">const</span> string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">ciStringCompareImpl</span>(s1, s2);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> -<span class="built_in">ciStringCompare</span>(s2, s1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>第一种实现：mismatch</p><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110061618197.png" alt="image-20210802093101409"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//std::not2</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line">  <span class="function">binary_negate&lt;Predicate&gt; <span class="title">not2</span> <span class="params">(<span class="keyword">const</span> Predicate&amp; pred)</span></span>;</span><br><span class="line"><span class="comment">//Return negation of binary function object</span></span><br><span class="line"><span class="comment">//Constructs a binary function object (of a binary_negate type) that returns the //opposite of pred (as returned by operator !).</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// It is defined with the same behavior as:</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Predicate</span>&gt;</span> <span class="function">binary_negate&lt;Predicate&gt; <span class="title">not2</span> <span class="params">(<span class="keyword">const</span> Predicate&amp; pred)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> binary_negate&lt;Predicate&gt;(pred);</span><br><span class="line"><span class="comment">// 二元比较后再取非。</span></span><br></pre></td></tr></table></figure></li><li><p>第二种实现：lexicographical_compare</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ciCharCompare</span><span class="params">(<span class="keyword">char</span> c1, <span class="keyword">char</span> c2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">tolower</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(c1)) &lt; </span><br><span class="line">    <span class="built_in">tolower</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(c2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ciStringCompare</span><span class="params">(<span class="keyword">const</span> string &amp;s1, <span class="keyword">const</span> string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lexicographical_compare</span>(s1.<span class="built_in">begin</span>(), s1.<span class="built_in">end</span>(),</span><br><span class="line">                                  s2.<span class="built_in">begin</span>(), s2.<span class="built_in">end</span>(),</span><br><span class="line">                                  ciCharLess);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lexicographical_compare 是 strcmp 的一个泛化版本，可以允许用户自定义两个值的比较准则。<br>如果在找到不同的值之前，第一个区间已经结束了，返回  true：一个前缀比任何一个以他为前缀的区间更靠前。</p></li></ul><h2 id="第-36-条：理解-copy-if-算法的正确实现"><a href="#第-36-条：理解-copy-if-算法的正确实现" class="headerlink" title="第 36 条：理解 copy_if 算法的正确实现"></a>第 36 条：理解 copy_if 算法的正确实现</h2><p>copy_if 的正确实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIterator,</span></span><br><span class="line"><span class="function"><span class="keyword">typename</span> OutputIterator,</span></span><br><span class="line"><span class="function"><span class="keyword">typename</span> Predicate&gt;</span></span><br><span class="line"><span class="function">OutputIterator <span class="title">copy_if</span><span class="params">(InputIterator begin,</span></span></span><br><span class="line"><span class="params"><span class="function">                      InputIterator end,</span></span></span><br><span class="line"><span class="params"><span class="function">                      OutputIterator destBegin</span></span></span><br><span class="line"><span class="params"><span class="function">                      Predicate p)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (begin != end) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">p</span>(*begin)) *destBegin++ = *begin;</span><br><span class="line">                ++begin;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> destBegin;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="第-37-条：使用-accumulate-或者-for-each-进行区间统计。"><a href="#第-37-条：使用-accumulate-或者-for-each-进行区间统计。" class="headerlink" title="第 37 条：使用 accumulate 或者 for_each 进行区间统计。"></a>第 37 条：使用 accumulate 或者 for_each 进行区间统计。</h2><h3 id="accumulate（计算出一个区间的统计信息）"><a href="#accumulate（计算出一个区间的统计信息）" class="headerlink" title="accumulate（计算出一个区间的统计信息）"></a>accumulate（计算出一个区间的统计信息）</h3><ol><li><p>std::accumulate</p><table><thead><tr><th align="right">sum (1)</th><th><code>template &lt;class InputIterator, class T&gt;  T accumulate (InputIterator first, InputIterator last, T init); </code></th></tr></thead><tbody><tr><td align="right">custom (2)</td><td><code>template &lt;class InputIterator, class T, class BinaryOperation&gt; T accumulate (InputIterator first, InputIterator last, T init,                 BinaryOperation binary_op);</code></td></tr></tbody></table></li><li><p>sum：</p><p>第一种形式：有两个迭代器和一个初始值。计算 double 的总和时，初始值应该设为 0.0，否则 sum 的值不正确（每次加法的结果转换成整数后再运算）</p><p>第二种形式：使用 istream_iterator 和 istreambuf_interator（数值算法，numeric algorithm）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">accumulate</span>(istream_iterator&lt;<span class="keyword">int</span>&gt;(cin),</span><br><span class="line">                  istream_iterator&lt;<span class="keyword">int</span>&gt;(),</span><br><span class="line">                  <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>accumulate 直接返回统计结果。</p></li><li><p>用法（custom）</p><ol><li><p>计算一个容器中字符串的长度总和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string::size_type</span></span><br><span class="line"><span class="function"><span class="title">stringLengthSum</span><span class="params">(string::size_type sumSofFar, <span class="comment">//size_type:中的技术类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">const</span> string &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sumSoFar + s.<span class="built_in">size</span>();</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">set&lt;string&gt; ss;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 对ss中的每个元素调用stringLengthSum，然后把结果付给lengthSum，初始值为0</span></span><br><span class="line">string::size_type lengthSum = </span><br><span class="line">    <span class="built_in">accumulate</span>(ss.<span class="built_in">begin</span>(), ss.<span class="built_in">end</span>().</span><br><span class="line">              <span class="keyword">static_cast</span>&lt;string::size_type&gt;(<span class="number">0</span>),</span><br><span class="line">              stringLengthSum);</span><br></pre></td></tr></table></figure></li><li><p>计算一个区间中数值的乘积。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">float</span>&gt; vf;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 对vf中的每个元素调用multipies&lt;float&gt;，并把结果赋给product    </span></span><br><span class="line"><span class="keyword">float</span> product = <span class="built_in">accumulate</span>(vf.<span class="built_in">begin</span>(), vf.<span class="built_in">end</span>(), <span class="number">1.0f</span>, multiplies&lt;<span class="keyword">float</span>&gt;());    </span><br></pre></td></tr></table></figure><p>初始值必须为1.0f，保证是浮点数的1。</p></li></ol></li></ol><h3 id="for-each（对一个区间的每个元素做一个操作）"><a href="#for-each（对一个区间的每个元素做一个操作）" class="headerlink" title="for_each（对一个区间的每个元素做一个操作）"></a>for_each（对一个区间的每个元素做一个操作）</h3><p>for_each 接受两个参数：一个是区间，另一个是函数（通常是函数对象），对区间中的每个元素都要调用这个函数。但这个函数只接受一个实参（即当前区间的元素）。</p><p>for_each 的函数参数允许有副作用。</p><p>for_each 返回的是一个<strong>函数对象</strong>。</p><p>举例：P134，计算一个区间中所有点的平均值。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;5-算法&quot;&gt;&lt;a href=&quot;#5-算法&quot; class=&quot;headerlink&quot; title=&quot;5 算法&quot;&gt;&lt;/a&gt;5 算法&lt;/h1&gt;</summary>
    
    
    
    <category term="C++" scheme="https://tommyplayer-c.github.io/categories/C/"/>
    
    
    <category term="STL" scheme="https://tommyplayer-c.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>Effective STL 笔记-第4章 迭代器</title>
    <link href="https://tommyplayer-c.github.io/2021/07/18/Effective-STL-4-%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>https://tommyplayer-c.github.io/2021/07/18/Effective-STL-4-%E8%BF%AD%E4%BB%A3%E5%99%A8/</id>
    <published>2021-07-17T16:00:00.000Z</published>
    <updated>2021-10-06T08:26:33.999Z</updated>
    
    <content type="html"><![CDATA[<h1 id="4-迭代器"><a href="#4-迭代器" class="headerlink" title="4 迭代器"></a>4 迭代器</h1><span id="more"></span><h2 id="第-26-条：iterator-优先于-const-interator、reverse-interator-及-const-reverse-interator。"><a href="#第-26-条：iterator-优先于-const-interator、reverse-interator-及-const-reverse-interator。" class="headerlink" title="第 26 条：iterator 优先于 const_interator、reverse_interator 及 const_reverse_interator。"></a>第 26 条：iterator 优先于 const_interator、reverse_interator 及 const_reverse_interator。</h2><p>不同类型的迭代器之间的关系：</p><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110061617728.png" alt="image-20210801082829532"></p><p>尽量使用 iterator 而不是 const 或 reverse 型的迭代器，可以使得容器的使用更为简单而有效，并且可以避免潜在的问题。</p><ul><li>有些版本的 insert 和 erase 函数要求使用 iterator。如果你需要调用这些函数，必须使用 iterator，const 和 reverse 型的迭代器不能满足这些函数的要求。</li><li>要想隐式地将一个 const_interator 转换成 iterator 是不可能的。</li><li>从 reverse_interator 转换而来的 iterator 在使用之前可能需要相应的调整。</li><li>尽量不要混合使用 iterator 和 const_interator，有可能通过不了编译。</li></ul><h2 id="第-27-条：使用-distance-和-advance-将容器的-const-interator-转换成-iterator。"><a href="#第-27-条：使用-distance-和-advance-将容器的-const-interator-转换成-iterator。" class="headerlink" title="第 27 条：使用 distance 和 advance 将容器的 const_interator 转换成 iterator。"></a>第 27 条：使用 distance 和 advance 将容器的 const_interator 转换成 iterator。</h2><p>包含显式类型转换的代码不能通过编译的原因：对于这些容器类型（deque，list，set，multiset，map，multimap），iterator 和 const_interator 是完全不同的类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> intDeque::const_interator ConstIter;</span><br><span class="line">ConstIter ci;</span><br><span class="line">...</span><br><span class="line"><span class="function">Iter <span class="title">i</span><span class="params">(ci)</span></span>;<span class="comment">// 编译错误！从const_interator到</span></span><br><span class="line"><span class="comment">// iterator没有隐式转换途径。</span></span><br><span class="line"><span class="function">Iter <span class="title">i</span><span class="params">(const_caset&lt;Iter&gt;(ci))</span></span>;<span class="comment">// 仍然是编译错误！不能将</span></span><br><span class="line"><span class="comment">// const_iterator强制转换为iterator</span></span><br></pre></td></tr></table></figure><p>不过，对于 vector 和 string 而言，以上代码也许能通过编译。</p><p>vector：const T* 变为 const *</p><p>string：char * 变为 const char *</p><p>将 const_interator 转换为 iterator 可能需要线性时间的代价（双向迭代器），安全、可移植不需要线性时间（随机访问迭代器）的代价。</p><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110061618615.png" alt="image-20210801084840175"></p><p>将 advance 那一行改为 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">advance</span>(i, distance&lt;ConstIter&gt;(i, ci));<span class="comment">// 将i和ci都当做const_interator,</span></span><br><span class="line"><span class="comment">// 计算出它们之间的距离，然后将i移动这段距离</span></span><br></pre></td></tr></table></figure><h2 id="第-28-条：正确理解由-reverse-interator-的-base-成员函数所产生的-iterator-的用法。"><a href="#第-28-条：正确理解由-reverse-interator-的-base-成员函数所产生的-iterator-的用法。" class="headerlink" title="第 28 条：正确理解由 reverse_interator 的 base() 成员函数所产生的 iterator 的用法。"></a>第 28 条：正确理解由 reverse_interator 的 base() 成员函数所产生的 iterator 的用法。</h2><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110061618742.png" alt="image-20210801085559849"></p><p>删除 ri 所指的元素：<code>v.erase((++ri).base() );</code> 不能对 base 的结果做递减操作，先递增 ri，再调用 base() 函数。</p><h2 id="第-29-条：对于逐个字符的输入请考虑使用-istreambuf-iterator。"><a href="#第-29-条：对于逐个字符的输入请考虑使用-istreambuf-iterator。" class="headerlink" title="第 29 条：对于逐个字符的输入请考虑使用 istreambuf_iterator。"></a>第 29 条：对于逐个字符的输入请考虑使用 istreambuf_iterator。</h2><p>如果你需要从一个输入流中逐个读取字符，那么就<strong>不必使用格式化输入</strong>，使用 istreambuf_interator 可获得明显的性能改善：直接从<strong>流的缓冲区</strong>读取下一个字符。</p><p>复制文本文件的内容到 string：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">inputFile</span><span class="params">(<span class="string">&quot;interestingData.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">fileData</span><span class="params">((istreambuf_iterator&lt;<span class="keyword">char</span>&gt;(inputFile)),</span></span></span><br><span class="line"><span class="params"><span class="function">                istreambuf_iterator&lt;<span class="keyword">char</span>&gt;())</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;4-迭代器&quot;&gt;&lt;a href=&quot;#4-迭代器&quot; class=&quot;headerlink&quot; title=&quot;4 迭代器&quot;&gt;&lt;/a&gt;4 迭代器&lt;/h1&gt;</summary>
    
    
    
    <category term="C++" scheme="https://tommyplayer-c.github.io/categories/C/"/>
    
    
    <category term="STL" scheme="https://tommyplayer-c.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>Effective STL 笔记-第3章 关联容器</title>
    <link href="https://tommyplayer-c.github.io/2021/07/17/Effective-STL-3-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/"/>
    <id>https://tommyplayer-c.github.io/2021/07/17/Effective-STL-3-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/</id>
    <published>2021-07-16T16:00:00.000Z</published>
    <updated>2021-10-06T08:26:31.864Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-关联容器"><a href="#3-关联容器" class="headerlink" title="3 关联容器"></a>3 关联容器</h1><span id="more"></span><h2 id="第-19-条：理解相等（equality）和等价（equivalence）的区别。"><a href="#第-19-条：理解相等（equality）和等价（equivalence）的区别。" class="headerlink" title="第 19 条：理解相等（equality）和等价（equivalence）的区别。"></a>第 19 条：理解相等（equality）和等价（equivalence）的区别。</h2><p>find 对”相同“的定义是<strong>相等</strong>，是以 <strong>operator==</strong> 为基础的。但 x 和 y 有相等的值并不一定意味着它们的所有数据成员都有相等的值。</p><p>set::insert 对“相同”的定义是<strong>等价</strong>，是以 <strong>operator&lt;</strong> 为基础的。</p><p>考虑 <code>set&lt;Widget&gt; s</code> 和 两个对象 w1 和 w2，如果下面的表达式为真，则 w1 和 w2 对于 operator&lt; 具有相等的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">! (w1 &lt; w2) &amp;&amp; ! (w2 &lt; w1);</span><br></pre></td></tr></table></figure><p>如果两个值中的任何一个（按照一定的排序准则）都不在另一个的前面，那么这两个值（按照这一准则）就是等价的。</p><p>标准关联容器总是保持排列顺序的，所以每个容器必须有一个比较函数（默认为 less）来决定保持怎样的顺序。等价的定义正是通过该比较函数实现的。</p><p>使用单一的比较函数可以避免一大堆问题。</p><h2 id="第-20-条：为包含指针的关联容器指定比较类型。"><a href="#第-20-条：为包含指针的关联容器指定比较类型。" class="headerlink" title="第 20 条：为包含指针的关联容器指定比较类型。"></a>第 20 条：为包含指针的关联容器指定比较类型。</h2><p><code>set&lt;string*&gt; ssp;</code></p><p>是如下代码的缩写。</p><p><code>set&lt;string*, less&lt;string*&gt; &gt; ssp;</code></p><p>如果你想让 string* 指针在集合中按字符串的值排序，那么不能使用默认的比较函数子类（function class）less&lt;string*&gt;。你必须自己编写<strong>函数子类</strong>（不能是函数，set 需要的是一个类型，并在内部用它创建一个函数 ）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StringPtrLess</span>:</span></span><br><span class="line"><span class="keyword">public</span> binary_function&lt;<span class="keyword">const</span> string*,</span><br><span class="line"><span class="keyword">const</span> string*,</span><br><span class="line"><span class="keyword">bool</span>&gt;&#123;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> string *ps1, <span class="keyword">const</span> string *ps2)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *ps1 &lt; *ps2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;                             </span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110061613952.png" alt="image-20210728175610404"></p><h2 id="第-21-条：总是让比较函数在等值情况下返回-false。"><a href="#第-21-条：总是让比较函数在等值情况下返回-false。" class="headerlink" title="第 21 条：总是让比较函数在等值情况下返回 false。"></a>第 21 条：总是让比较函数在等值情况下返回 false。</h2><p>相等的值从来就不会有前后顺序关系，所以，对于相等的值，比较函数应当始终返回 false。</p><p>equal_range：指定一个包含等价值的区间。</p><p>任何一个定义了”严格的弱序化“的函数必须对相同值得两个拷贝返回 false。</p><h2 id="第-22-条：切勿直接修改-set-或-multiset-中的键。"><a href="#第-22-条：切勿直接修改-set-或-multiset-中的键。" class="headerlink" title="第 22 条：切勿直接修改 set 或 multiset 中的键。"></a>第 22 条：切勿直接修改 set 或 multiset 中的键。</h2><p>对于一个 map&lt;K, V&gt; 或 map&lt;K, V&gt; 类型的对象，其中的元素类型是 pair&lt;const K, V&gt;，因为键的类型是 const K，所以它不能修改。</p><p>set / multiset 中的值不是 const，所以对这些值进行修改的代码可以通过编译。</p><p>类型转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i != se.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const_cast</span>&lt;Employee&gt;(*i).<span class="built_in">setTitle</span>(<span class="string">&quot;Corporate Deitiy&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，不能使用 static_cast ，因为类型转换的结果是一个临时的匿名对象，它是 *i 的一个拷贝，setTitle 被作用在这个临时对象上，而不是 *i 上！</p><p>执行一次强制类型转换就意味着临时关掉了类型系统的安全性。</p><p>小结：</p><ul><li>如果你不关心程序的可移植性，而你想改变 set 或 multiset 中元素的值，并且你的 STL 实现允许，则请继续做下去。只是注意不要改变元素中的键部分，即元素中能够影响容器有序性的部分。</li><li>如果你重视可移植性，就要确保 set 和 multiset 中的元素不能被修改。至少不能未经过强制类型转换就修改。</li></ul><p>安全、可移植的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Employee selectedID;</span><br><span class="line">...</span><br><span class="line">EmpIDSet::iterator i =</span><br><span class="line">    se.<span class="built_in">find</span>(selectedID);<span class="comment">// 第1步：找到待修改的元素</span></span><br><span class="line"><span class="keyword">if</span> (i != se.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="function">Employee <span class="title">e</span> <span class="params">(*i)</span></span>;<span class="comment">// 第2步：拷贝该元素</span></span><br><span class="line">    e.<span class="built_in">setTitle</span>(<span class="string">&quot;Corporate Deily&quot;</span>);<span class="comment">// 第3步：修改拷贝</span></span><br><span class="line">    se.<span class="built_in">erase</span>(i++);<span class="comment">// 第4步：删除该元素</span></span><br><span class="line">    <span class="comment">// 递增迭代器以保持它的有效性</span></span><br><span class="line">    se.<span class="built_in">insert</span>(i, e)<span class="comment">// 第5步：插入该元素，它的位置和原来相同。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="第-23-条：考虑用排序的-vector-替代关联容器。"><a href="#第-23-条：考虑用排序的-vector-替代关联容器。" class="headerlink" title="第 23 条：考虑用排序的 vector 替代关联容器。"></a>第 23 条：考虑用排序的 vector 替代关联容器。</h2><p>标准的关联容器通常被实现为<strong>平衡二叉树</strong>。适合插入、删除、查找的混合操作，提供对数时间的查找能力。但比较浪费内存空间（父指针，左儿子指针，右儿子指针）。如果节点散布在全部地址空间，将会导致更多的页缺失。</p><p>散列容器：提供常数时间的查找能力。</p><p>使用数据结构的一般过程：</p><ol><li><strong>设置阶段</strong>：创建一个新的数据结构，并插入大量元素。在这个阶段，几乎所有的操作都是插入和删除操作，很少或几乎没有查找操作。</li><li><strong>查找阶段</strong>：查询该数据结构以找到特定的信息。在这个阶段，几乎所有的操作都是查找操作，很少或几乎没有插入和删除操作。</li><li><strong>重组阶段</strong>：改变该数据结构的内容，或许是删除所有的当前数据，再插入新的数据。在行为上，这个阶段与第1阶段类似。但这个阶段结束以后，应用程序又回到了第2阶段。</li></ol><p>使用 vector 替代标准关联容器：</p><ul><li>在<strong>排序</strong>的 vector 中存储数据可能比在标准关联容器中存储同样的数据要耗费更少的内存。</li><li>考虑到页面错误的因素，通过<strong>二分搜索法</strong>来查找一个排序的 vector 可能比查找一个标准关联容器要更快一点。</li><li>存储在 vector 中的数据必须是 pair&lt;K, V&gt; ，因为排序时它的元素的值将通过赋值操作被移动。</li><li>对 vector 做排序时，必须为 pair 写一个<strong>自定义的比较类型</strong>。（P85）</li></ul><h2 id="第-24-条：当效率至关重要时，请在-map-operator-与-map-insert-之间谨慎做出选择。"><a href="#第-24-条：当效率至关重要时，请在-map-operator-与-map-insert-之间谨慎做出选择。" class="headerlink" title="第 24 条：当效率至关重要时，请在 map::operator[] 与 map::insert 之间谨慎做出选择。"></a>第 24 条：当效率至关重要时，请在 map::operator[] 与 map::insert 之间谨慎做出选择。</h2><p>map 的 operator[] 函数与众不同，它与 vector、deque 和 string 的 operator[] 函数无关，与用于数组的内置 operator[] 也没有关系。它的设计目的时为了提供<strong>添加和更新</strong>（add or update）的功能。</p><p><code>m[k] = v</code> 检查键 k 是否已经在 map 中了。如果没有，它就被加入，并以 v 作为相应的值。如果 k 已经在映射表中了，则与之关联的值被更新为 v。</p><p>k 不在映射表时，operator[] 使用值类型的<strong>默认构造函数</strong>创建一个新的对象，然后返回指向这个新对象的引用。这样做效率会很低，可以换为 insert 操作，节省了 3 个函数调用（创建默认构造的对象，析构该临时对象，调用赋值操作符）。</p><p>总结：当向映射表中添加元素时，要优先选用 insert 而不是 operator[]；当更新已经在映射表中的元素的值时，要优先选择 operator[]。</p><p>P90：efficientAddOrUpdate</p><h2 id="第-25-条：熟悉非标准的散列容器。"><a href="#第-25-条：熟悉非标准的散列容器。" class="headerlink" title="第 25 条：熟悉非标准的散列容器。"></a>第 25 条：熟悉非标准的散列容器。</h2><p>非标准的散列容器有 hash_map，hash_set，hash_multimap，hash_multiset</p><p>SGI 的散列容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span><br><span class="line"><span class="keyword">typename</span> HashFunction = hash&lt;T&gt;,</span><br><span class="line"><span class="keyword">typename</span> CompareFunction = equal_to&lt;T&gt;,</span><br><span class="line"><span class="keyword">typename</span> Allocator = allocator&lt;T&gt; &gt;</span><br><span class="line">class hash_set;            </span><br></pre></td></tr></table></figure><p>注意，与标准关联容器不同， SGI 的散列容器使用 <strong>equal_to</strong> 作为默认的比较函数，通过测试两个对象是否<strong>相等</strong>而不是等价来决定容器中的两个对象是否相等。</p><p>SGI 的实现把表的元素放在一个单向链表中，而 Dinkumware 的实现则使用了双向链表。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;3-关联容器&quot;&gt;&lt;a href=&quot;#3-关联容器&quot; class=&quot;headerlink&quot; title=&quot;3 关联容器&quot;&gt;&lt;/a&gt;3 关联容器&lt;/h1&gt;</summary>
    
    
    
    <category term="C++" scheme="https://tommyplayer-c.github.io/categories/C/"/>
    
    
    <category term="STL" scheme="https://tommyplayer-c.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>Effective STL 笔记-第2章 vector 和 string</title>
    <link href="https://tommyplayer-c.github.io/2021/07/16/Effective-STL-2-vector-%E5%92%8C-string/"/>
    <id>https://tommyplayer-c.github.io/2021/07/16/Effective-STL-2-vector-%E5%92%8C-string/</id>
    <published>2021-07-15T16:00:00.000Z</published>
    <updated>2021-10-06T08:26:29.770Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-vector-和-string"><a href="#2-vector-和-string" class="headerlink" title="2 vector 和 string"></a>2 vector 和 string</h1><span id="more"></span><h2 id="第-13-条：vector-和-string-优先于动态分配的数组。"><a href="#第-13-条：vector-和-string-优先于动态分配的数组。" class="headerlink" title="第 13 条：vector 和 string 优先于动态分配的数组。"></a>第 13 条：vector 和 string 优先于动态分配的数组。</h2><p>使用 new 动态分配内存时必须承担的责任：</p><ol><li>确保以后用 delete 删除所分配的内存。</li><li>确保使用正确的 delete 形式。</li><li>确保只 delete 了一次。</li></ol><p>普通数组的缺点：</p><ol><li>没有提供 begin、end、size 这样的成员函数。</li><li>没有 iterator、reverse_iterator、value_type 这样的嵌套类型定义。</li></ol><p>使用 vector 和 string 可以减轻自己的负担。</p><h2 id="第-14-条：使用-reserve-来避免不必要的重新分配。"><a href="#第-14-条：使用-reserve-来避免不必要的重新分配。" class="headerlink" title="第 14 条：使用 reserve 来避免不必要的重新分配。"></a>第 14 条：使用 reserve 来避免不必要的重新分配。</h2><p>vector 和 string 的自动增长机制：</p><ol><li>分配：分配一块大小为当前容量的<strong>某个倍数</strong>的新内存。vector 和 string 一般为 2.</li><li>把容器的<strong>所有元素</strong>从旧的内存复制到新的内存。</li><li>析构掉旧内存中的对象。</li><li>释放旧内存。</li></ol><p>**size()**：告诉你该容器中有多少个元素。</p><p>**capacity()**：告诉你该容器利用已经分配的内存可以容纳多少个元素。这是容器所能容纳的元素总数。</p><p>**resize(Container::size_type n)**：强迫容器改变到包含 n 个元素的状态。在调用 resize 之后，size 将返回 n。</p><p>**reserve(Container::size_type n)**：强迫容器把它的容量变为至少是 n，前提是 n 不小于当前的大小。</p><p>使用 reserve，简单预留适合大小的空间，避免循环过程中发生重新分配：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">reserve</span>(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; ++i) v.<span class="built_in">push_back</span>(i);</span><br></pre></td></tr></table></figure><p>对 push_back 的调用不会使 string 中的迭代器、指针和引用无效：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt; s.<span class="built_in">capacity</span>())</span><br><span class="line">&#123;</span><br><span class="line">    s.<span class="built_in">push_back</span>(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h2 id="第-15-条：注意-string-实现的多样性。"><a href="#第-15-条：注意-string-实现的多样性。" class="headerlink" title="第 15 条：注意 string 实现的多样性。"></a>第 15 条：注意 string 实现的多样性。</h2><p>每个 string 包含的信息：</p><ul><li>字符串的大小（size），即它所包含的字符个数。</li><li>存储该字符串中字符的内存容量（capacity）。</li><li>字符串的值（value)，即构成该字符串的字符。</li></ul><p>可选：</p><ul><li>分配子的拷贝。</li><li>对值的引用计数。</li></ul><p><strong>P56-P59</strong></p><h3 id="实现A"><a href="#实现A" class="headerlink" title="实现A"></a>实现A</h3><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110061612369.png" alt="image-20210728155941619"></p><h3 id="实现B"><a href="#实现B" class="headerlink" title="实现B"></a>实现B</h3><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110061612461.png" alt="image-20210728155956711"></p><h3 id="实现C"><a href="#实现C" class="headerlink" title="实现C"></a>实现C</h3><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110061612109.png" alt="image-20210728160035319"></p><h3 id="实现D"><a href="#实现D" class="headerlink" title="实现D"></a>实现D</h3><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110061612242.png" alt="image-20210728160108172"></p><h2 id="第-16-条：了解如何把-vector-和-string-数据传给旧的-API。"><a href="#第-16-条：了解如何把-vector-和-string-数据传给旧的-API。" class="headerlink" title="第 16 条：了解如何把 vector 和 string 数据传给旧的 API。"></a>第 16 条：了解如何把 vector 和 string 数据传给旧的 API。</h2><ul><li><p>C++标准要求  vector 中的元素存储在连续的内存中，就像数组一样，所以可以直接得到容器中的数据指针。</p><p>对于 vector<int> v; 表达式 v[0] 给出了一个引用，它是该向量中的第一个元素，所以 &amp;v[0] 是指向第一个元素的指针。</p><p>&amp;*v.begin() 等价于 &amp;v[0]</p></li><li><p>对于 string，由于 string 中的数据不一定存储在连续的内存中且 string 的内部表示不一定是以空字符结尾，需使用成员函数 c_str()。</p></li></ul><p>P62</p><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110061612326.png" alt="image-20210728163911009"><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110061612568.png" alt="image-20210728164036170"></p><h2 id="第-17-条：使用-“swap-技巧”-除去多余的容量。"><a href="#第-17-条：使用-“swap-技巧”-除去多余的容量。" class="headerlink" title="第 17 条：使用 “swap 技巧” 除去多余的容量。"></a>第 17 条：使用 “swap 技巧” 除去多余的容量。</h2><p>shrink to fit：为了避免向量仍占用不再需要的内存，你希望有一种方法能把它的容量从以前的最大值缩减到当前需要的数量。</p><p>从 contestants 向量中除去多余的容量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Contestant&gt;(contestants).<span class="built_in">swap</span>(contestants);</span><br></pre></td></tr></table></figure><p>vector 的拷贝构造函数只为说拷贝的元素分配<strong>所需要的内存</strong>，所以这个临时变量没有多余的容量。</p><p>swap：临时变量的数据和 contestents 的数据做 swap 操作。在这之后，contestents 具有了被去除之后的容量，即原先临时变量的容量。临时变量随后被析构，从而释放先前为 contestents 所占据的内存。注意，迭代器、指针和引用也将被交换（string 除外）。</p><p>同样适用于 string</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">string</span>(s).<span class="built_in">swap</span>(s);    </span><br></pre></td></tr></table></figure><p>清除一个容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Contestant&gt; v;</span><br><span class="line">string s;</span><br><span class="line">...</span><br><span class="line">vector&lt;Contestant&gt;().<span class="built_in">swap</span>(v);<span class="comment">// 清除v并把它的容量变为最小</span></span><br><span class="line"><span class="built_in">string</span>().<span class="built_in">swap</span>(s);<span class="comment">// 清除s并把它的容量变为最小</span></span><br></pre></td></tr></table></figure><h2 id="第-18-条：避免使用-vector-bool。"><a href="#第-18-条：避免使用-vector-bool。" class="headerlink" title="第 18 条：避免使用 vector bool。"></a>第 18 条：避免使用 vector bool。</h2><p>vector<bool> 是一个假的容器：</p><ul><li><p>它不是一个 STL 容器。</p></li><li><p>它并不存储 bool。为了节省空间，它储存的是 bool 的紧凑表示——使用了与位域（bitfield）一样的思想，一个 8 位的字节可容纳 8 个 “bool”。<u>你可以创建一个指向 bool 的指针，而指向单个位的指针则是不允许的。指向单个位的引用也是被禁止的。</u></p></li><li><p>vector<bool>::operator[] 返回一个对象，表现得像是一个指向单个位的引用，即所谓的代理对象（proxy object）。</p></li></ul><p>vector<bool> 的替代方案：</p><ol><li>deque<bool>：deque<bool> 是一个 STL 容器，而且它确实存储 bool。但 deque 中元素的内存不是连续的。</li><li>bitset：bitset 不是 STL 容器，它的大小（元素的个数）在编译时就确定了，所以它不支持迭代器。与 vector<bool> 一样，它使用了一种紧凑表示，只为所包含的每个值提供一位空间。</li></ol><p>总之，vector<bool> 是一个失败了的雄心勃勃的实验，它不完全满足 STL 容器的要求；你最好不要使用它；你可以使用 deque<bool> 和 bitset 来替代它，这两个数据结构几乎能做 vector<bool> 所能做的一切事情。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;2-vector-和-string&quot;&gt;&lt;a href=&quot;#2-vector-和-string&quot; class=&quot;headerlink&quot; title=&quot;2 vector 和 string&quot;&gt;&lt;/a&gt;2 vector 和 string&lt;/h1&gt;</summary>
    
    
    
    <category term="C++" scheme="https://tommyplayer-c.github.io/categories/C/"/>
    
    
    <category term="STL" scheme="https://tommyplayer-c.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>Effective STL 笔记-第1章 容器</title>
    <link href="https://tommyplayer-c.github.io/2021/07/15/Effective-STL-1-%E5%AE%B9%E5%99%A8/"/>
    <id>https://tommyplayer-c.github.io/2021/07/15/Effective-STL-1-%E5%AE%B9%E5%99%A8/</id>
    <published>2021-07-14T16:00:00.000Z</published>
    <updated>2021-10-06T08:26:27.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-容器"><a href="#1-容器" class="headerlink" title="1 容器"></a>1 容器</h1><span id="more"></span><h2 id="第-1-条：慎重选择容器类型。"><a href="#第-1-条：慎重选择容器类型。" class="headerlink" title="第 1 条：慎重选择容器类型。"></a>第 1 条：慎重选择容器类型。</h2><p>STL 容器不是简单的好，而是确实很好。</p><p>容器类型如下：</p><ul><li><strong>标准 STL 序列容器</strong>：vector、string、deque、list。</li><li><strong>标准 STL 关联容器</strong>：set、multiset、map、multimap。</li><li>非标准序列容器 slist 和 rope。slist 是一个单向链表，rope 本质上是一个 “重型” string。</li><li>非标准的关联容器：hash_set、hash_multiset、hash_map、hash_multimap。</li><li><strong>vector<char> 作为 string 的替代</strong>。</li><li>vector 作为标准关联容器的替代：有时 vector 在运行时间和空间上都要优于标准关联容器。</li><li><strong>几种标准的非 STL 容器</strong>：数组、bitset、valarray、<strong>stack</strong>、<strong>queue</strong>、<strong>priority_queue</strong>。</li></ul><p>选择标准：</p><ol><li><p>vector 应该是默认使用的序列类型；需要频繁地在序列中间做插入和删除操作时，使用 list；大多数插入和删除的操作发生在序列的头部和尾部时，使用 deque。</p></li><li><p><strong>连续内存容器</strong>：也称为基于数组的容器（array-based container），特点是会把它的元素存放在一块或多块动态分配的内存中，<strong>每块内存中有多个元素</strong>。</p><p>插入或删除元素时，<strong>同一内存块中的所有元素要向前或向后移动</strong>，这样会影响效率和异常安全性。</p><p>连续内存容器有 vector、string、deque、rope。</p></li><li><p><strong>基于节点的容器</strong>：每一个动态分配的内存块中只存放一个元素。<strong>元素的插入和删除只影响到指向节点的指针，而不影响节点本身的内容</strong>。所以插入或删除操作时元素的值不需要移动。</p><p>基于节点的容器有 list 和 slist。</p></li><li><p>如果容器内部使用了引用计数技术（reference counting），你是否介意？如果是，就要避免使用 string 和 rope（都使用了引用计数技术）。可以考虑 vector<char></p></li><li><p>你需要使迭代器、指针、引用变为无效的次数最少吗？基于节点的容器没有这个问题，<strong>针对连续内存容器的插入和删除操作一般</strong>会导致指向该容器的迭代器、指针和引用变为无效。</p></li><li><p>如果在容器上使用 swap，使得迭代器、指针或引用变为无效了，你会在意吗？如果在意，你要避免使用 string，<strong>因为 string 是 STL 中在 swap 过程中会导致迭代器、指针和引用变为无效的唯一容器</strong>。</p></li></ol><h2 id="第-2-条：不要试图编写独立于容器类型的代码。"><a href="#第-2-条：不要试图编写独立于容器类型的代码。" class="headerlink" title="第 2 条：不要试图编写独立于容器类型的代码。"></a>第 2 条：不要试图编写独立于容器类型的代码。</h2><p>容器类型被泛化为序列容器和关联容器，类似的容器被赋予相似的功能：</p><ol><li>标准的连续内存容器提供随机访问迭代器，而标准的基于节点的容器提供了双向迭代器。</li><li>序列容器支持 push_front 和/或 push_back 操作，而关联容器则不然。</li><li>关联容器提供了对数时间的 lower_bound、upper_bound、equal_range 成员函数，但序列容器却没有提供。</li></ol><p>所以，试图编写对序列容器和关联容器都适用的代码是毫无意义的，因为很多成员函数仅当其容器为某一类型时才存在。这种限制的根源在于，对不同类型的序列容器，使迭代器、指针和引用无效（invalidate）的规则是不同的。不同的容器是不同的，它们有非常明显的优缺点。它们并不是被设计来交换使用的。</p><p><strong>一种容器类型转换为另一种容器类型</strong>：typedef</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span>...&#125;;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;Widget&gt; WidgetContainer;</span><br><span class="line">WidgetContainer cw;</span><br><span class="line">Widget bestWidget;</span><br><span class="line">...</span><br><span class="line">WidgetContainer::iterator i = <span class="built_in">find</span>(cw.<span class="built_in">begin</span>(), cw.<span class="built_in">end</span>(), bestWidget);</span><br></pre></td></tr></table></figure><p>这样就使得改变容器类型要容易得多，尤其当这种改变仅仅是增加一个自定义得分配子时，就显得更为方便（这一改变不影响使迭代器/指针/引用无效的规则）。</p><h2 id="第-3-条：确保容器中的对象拷贝正确而高效。"><a href="#第-3-条：确保容器中的对象拷贝正确而高效。" class="headerlink" title="第 3 条：确保容器中的对象拷贝正确而高效。"></a>第 3 条：确保容器中的对象拷贝正确而高效。</h2><ul><li><p>存在继承关系的情况下，拷贝动作会导致<strong>剥离（slicing）</strong>：如果创建了一个存放基类对象的容器，却向其中插入派生类对象，那么在派生类对象（通过基类的拷贝构造函数）被拷贝进容器时，它所特有的部分（即派生类中的信息）将会丢失。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Widget&gt; vw;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialWidget</span>:</span><span class="comment">// SpecialWidget 继承于上面的 Widget</span></span><br><span class="line"><span class="keyword">public</span> Widget&#123;...&#125;;</span><br><span class="line">SpecialWidget sw;</span><br><span class="line">vw.<span class="built_in">push_back</span>();<span class="comment">// sw 作为基类对象被拷贝进 vw 中</span></span><br><span class="line"><span class="comment">// 它的派生类特有部分在拷贝时被丢掉了</span></span><br></pre></td></tr></table></figure><ul><li><strong>剥离意味着向基类对象中的容器中插入派生类对象几乎总是错误的</strong>。</li><li>解决剥离问题的简单方法：使容器包含<strong>指针</strong>而不是对象。</li></ul></li></ul><h2 id="第-4-条：调用-empty-而不是检查-size-是否为0。"><a href="#第-4-条：调用-empty-而不是检查-size-是否为0。" class="headerlink" title="第 4 条：调用 empty 而不是检查 size()是否为0。"></a>第 4 条：调用 empty 而不是检查 size()是否为0。</h2><ul><li><p>empty 通常被实现为内联函数（inline function），并且它做的仅仅是返回 size 是否为 0.</p></li><li><p>empty 对所有标准容器都是常数时间操作，而对于一些 list 实现，size 耗费线性时间。</p></li></ul><h2 id="第-5-条：区间成员函数优先于与之对应的单元素成员函数。"><a href="#第-5-条：区间成员函数优先于与之对应的单元素成员函数。" class="headerlink" title="第 5 条：区间成员函数优先于与之对应的单元素成员函数。"></a>第 5 条：区间成员函数优先于与之对应的单元素成员函数。</h2><p>小测验：给定 v1 和 v2 两个向量，使 v1 的内容和 v2 <strong>后半部分</strong>相同的最简单操作是什么？</p><p>​    <code>v1.assign(v2.begin() + v2.size() / 2, v2.end());</code></p><ul><li>TIP：<code>assign</code> 存在于所有的标准序列容器（vector，string，deque，list）中，<strong>当你需要完全替换一个容器的内容时，应该想到赋值（assignment）</strong>。</li><li>使用区间成员函数的原因：少写一些代码；得到意图清晰和更加直接的代码；更高的效率。</li></ul><p>把一个 int 数组拷贝到一个 vector 的前端（P22）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> data[numValues];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">...</span><br><span class="line">v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>(), data, data + numValues);<span class="comment">// 使用区间形式的 insert</span></span><br></pre></td></tr></table></figure><p>C++标准要求区间 insert 函数把现有容器中的元素<strong>直接移动到它们最终的位置上</strong>，即只需付出<strong>每个元素移动一次</strong>的代价。</p><p>支持区间的成员函数：</p><ul><li><p>区间创建：所有的标准容器都提供以下形式的构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">container::<span class="built_in">container</span>(InputIterator begin,<span class="comment">// 区间开始</span></span><br><span class="line">                    InputIterator end)<span class="comment">// 区间结束</span></span><br></pre></td></tr></table></figure></li><li><p>区间插入：所有的标准序列容器都提供以下形式的 insert：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">container::insert</span><span class="params">(iterator position,<span class="comment">// 在何处插入区间</span></span></span></span><br><span class="line"><span class="params"><span class="function">                      InputIterator begin,<span class="comment">// 区间开始</span></span></span></span><br><span class="line"><span class="params"><span class="function">                      InputIterator end)</span><span class="comment">// 区间结束</span></span></span><br></pre></td></tr></table></figure><p>关联容器：<code>void container::insert(InputIterator begin, InputIterator end);</code></p></li><li><p>区间删除：所有的标准容器都提供了区间形式的删除（erase）操作。</p><p>序列容器：<code>iterator container::erase(iterator begin, iterator end);</code></p><p>关联容器：<code>void container::erase(iterator begin, iterator end);</code></p></li></ul><h2 id="第-6-条：当心-C-编译器最烦人的分析机制。"><a href="#第-6-条：当心-C-编译器最烦人的分析机制。" class="headerlink" title="第 6 条：当心 C++ 编译器最烦人的分析机制。"></a>第 6 条：当心 C++ 编译器最烦人的分析机制。</h2><p><strong>围绕参数名的括号</strong>会被忽略，而<strong>独立的括号</strong>则表明参数列表的存在（存在一个函数指针参数）。</p><p>C++中一条普遍规律：尽可能地解释为函数声明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将一个含有整数的文件复制到一个list中。</span></span><br><span class="line"><span class="function">ifstream <span class="title">dataFile</span><span class="params">(<span class="string">&quot;ints.dat&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">list&lt;<span class="keyword">int</span>&gt; <span class="title">data</span><span class="params">(istream_iterator&lt;<span class="keyword">int</span>&gt;(dataFile),<span class="comment">// dataFile两边的括号会被忽略</span></span></span></span><br><span class="line"><span class="params"><span class="function">              istream_iterator&lt;<span class="keyword">int</span>&gt;())</span></span>;<span class="comment">// 函数指针</span></span><br><span class="line"><span class="comment">// 上式声明了一个函数，而不是初始化对象！</span></span><br></pre></td></tr></table></figure><h2 id="第-7-条：如果容器中包含了通过-new-操作创建的指针，切记在容器对象析构前将指针-delete-掉。"><a href="#第-7-条：如果容器中包含了通过-new-操作创建的指针，切记在容器对象析构前将指针-delete-掉。" class="headerlink" title="第 7 条：如果容器中包含了通过 new 操作创建的指针，切记在容器对象析构前将指针 delete 掉。"></a>第 7 条：如果容器中包含了通过 new 操作创建的指针，切记在容器对象析构前将指针 delete 掉。</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;Widget*&gt; vwp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOME_MAGIC_NUMBER; ++i)</span><br><span class="line">        vwp.<span class="built_in">push_back</span>(<span class="keyword">new</span> Widget);</span><br><span class="line">    ...<span class="comment">// 使用 vwp  </span></span><br><span class="line">&#125;<span class="comment">// 这里发生 Widget 泄露</span></span><br></pre></td></tr></table></figure><p>当你使用指针的容器，而其中的指针应该被删除时，为了避免资源泄露，你必须或者用引用计数形式的智能指针对象（比如 Boost 的 shared_ptr）代替指针，或者当容器被析构时手工删除其中的每个指针。</p><p>使用 for_each 和 delete 函数对象来解决这个问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DeleteObject</span>&#123;</span><span class="comment">// 这里去掉了模板化和基类</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// 在这里加入模板化</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T* ptr)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deque&lt;SpecialString*&gt; dssp;</span><br><span class="line">    for_each(dssp.<span class="built_in">begin</span>(), dssp.<span class="built_in">end</span>(),</span><br><span class="line">            <span class="built_in">DeletObject</span>());<span class="comment">// 确定的行为，但不是异常安全的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用智能指针来解决这个问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> boost::shared_ptr&lt;Widget&gt; SPW;<span class="comment">// SPW = 指向 Widget 的 shared_ptr</span></span><br><span class="line">    </span><br><span class="line">    vector&lt;SPW&gt; vwp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOME_MAGIC_NUMBER; ++i)</span><br><span class="line">        vwp.<span class="built_in">push_back</span>(<span class="built_in">SPW</span>(<span class="keyword">new</span> Widget));</span><br><span class="line">    ...<span class="comment">// 使用vwp </span></span><br><span class="line">&#125;<span class="comment">// 这里不会有Widget泄露，即使上面的代码有异常被抛出。</span></span><br></pre></td></tr></table></figure><h2 id="第-8-条：请勿创建包含-auto-ptr-的容器对象"><a href="#第-8-条：请勿创建包含-auto-ptr-的容器对象" class="headerlink" title="第 8 条：请勿创建包含 auto_ptr 的容器对象"></a>第 8 条：请勿创建包含 auto_ptr 的容器对象</h2><p>auto_ptr 的容器（COAP）是被禁止的，试图使用它们的代码不会被编译通过。</p><p>复制一个 auto_ptr 时，它所指向的对象的所有权被移交到复制的 auto_ptr 上，而它自身被置为 NULL。<strong>复制一个 auto_ptr 意味着改变它的值</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;auto_ptr&lt;Widget&gt; &gt; widgets;</span><br><span class="line"><span class="built_in">sort</span>(widgets.<span class="built_in">begin</span>(), widgets.<span class="built_in">end</span>(),</span><br><span class="line">    <span class="built_in">widgetAPcompare</span>());<span class="comment">//对vector所做的排序操作可能会改变它的内容！</span></span><br></pre></td></tr></table></figure><h2 id="第-9-条：慎重选择删除元素的方法"><a href="#第-9-条：慎重选择删除元素的方法" class="headerlink" title="第 9 条：慎重选择删除元素的方法"></a>第 9 条：慎重选择删除元素的方法</h2><h3 id="删除容器中有特定值的所有对象"><a href="#删除容器中有特定值的所有对象" class="headerlink" title="删除容器中有特定值的所有对象"></a>删除容器中有特定值的所有对象</h3><p>对标准容器 <code>Container&lt;int&gt;c;</code> 删除其中所有值为 1963 的元素的方法。</p><p><strong>erase-remove 习惯用法</strong>（连续内存容器 vector，deque，string）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.<span class="built_in">erase</span>(<span class="built_in">remove</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), <span class="number">1963</span>), c.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><p>list：<code>c.remove(1963);</code> </p><p>关联容器：<code>c.erase(1963);</code> 对数时间开销，基于等价而不是相等。注意关联容器没有名为 remove 的成员函数，使用任何名为 remove 的操作都是完全错误的。</p><h3 id="删除容器中满足特定判别式（条件）的所有对象"><a href="#删除容器中满足特定判别式（条件）的所有对象" class="headerlink" title="删除容器中满足特定判别式（条件）的所有对象"></a>删除容器中满足特定判别式（条件）的所有对象</h3><p>删除使下面的判别式返回 true 的每一个对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">badValue</span><span class="params">(<span class="keyword">int</span> )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列容器(vector,string,deque,list)</span></span><br><span class="line">c.<span class="built_in">erase</span>(<span class="built_in">remove_if</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), badValue), c.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// list</span></span><br><span class="line">c.<span class="built_in">remove_if</span>(badValue);</span><br></pre></td></tr></table></figure><p>对于标准关联容器，则没有这么直截了当。</p><p>简单但效率稍低的办法：利用 remove_copy_if 把我们需要的值复制到一个新容器中，然后把原来容器的内和新容器的内容相互交换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AssocContainer&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">...</span><br><span class="line">AssocContainer&lt;<span class="keyword">int</span>&gt; goodValues;<span class="comment">// 保持不被删除的值的临时容器</span></span><br><span class="line"><span class="built_in">remove_copy_if</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), <span class="built_in">inserter</span>(goodValues, goodValues.<span class="built_in">end</span>()), badValue);</span><br><span class="line">c.<span class="built_in">swap</span>(goodValues);</span><br></pre></td></tr></table></figure><p>高效方法：写一个循环遍历容器中的元素，并在遍历过程中删除元素。注意，对于关联容器（map，set，multimap，multiset），<strong>删除当前的 iterator，只会使当前的 iterator 失效</strong>。</p><p>原因：关联容器的底层使用<strong>红黑树</strong>实现，插入、删除一个结点不会对其他结点造成影响。erase 只会使被删除元素的迭代器失效。关联容器的 erase 返回值为 <strong>void</strong>，可以使用 <strong>erase(iter++)</strong> 的方式删除迭代器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AssocContainer&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">ofstream logFile;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (AssocContainer&lt;<span class="keyword">int</span>&gt;::iterator i = c.<span class="built_in">begin</span>(); i != c.<span class="built_in">end</span>(); <span class="comment">/*什么也不做*/</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">badValue</span>(*i)) </span><br><span class="line">    &#123;</span><br><span class="line">        logFile &lt;&lt; <span class="string">&quot;Erasing &quot;</span> &lt;&lt; *i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;<span class="comment">// 写日志文件</span></span><br><span class="line">        c.<span class="built_in">erase</span>(i++);<span class="comment">// 使用后缀递增删除元素，避免迭代器无效。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于序列式容器（vector，string，deque），<strong>删除当前的 iterator 会使后面所有元素的 iterator 都失效</strong>。</p><p>原因： vector、string、deque 使用了<strong>连续分配的内存</strong>，删除一个元素会导致后面的所有元素都向前移动一个位置。所以不能使用 erase(iter++) 的方式，<strong>但可以使用 erase 方法，序列容器的 erase 可以返回下一个有效的 iterator</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (SeqContainer&lt;<span class="keyword">int</span>&gt;::iterator i = c.<span class="built_in">begin</span>(); i != c.<span class="built_in">end</span>(); )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">badValue</span>(*i))</span><br><span class="line">    &#123;</span><br><span class="line">logFile &lt;&lt; <span class="string">&quot;Erasing &quot;</span> &lt;&lt; *i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        i = c.<span class="built_in">erase</span>(i);<span class="comment">// 把erase的返回值赋给i，使i的值保持有效。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第-10-条：了解分配子（allocator）的约定和限制"><a href="#第-10-条：了解分配子（allocator）的约定和限制" class="headerlink" title="第 10 条：了解分配子（allocator）的约定和限制"></a>第 10 条：了解分配子（allocator）的约定和限制</h2><p>分配子最初是作为内存模型的抽象而产生的。</p><p>编写自定义的分配子，需要记住哪些内容：</p><ul><li>分配子是一个模板，模板参数 T 代表你为它分配内存的对象类型。</li><li>提供类型定义 pointer 和 reference，但是始终让 pointer 为 T*，reference 为 T&amp;。</li><li>千万别让你的分配子拥有随对象而不同的状态（per-object state）。通常，分配子不应该有非静态的数据成员。</li><li>传给分配子的 allocate 成员函数的是那些要求内存的<strong>对象的个数</strong>，而<strong>不是所需的字节数</strong>。同时要记住，这些函数返回 T* 指针（通过 pointer 类型定义），即使尚未有 T 对象被构造出来。</li><li>一定要提供嵌套的 rebind 模板，因为标准容器依赖该模板。（P42）</li></ul><h2 id="第-11-条：理解自定义分配子的合理用法。"><a href="#第-11-条：理解自定义分配子的合理用法。" class="headerlink" title="第 11 条：理解自定义分配子的合理用法。"></a>第 11 条：理解自定义分配子的合理用法。</h2><h2 id="第-12-条：切勿对-STL-容器的线程安全性有不切实际的依赖。"><a href="#第-12-条：切勿对-STL-容器的线程安全性有不切实际的依赖。" class="headerlink" title="第 12 条：切勿对 STL 容器的线程安全性有不切实际的依赖。"></a>第 12 条：切勿对 STL 容器的线程安全性有不切实际的依赖。</h2><p>STL 只支持以下多线程标准：</p><ul><li>多个线程读是安全的。</li><li>多个线程对不同的容器做写入操作是安全的。</li></ul><p>你不能指望 STL 库会把你从手工同步控制中解脱出来，而且你不能依赖于任何线程支持。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-容器&quot;&gt;&lt;a href=&quot;#1-容器&quot; class=&quot;headerlink&quot; title=&quot;1 容器&quot;&gt;&lt;/a&gt;1 容器&lt;/h1&gt;</summary>
    
    
    
    <category term="C++" scheme="https://tommyplayer-c.github.io/categories/C/"/>
    
    
    <category term="STL" scheme="https://tommyplayer-c.github.io/tags/STL/"/>
    
  </entry>
  
</feed>

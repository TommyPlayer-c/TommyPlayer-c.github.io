<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>网络编程笔记(一)-基本TCP套接字编程 - Keep moving</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="TommyPlayer"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="TommyPlayer"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="网络编程笔记(一)-基本TCP套接字编程  参考《UNIX网络编程》1 - 4 章，《TCP&amp;#x2F;IP网络编程》1 - 5 章。"><meta property="og:type" content="blog"><meta property="og:title" content="网络编程笔记(一)-基本TCP套接字编程"><meta property="og:url" content="https://tommyplayer-c.github.io/2021/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%B8%80-%E5%9F%BA%E6%9C%ACTCP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/"><meta property="og:site_name" content="Keep moving"><meta property="og:description" content="网络编程笔记(一)-基本TCP套接字编程  参考《UNIX网络编程》1 - 4 章，《TCP&amp;#x2F;IP网络编程》1 - 5 章。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/qin-haonan/my-picture/raw/master/202110091547452.png"><meta property="og:image" content="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548958.png"><meta property="og:image" content="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548322.png"><meta property="og:image" content="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548850.png"><meta property="og:image" content="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548054.png"><meta property="og:image" content="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548474.png"><meta property="og:image" content="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548064.png"><meta property="og:image" content="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548077.png"><meta property="og:image" content="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548683.png"><meta property="og:image" content="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548944.png"><meta property="og:image" content="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548558.png"><meta property="og:image" content="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548420.png"><meta property="og:image" content="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548687.png"><meta property="og:image" content="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548376.png"><meta property="og:image" content="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548125.png"><meta property="og:image" content="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548355.png"><meta property="og:image" content="https://gitee.com/qin-haonan/my-picture/raw/master/202110091549622.png"><meta property="og:image" content="https://gitee.com/qin-haonan/my-picture/raw/master/202110091549617.png"><meta property="og:image" content="https://gitee.com/qin-haonan/my-picture/raw/master/202110091549099.png"><meta property="og:image" content="https://gitee.com/qin-haonan/my-picture/raw/master/202110091549464.jpg"><meta property="og:image" content="https://gitee.com/qin-haonan/my-picture/raw/master/202110091549688.png"><meta property="article:published_time" content="2021-09-29T16:00:00.000Z"><meta property="article:modified_time" content="2021-10-24T09:01:24.429Z"><meta property="article:author" content="TommyPlayer"><meta property="article:tag" content="linux 网络编程"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://gitee.com/qin-haonan/my-picture/raw/master/202110091547452.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://tommyplayer-c.github.io/2021/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%B8%80-%E5%9F%BA%E6%9C%ACTCP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/"},"headline":"网络编程笔记(一)-基本TCP套接字编程","image":["https://gitee.com/qin-haonan/my-picture/raw/master/202110091547452.png","https://gitee.com/qin-haonan/my-picture/raw/master/202110091548958.png","https://gitee.com/qin-haonan/my-picture/raw/master/202110091548322.png","https://gitee.com/qin-haonan/my-picture/raw/master/202110091548850.png","https://gitee.com/qin-haonan/my-picture/raw/master/202110091548054.png","https://gitee.com/qin-haonan/my-picture/raw/master/202110091548474.png","https://gitee.com/qin-haonan/my-picture/raw/master/202110091548064.png","https://gitee.com/qin-haonan/my-picture/raw/master/202110091548077.png","https://gitee.com/qin-haonan/my-picture/raw/master/202110091548683.png","https://gitee.com/qin-haonan/my-picture/raw/master/202110091548944.png","https://gitee.com/qin-haonan/my-picture/raw/master/202110091548558.png","https://gitee.com/qin-haonan/my-picture/raw/master/202110091548420.png","https://gitee.com/qin-haonan/my-picture/raw/master/202110091548687.png","https://gitee.com/qin-haonan/my-picture/raw/master/202110091548376.png","https://gitee.com/qin-haonan/my-picture/raw/master/202110091548125.png","https://gitee.com/qin-haonan/my-picture/raw/master/202110091548355.png","https://gitee.com/qin-haonan/my-picture/raw/master/202110091549622.png","https://gitee.com/qin-haonan/my-picture/raw/master/202110091549617.png","https://gitee.com/qin-haonan/my-picture/raw/master/202110091549099.png","https://gitee.com/qin-haonan/my-picture/raw/master/202110091549464.jpg","https://gitee.com/qin-haonan/my-picture/raw/master/202110091549688.png"],"datePublished":"2021-09-29T16:00:00.000Z","dateModified":"2021-10-24T09:01:24.429Z","author":{"@type":"Person","name":"TommyPlayer"},"publisher":{"@type":"Organization","name":"Keep moving","logo":{"@type":"ImageObject","url":{"text":"丢掉幻想，准备斗争"}}},"description":"网络编程笔记(一)-基本TCP套接字编程  参考《UNIX网络编程》1 - 4 章，《TCP&#x2F;IP网络编程》1 - 5 章。"}</script><link rel="canonical" href="https://tommyplayer-c.github.io/2021/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%B8%80-%E5%9F%BA%E6%9C%ACTCP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Keep moving" type="application/atom+xml">
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">丢掉幻想，准备斗争</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-09-29T16:00:00.000Z" title="2021/9/30 上午12:00:00">2021-09-30</time>发表</span><span class="level-item"><time dateTime="2021-10-24T09:01:24.429Z" title="2021/10/24 下午5:01:24">2021-10-24</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span><span class="level-item">1 小时读完 (大约9170个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">网络编程笔记(一)-基本TCP套接字编程</h1><div class="content"><h1 id="网络编程笔记-一-基本TCP套接字编程"><a href="#网络编程笔记-一-基本TCP套接字编程" class="headerlink" title="网络编程笔记(一)-基本TCP套接字编程"></a>网络编程笔记(一)-基本TCP套接字编程</h1><blockquote>
<p> 参考《UNIX网络编程》1 - 4 章，《TCP/IP网络编程》1 - 5 章。</p>
</blockquote>
<span id="more"></span>

<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><p><strong>守护进程</strong>（daemon）：一般认为 Web 服务器程序是一个长时间运行的程序，它只在响应来自网络的请求时才发送网络消息。守护进程能在后台运行且不跟任何终端关联。</p>
</li>
<li><p>TCP 套接字的花哨名字：网际（AF_INET）字节流（SOCK_STREAM）套接字</p>
</li>
<li><p>时间获取服务器的众所周知端口：13</p>
</li>
<li><p>协议无关性：</p>
<p>将 IPv4 修改为 IPv6 协议</p>
<ul>
<li>sockaddr_in ——&gt; sockaddr_in6</li>
<li>AF_INET ——&gt; AF_INET6</li>
<li>sin_port ——&gt; sin6_port</li>
</ul>
<p>更好的做法是编写协议无关程序。</p>
</li>
<li><p>包裹函数</p>
<p>weapper function。在本书中，约定包裹函数名是实际函数名的首字母<strong>大写形式</strong>。每个包裹函数完成实际的函数调用，检查返回值，并在错误时终止进程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Socket</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span>( (n = <span class="built_in">socket</span>(family, type, protocol)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Unix <strong>errno</strong> 值：只要有一个 UNIX 函数中有错误发生，全局变量 errno 就被置为一个指明该错误类型的正值，函数本身则通常返回 -1。err_sys（作者定义的）查看 errno 变量的值并输出相应的出错信息。</p>
</li>
<li><p>服务器种类：</p>
<ul>
<li><p>迭代服务器：对于每个客户都迭代执行一次</p>
</li>
<li><p>并发服务器：同时处理多个客户（Unix 的 fork 函数，用线程替代 fork 等）</p>
</li>
</ul>
</li>
<li><p>国际标准化组织（International Organization for Standardization，ISO）的计算机通信开放系统互连模型（open systems interconnection，OSI），是一个七层模型。</p>
<p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091547452.png" alt="image-20211004151149492"><br>物理层/数据链路层：随系统提供的设备驱动程序和网络硬件。</p>
<p>网络层：由 IPv4 和 IPv6 这两个协议处理。在附录 A 中讲述。</p>
<p>传输层：即本书所讲的套接字编程接口，从应用层(上3层)进入传输层的接口。</p>
<p>会话层/表示层/应用层：OSI 的顶上三层被合并为一层，称为应用层。Web 客户端（浏览器)、Telnet 客户、web 服务器、FTP 服务器等在这层。</p>
<p>《Unix 网络编程》讲述的套接字编程接口是从顶上三层（网际协议的应用层）进入传输层的接口，重点关注如何使用套接字编写使用 TCP 或 UDP 的网络应用程序。</p>
<p>套接字提供的是从OSI模型的顶上三层进入传输层的接口，这里设计有两个原因：</p>
<ul>
<li>理由一：顶上三层处理具体网络应用（如 FTP、Telnet 或 HTTP）的所有细节，却对通信细节了解很少；底下四层对具体网络应用了解不多，却处理所有的通信细节：发送数据，等待确认，给无序到达的数据排序，计算并验证校验和等等。</li>
<li>理由二：顶上三层通常构成所谓的用户进程（user process），底下四层却通常作为操作系统内核的一部分提供。Unix 与其他现代操作系统都提供分隔用户进程与内核进程的机制。由此可见，<u>第 4 层和第 5 层之间的接口是构建 API 的自然位置</u>。</li>
</ul>
</li>
<li><p>POSIX（Portable  Operating System Interface，可移植操作系统接口）</p>
<ul>
<li>64 位体系结构：LP64 模型中，长整数（L）和指针（P）都占用 64 位。</li>
</ul>
</li>
</ul>
<h3 id="相关-linux-指令"><a href="#相关-linux-指令" class="headerlink" title="相关 linux 指令"></a>相关 linux 指令</h3><ol>
<li><p><code>netstat -ni</code>：提供网络接口信息，-n 输出数值地址而不是反向解析为名字。其中 loopback 接口称为 lo，以太网接口称为 eth0（这里是 ens33）。</p>
<p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548958.png" alt="image-20211004152710613"></p>
</li>
<li><p><code>netstat -nr</code>：查看路由表</p>
<p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548322.png" alt="image-20211004153659445"></p>
</li>
<li><p><code>ifconfig ens33</code>：获得 ens33 以太网接口的详细信息</p>
<p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548850.png" alt="image-20211004153901168"></p>
</li>
<li><p><code> ping -b 192.168.200.255</code>：对本地接口的广播地址执行 ping ，可以找到本地网络中其他主机的 IP 地址。</p>
</li>
<li><p>Linux ps（英文全拼：process status）命令用于显示当前进程的状态，类似于 windows 的任务管理器</p>
</li>
</ol>
<ol start="6">
<li>grep：Global regular expression print</li>
</ol>
<h3 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h3><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548054.png" alt="image-20211009090554559"></p>
<ul>
<li><p>TCP 提供面向连接的、可靠的、排序、流量控制、全双工的数据传送服务。</p>
</li>
<li><p>UDP 提供无连接的、不可靠的、尽力服务。发送给接收进程的数据有可能丢失，也有可能错序。</p>
</li>
<li><p>SCTP：流控制传输协议。提供可靠全双工<strong>关联</strong>的面向连接的协议。</p>
<p>使用关联来指代 SCTP 的连接：一个连接只涉及两个 IP 地址之间的通信，一个关联指代两个系统之间的一次通信。</p>
<ul>
<li>SCTP 是<strong>多宿</strong>的，单个 SCTP 端点能够支持多个 IP 地址。</li>
<li>SCTP 面向消息，它提供各个记录的按序递送服务。</li>
</ul>
</li>
</ul>
<h4 id="TCP-的建立和终止"><a href="#TCP-的建立和终止" class="headerlink" title="TCP 的建立和终止"></a>TCP 的建立和终止</h4><p>TCP 三路握手建立连接：</p>
<img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548474.png" alt="image-20211009092049576" style="zoom: 67%;" />

<ol>
<li>服务器<strong>被动打开</strong> (passive open)：服务器调用 socket、bind、litsen 函数，准备好接受外来连接。</li>
<li>客户<strong>主动打开</strong> (active open)：客户调用 connext，发送 SYN 报文，告诉对方初始序号。通常 SYN 报文不携带数据，其所在的 IP 数据报只包含一个 IP 首部、一个 TCP 首部和可能有的TCP选项。</li>
<li>服务器必须确认（ACK）客户的 SYN：服务器在单个分节中，发送自己要发送数据的初始序列号 SYN 和对客户 SYN 的确认（ACK）。</li>
<li>客户必须确认服务器的 SYN，发送 ACK。</li>
</ol>
<p>TCP选项：</p>
<ul>
<li>MSS 选项：通告对端自己的最大报文段长度（maximum segment size）</li>
<li>窗口规模选项：通告对端的最大窗口大小（advertised window size）为 65535(16 bits)，但现在要求更大的窗口，必须左移 0~14 位。</li>
<li>时间戳选项：防止失而复现的分组可能造成的数据损坏。窗口规模选项和时间戳选项也称<strong>长肥管道选项</strong>。</li>
</ul>
<p>TCP 四路握手释放连接：</p>
<img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548064.png" alt="image-20211009093305378" style="zoom:67%;" />

<ol>
<li><strong>主动关闭</strong> (active close)：某个应用进程首先调用 close，发送一个 FIN 分节表示自己的数据发送完毕。</li>
<li><strong>被动关闭</strong> (passive close)：TCP 确认这个 FIN，<u>它的接收也作为一个文件结束符（EOF）传递给接收端应用进程</u>（FIN 意味着无额外数据可接收）。</li>
<li>一段时间后，接收 FIN 的进程将会调用 close 关闭自己的套接字，它的 TCP 也发送一个FIN。</li>
<li>接收到最终 FIN 的原发送端 TCP 确认这个 FIN。</li>
</ol>
<p><strong>半关闭</strong> (half-close)：被动关闭一端向主动关闭一端流动数据。</p>
<p>当一个 Unix 进程不论自愿地（调用 exit 或从 main 函数返回）还是非自愿地（收到一个终止本进程的信号）终止时，所有打开的描述符都被关闭，这也导致仍然打开的任何 TCP 连接上也发出一个 FIN。</p>
<h4 id="TCP-状态转移图"><a href="#TCP-状态转移图" class="headerlink" title="TCP 状态转移图"></a>TCP 状态转移图</h4><p>理解状态转换图是使用 netstat 命令诊断网络问题的基础。</p>
<p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548077.png" alt="image-20211009122724708"></p>
<h4 id="TIME-WAIT状态"><a href="#TIME-WAIT状态" class="headerlink" title="TIME_WAIT状态"></a>TIME_WAIT状态</h4><p>TIME_WAIT：停留在这个状态的持续时间是最长报文段生命期（maximum segment lifetime，MSL）的两倍，也称 2MSL。</p>
<p>TIME_WAIT 状态存在的两个理由：</p>
<ol>
<li>可靠地实现 TCP 全双工连接的终止：最终的 ACK 需要维护状态，比如 ACK 丢失需要重传，否则会响应 RST</li>
<li>允许老的重复报文段在网络中消逝：正确处理重复的分组——迷途的重复分组/漫游的重复分组。</li>
</ol>
<h4 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h4><p>端口的作用：</p>
<ol>
<li><p>  让应用层的各种应用进程将其数据通过端口 向下 交付给传输层</p>
</li>
<li><p>让传输层知道应当将其报文段中的数据 向上 通过端口交付给应用层相应的进程</p>
<p>  端口是传输层的服务访问点 (SAP)：数据链路层的 SAP 是 MAC 地址，网络层的 SAP 是 IP 地址，传输层的 SAP 是端口</p>
</li>
</ol>
<p>端口号：标识计算机应用层中的各进程</p>
<p>UDP 协议和 TCP 协议如何知道把收到的数据段交给哪个上层进程呢？利用数据段 (segment) 中的<strong>目的端口号</strong> (2个字节)</p>
<p>端口号分类：</p>
<ol>
<li><p>IANA 的<strong>知名端口</strong>（Well-known ports，也称众所周知端口）0~1023<br>为提供知名网络服务的系统进程所用。 例如: <u>20-ftp Data，21-ftp Control，23-telnet，</u><br><u>25-SMTP，53-DNS，69-TFTP，80-HTTP，110-POP3，161-SNMP</u>。</p>
<p>Unix 系统的保留端口（reserved port）指的是小于 1024 的任何端口，所有知名端口都是保留端口。</p>
</li>
<li><p>注册端口（Registered ports）1024~49151。在 IANA 注册的专用端口号，为企业软件所用。    </p>
</li>
<li><p>动态端口（Private ports）49152~65535。没有规定用途的端口号，一般用户可以随意使用。也称为私用或暂用端口号。</p>
</li>
</ol>
<h4 id="套接字-Socket"><a href="#套接字-Socket" class="headerlink" title="套接字 (Socket)"></a>套接字 (Socket)</h4><p>(1) 通过IP地址或域名找到主机： <a target="_blank" rel="noopener" href="http://www.baidu.com-&gt;36.152.44.96/">www.baidu.com-&gt;36.152.44.96</a></p>
<p>(2) 通过端口号找到主机上的进程</p>
<p>套接字是网络数据传输用的软件设备，网络编程又称套接字编程。</p>
<p>套接字函数是 TCP 协议的编程接口，每个 TCP 套接字都有自己的接收缓冲区和发送缓冲区。</p>
<p>一个 TCP 的套接字对是一个定义该连接的两个端点的四元组：本地 IP 地址、本地 TCP 端口号、外地 IP 地址、外地 TCP 端口号。<u>标识每个端点的两个值（IP 地址和端口号）通常称为一个<strong>套接字</strong></u>。</p>
<h4 id="TCP-端口号与并发服务器"><a href="#TCP-端口号与并发服务器" class="headerlink" title="TCP 端口号与并发服务器"></a>TCP 端口号与并发服务器</h4><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548683.png" alt="STEP1" style="zoom:67%;" />

<p>STEP1：该服务器主机是多宿的。<code>*:*</code> 表示监听套接字。</p>
<p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548944.png" alt="STEP2"></p>
<p>STEP2：客户主机选择临时端口 1500 连接服务器。</p>
<p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548558.png" alt="STEP3"></p>
<p>STEP3：我们必须区分已连接套接字和监听套接字。注意已连接套接字使用与监听套接字相同的本地端口（21）</p>
<p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548420.png" alt="STEP4"></p>
<p>STEP4：客户主机另一个客户使用临时端口 1501 连接同一个服务器。注意第一个连接的套接字对与第二个连接的套接字对不同，因为客户选择的临时端口号不同。</p>
<blockquote>
<p>必须查看套接字对的所有 4 个元素才能确定由哪个端点接收某个到达的分节，图 2-14 对于同一个本地端口（21）存在 3 个套接字。</p>
</blockquote>
<h2 id="网络地址结构"><a href="#网络地址结构" class="headerlink" title="网络地址结构"></a>网络地址结构</h2><h3 id="IPv4-套接字地址结构"><a href="#IPv4-套接字地址结构" class="headerlink" title="IPv4 套接字地址结构"></a>IPv4 套接字地址结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来存放因特网的 IP 地址和端口号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>		sin_family;			<span class="comment">// 地址族（Address Family）</span></span><br><span class="line">    <span class="keyword">uint16_t</span> 		sin_port;			<span class="comment">// 16位TCP/UDP端口号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> 			<span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>	<span class="comment">// 32位IP地址</span></span><br><span class="line">    <span class="keyword">char</span> 			sin_zero[<span class="number">8</span>];		<span class="comment">// 不使用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">in_addr_t</span> s_addr	<span class="comment">// 32位IPv4地址，整数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用的套接字地址结构，经常将sockaddr_in强制转换为sockaddr，它是bind函数的指针参数之一</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin_family;		<span class="comment">// 地址族（Address Family）</span></span><br><span class="line">    <span class="keyword">char</span>		sa_data[<span class="number">14</span>];	<span class="comment">// 地址信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example:</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span>	<span class="comment">// 直接向 sockaddr 填充地址信息很麻烦（要填充0）</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 类型强制转换    </span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">bind</span>(serv_sock, (struct sockaddr *)&amp;serv_addr, <span class="built_in"><span class="keyword">sizeof</span></span>(serv_addr)) == <span class="number">-1</span>)</span><br><span class="line">    <span class="built_in">error_handling</span>(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>sockaddr_in 参数分析：</p>
<ol>
<li>sin_family：地址族，AF_INET（IPV4网络协议中使用的地址族），AF_INET6（IPV6网络协议中使用的地址族），AF_LOCAL（本地通信中采用的UNIX协议的地址族）。</li>
<li>sin_port：以网络字节序保存 <strong>16</strong> 位端口号。</li>
<li>sin_addr：以网络字节序保存 <strong>32</strong> 位地址信息。</li>
<li>sin_zero：使结构体 sockaddr_in 的大小与结构体 <strong>sockaddr</strong> 保持一致而插入的成员，<strong>必须填充 0</strong>.</li>
</ol>
<p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548687.png" alt="image-20210920085002811"></p>
<p>注意点：</p>
<ul>
<li><p>32 位 IPv4 地址存在两种不同访问方法：</p>
<ul>
<li> <code>serv.sin_addr</code> 按照 <code>in_addr</code> <strong>结构</strong>来引用地址。</li>
<li> <code>serv.sin_addr.s_addr</code>  按照 <code>in_addr_t</code>（通常是一个无符号位的 32 位<strong>整数</strong>）来引用地址。</li>
</ul>
<p>必须正确使用 IPv4 地址，尤其是它作为函数参数时，因为编译器对<strong>传递结构</strong>和<strong>传递整数</strong>的处理是完全不同的。</p>
</li>
<li><p>sin_zero 字段未曾使用，总是把它置为 0。按照惯例，我们总是在填写结构体之前，把整个结构体都置为 0。<u>使用 <code>bzero()</code> 函数</u></p>
</li>
<li><p>socket 地址结构仅在给定主机上使用：虽然某些字段（例如IP地址和端口号）用在不同主机之间的通信中，<u>但是结构本身是不会在主机上传递的</u>。</p>
</li>
</ul>
<h3 id="IPv6-套接字地址结构"><a href="#IPv6-套接字地址结构" class="headerlink" title="IPv6 套接字地址结构"></a>IPv6 套接字地址结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span>&#123;</span></span><br><span class="line">    <span class="keyword">unit8_t</span>		s6_addr[<span class="number">16</span>];	<span class="comment">/* 128位IPv6地址 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIN6_LEN</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>	<span class="title">sockaddr_in6</span>&#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span>			sin6_len;			<span class="comment">// 结构体长度（28）</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>		sin6_family;		<span class="comment">// AF_INET6</span></span><br><span class="line">    <span class="keyword">in_port_t</span>		sin6_port;</span><br><span class="line">    <span class="keyword">uint32_t</span>		sin6_flowinfo;		<span class="comment">// 流信息，它的使用依然是一个课题</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span>	<span class="title">sin6_addr</span>;</span>			<span class="comment">// IPv6地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span>		sin6_scope_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新的通用的套接字地址结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span>&#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span>		ss_len;</span><br><span class="line">    <span class="keyword">sa_family_t</span>	ss_family;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>新的 struct sockaddr_storage <u>足以容纳系统所支持的任意套接字地址结构</u>。</p>
<ol>
<li><p>如果系统支持的任何套接字地址结构有对齐需要，那么 sockaddr_storage 能够满足最苛刻的对齐要求。</p>
</li>
<li><p>sockaddr_storage 足够大，能够容纳系统支持的任何套接字地址结构。</p>
</li>
</ol>
<p>注：除了上面呈现的两个字段外，其他字段对于用户是透明的，需要对 sockaddr_storage 进行类型强制转换后才能够访问其他字段。</p>
<h3 id="网络字节序和主机字节序"><a href="#网络字节序和主机字节序" class="headerlink" title="网络字节序和主机字节序"></a>网络字节序和主机字节序</h3><h4 id="字节排序函数"><a href="#字节排序函数" class="headerlink" title="字节排序函数"></a>字节排序函数</h4><p>主机字节序（Host Byte Order）——CPU 在内存中存储数据的方式：</p>
<ul>
<li><p>大端序（Big Endian）：高位字节存放到低位地址。</p>
<img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548376.png" alt="image-20210920090820279" style="zoom: 67%;" /></li>
<li><p>小端序（Little Endian）：高位字节存放到高位地址。</p>
<img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548125.png" alt="image-20210920090842486" style="zoom:67%;" /></li>
</ul>
<p>因特网的<strong>网络字节序</strong> (Network Byte Order) 采用大端序，即<strong>先发送高位字节</strong>。例如，发送 0x66020304 的网络序为 04 03 02 66（最右边的最先发送）</p>
<p><strong>字节序转换</strong>（Endian Conversations）：在填充 sockaddr_in 结构体前，先要将数据转换为网络字节序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h：主机字节序，n：网络字节序</span></span><br><span class="line"><span class="comment">// s代表short，16位，用于端口号转换。</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="title">htons</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> host)</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> net)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// l代表long，32位，用于IP地址转换。</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">htonl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> host)</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> net)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="字节操纵函数"><a href="#字节操纵函数" class="headerlink" title="字节操纵函数"></a>字节操纵函数</h4><p>名字以 b 开头的第一组函数起源于 4.2BSD：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：把目标字符串中指定数目的字节置为0，经常使用该函数把一个套接字地址结构初始化为0.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bzero</span> <span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bcopy</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">void</span> *dest, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bcmp</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr1, <span class="keyword">const</span> <span class="keyword">void</span> *ptr2, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure>

<p>名字以 mem 开头的第二组函数起源于 ANSI C 标准：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">// 记忆方法：dest = src;	长度参数总是最后一个参数。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span> <span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">int</span> c, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span> <span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">memcmp</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr1, <span class="keyword">const</span> <span class="keyword">void</span> *ptr2, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="地址转换函数"><a href="#地址转换函数" class="headerlink" title="地址转换函数"></a>地址转换函数</h4><p>点分十进制的字符串 –》32位网络字节序的二进制整数值：n 代表数值（numeric），a 代表地址（address）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：将转换结果（32位IP地址）直接保存在 in_addr 结构体中</span></span><br><span class="line"><span class="comment">// 返回值：成功时（字符串有效）返回1，失败时返回0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * string, struct in_addr * addr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：把 点分十进制的IP地址 转化为 32位IP地址。</span></span><br><span class="line"><span class="comment">// 返回值：成功时返回32位大端型整数值，失败时返回-1，可以检测无效的IP地址</span></span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * string)</span></span>;</span><br></pre></td></tr></table></figure>

<p>注意：inet_addr 已被废弃：该函数出错时返回 INADDR_NONE常值（通常是一个32位均为1的值），<u>有线广播地址 255.255.255.255 不能被该函数处理</u>！</p>
<p>32位网络字节序的二进制整数值 –》点分十进制的字符串：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：把 32位IP地址 转化为 点分十进制的IP地址</span></span><br><span class="line"><span class="comment">// 返回值：成功时返回转换后的 点分十进制数串的指针，失败时返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">inet_ntoa</span><span class="params">(struct in_addt adr)</span></span>;</span><br></pre></td></tr></table></figure>

<p>可用于 IPv4 和 IPv6 的地址转换函数：p 代表表达（presentation），n 代表数值（numeric）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：将strptr所指的字符串转换为数值，并通过addrptr指针存放二进制结果。</span></span><br><span class="line"><span class="comment">// 返回值：若成功则为1，若输入不是有效的表达格式则为0，若出错则为-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">const</span> <span class="keyword">char</span> *strptr, <span class="keyword">void</span> *addrptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：从数值格式（addrptr）转换到表达格式（strptr）</span></span><br><span class="line"><span class="comment">// 参数：len-目标存储单元的大小。</span></span><br><span class="line"><span class="comment">// 返回值：若成功则为指向结果的指针，若出错则为NULL</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">const</span> <span class="keyword">void</span> *addrptr, <span class="keyword">char</span> *strptr, <span class="keyword">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure>

<p>注：两个函数的 family 参数既可以是 AF_INET，也可以是 AF_INET6；如果以不被支持的地址族作为 family 参数，这两个函数就都返回一个错误，并将 errno 置为 EAFNOSUPPORT；</p>
<p>inet_ntop 函数的 strptr 参数不可以是一个空指针，调用者必须为目标存储单元分配内存并指定其大小，调用成功时，这个指针就是该函数的返回值。</p>
<h4 id="网络地址初始化"><a href="#网络地址初始化" class="headerlink" title="网络地址初始化"></a>网络地址初始化</h4><p>客户端：声明 sockaddr_in 结构体，并初始化要连接的服务器端套接字的 IP 地址和端口号，然后调用 connect 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line"><span class="keyword">char</span> *serv_ip = <span class="string">&quot;211.217.168.13&quot;</span></span><br><span class="line"><span class="keyword">char</span> *serv_port = <span class="string">&quot;9190&quot;</span>   </span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));			<span class="comment">// 结构体变量的所有成员初始化为0</span></span><br><span class="line">serv_addr.sin_family = AF_INET;					<span class="comment">// 指定地址族			</span></span><br><span class="line">serv_addr.sin_addr.s_addr = inet_addr(serv_ip);</span><br><span class="line">serv_addr.sin_port = htons(atoi(serv_port));	<span class="comment">// atoi--把ascii转化为int，htons—主机序到网络序		</span></span><br></pre></td></tr></table></figure>

<p>服务器：声明 sockaddr_in 结构体，初始化服务器端 IP 和端口号，可以使用 <strong>INADDR_ANY</strong> 自动获取服务器端的 IP 地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line"><span class="keyword">char</span> *serv_port = <span class="string">&quot;9190&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));			<span class="comment">// 结构体变量的所有成员初始化为0</span></span><br><span class="line">serv_addr.sin_family = AF_INET;					<span class="comment">// 指定地址族			</span></span><br><span class="line">serv_addr.sin_addr.s_addr = inet_addr(INADDR_ANY);	<span class="comment">// INADDR_ANY: 监听所有(接口的)IP地址</span></span><br><span class="line">serv_addr.sin_port = htons(atoi(serv_port));		<span class="comment">// atoi--把ascii转化为int，htons—主机序到网络序	</span></span><br></pre></td></tr></table></figure>



<h2 id="值-结果参数"><a href="#值-结果参数" class="headerlink" title="值-结果参数"></a>值-结果参数</h2><p>当向一个套接字函数传递一个套接字地址结构时，总是以引用传递，即传递的是一个<strong>指向结构的指针</strong>。该结构的长度也作为参数来传递，其传递的方式取决于该结构的传递的方向：从进程到内核，还是从内核到进程。</p>
<ol>
<li><p>从进程到内核传递的套接字结构有 3 个函数：bind、connect、sendto，这三个函数的一个参数是<u>指向套接字结构的指针，另一个是结构的大小</u>，如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv</span>;</span></span><br><span class="line">connect(sockfd, (SA *)&amp;serv, <span class="keyword">sizeof</span>(serv));</span><br></pre></td></tr></table></figure>

<p>指针和指针所指内容的大小都传递给了内核，于是内核知道需要从进程复制多少数据进来。</p>
<img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091548355.png" alt="image-20210920172240912" style="zoom:67%;" /></li>
<li><p>从内核到进程传递的套接字地址结构有四个函数：accept、recvfrom、getsockname、getpeername，这些函数其中两个参数是：<u>指向套接字结构的指针和指向表示结构大小的指针</u>，如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cli</span>;</span></span><br><span class="line"><span class="keyword">socklen_t</span> len;</span><br><span class="line"></span><br><span class="line">len = <span class="keyword">sizeof</span>(cli);</span><br><span class="line">getpeername(unixfd, (SA *)&amp;cli, &amp;len);</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091549622.png" alt="image-20210920172555963" style="zoom:67%;" />

<p>这种参数类型叫做<strong>值-结果参数</strong>：</p>
<ul>
<li>当函数被调用时，结构大小是一个<strong>值</strong>（value），它告诉<strong>内核</strong>该结构大小，这样内核在写该结构时不至于越界）。</li>
<li>当函数返回时，结构大小又是一个<strong>结果</strong>（result），它告诉<strong>进程内核</strong>在该结构中存储了多少信息。</li>
</ul>
<p>总结：当一个套接字函数需要填写一个结构时，该结构的长度也以引用形式传递，这样它的值也可以被函数更改。我们把这样的参数叫做值-结果参数。</p>
</li>
</ol>
<h2 id="书中自定义的读写函数"><a href="#书中自定义的读写函数" class="headerlink" title="书中自定义的读写函数"></a>书中自定义的读写函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span>	<span class="title">readn</span> <span class="params">(<span class="keyword">int</span> fildes, <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">written</span> <span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">const</span> <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readline</span> <span class="params">(<span class="keyword">int</span> fileds, <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> maxlen)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="readn-函数："><a href="#readn-函数：" class="headerlink" title="readn 函数："></a>readn 函数：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：从一个描述符读n字节</span></span><br><span class="line"><span class="comment">// 参数：fd-文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readn</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> nleft;	<span class="comment">// 剩余字节数</span></span><br><span class="line">    <span class="keyword">ssize_t</span> nread;	<span class="comment">// 一次read读取的字节数</span></span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">    ptr = buf;</span><br><span class="line">    nleft = n;</span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (nread = read(fd, ptr, nleft)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">                nread = <span class="number">0</span>; 	<span class="comment">/* call read() again */</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;         	<span class="comment">/* EOF */</span></span><br><span class="line">        &#125;</span><br><span class="line">        nleft -= nread;</span><br><span class="line">        ptr += nread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (n - nleft);		<span class="comment">/*return &gt;= 0*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="writen-函数："><a href="#writen-函数：" class="headerlink" title="writen 函数："></a>writen 函数：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：往一个描述符写n字节</span></span><br><span class="line"><span class="comment">// 参数：fd-文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">writen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> nleft;</span><br><span class="line">    <span class="keyword">ssize_t</span> nwritten;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">    ptr = vptr;</span><br><span class="line">    nleft = n;</span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (nwritten = write(fd, ptr, nleft)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nwritten &lt; <span class="number">0</span> &amp;&amp; errno == EINTR) &#123;</span><br><span class="line">                nwritten = <span class="number">0</span>; 	<span class="comment">/* call write() again */</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="number">-1</span>); 	<span class="comment">/* error */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        nleft -= nwritten;</span><br><span class="line">        ptr   += nwritten;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (n - nwritten);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="readline-函数："><a href="#readline-函数：" class="headerlink" title="readline 函数："></a>readline 函数：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：从一个描述符读文本行，一次一个字节，极端地慢</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readline</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> maxlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> n, rc;</span><br><span class="line">    <span class="keyword">char</span> c, *ptr;</span><br><span class="line"></span><br><span class="line">    ptr = vptr;</span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt;= maxlen; n++) &#123;</span><br><span class="line">        again:</span><br><span class="line">        <span class="keyword">if</span> ( (rc = read(fd, &amp;c, <span class="number">1</span>)) == <span class="number">1</span>) &#123;</span><br><span class="line">            *ptr++ = c;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">            *ptr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> (n - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">                <span class="keyword">goto</span> again;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *ptr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ((maxlen == (n<span class="number">-1</span>))?(n<span class="number">-1</span>):n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EINTR 错误：表示系统调用被一个捕获的信号中断，如果发生该错误则继续进行读/写操作。</p>
<p>注意，这个 readline 函数每读一个字节的数据就调用一次系统的 read 函数。这是非常低效的。改用标准I/O函数库可以解决性能问题，但是会引发许多后勤问题，因为 stdio 缓冲区的状态是不可见的。</p>
<p>下面是一个 readline 函数较快速的版本。但这会导致新的问题：使用静态变量实现跨域相继函数调用的状态信息维护，使函数变得<strong>不可重入</strong>或者说<strong>非线程安全</strong>了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> read_cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *read_ptr;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> read_buf[MAXLINE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">my_read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (read_cnt &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        again:</span><br><span class="line">        <span class="keyword">if</span> ( (read_cnt = read(fd, read_buf, <span class="keyword">sizeof</span>(read_buf))) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">                <span class="keyword">goto</span> again;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">-1</span>);            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (read_cnt == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        read_ptr = read_buf;</span><br><span class="line">    &#125;</span><br><span class="line">    read_cnt--;</span><br><span class="line">    *ptr = *read_ptr++;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readline</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> maxlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> n, rc;</span><br><span class="line">    <span class="keyword">char</span> c, *ptr;</span><br><span class="line"></span><br><span class="line">    ptr = vptr;</span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt; maxlen; n++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (rc = my_read(fd, &amp;c)) == <span class="number">1</span>) &#123;</span><br><span class="line">            *ptr++ = c;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            *ptr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> (n - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *ptr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readlinebuf</span><span class="params">(<span class="keyword">void</span> **vptrptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (read_cnt) &#123;</span><br><span class="line">        *vptrptr = read_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (read_cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="基本-TCP-套接字编程"><a href="#基本-TCP-套接字编程" class="headerlink" title="基本 TCP 套接字编程"></a>基本 TCP 套接字编程</h2><h3 id="socket-函数"><a href="#socket-函数" class="headerlink" title="socket 函数"></a>socket 函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：创建套接字（安装电话机）</span></span><br><span class="line"><span class="comment">// 返回值：成功时返回文件描述符，失败是返回-1。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example:</span></span><br><span class="line"><span class="keyword">int</span> tcp_socket = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"><span class="keyword">int</span> udp_socket = <span class="built_in">socket</span>(PF_INET, SOCK_DGRAM, IPPROTO_UDP);</span><br></pre></td></tr></table></figure>

<p>固定电话和套接字其实并无太大区别，下面会利用电话机讲解套接字的创建和使用方法。</p>
<p>输入参数：</p>
<ol>
<li><p>family：套接字中使用的地址簇 (Address Family) 或协议簇 (Protocol Family) 信息。 </p>
<ol>
<li>PF_UNSPEC (未定义)</li>
<li>PF_INET：IPv4</li>
<li>PF_INET6：IPv6</li>
<li>PF_LOCAL：本地通信的 UNIX 协议簇</li>
<li>PF_PACKET：底层套接字的协议簇</li>
</ol>
<p>注：PF 或 AF 开头的是相同的</p>
</li>
<li><p>type：套接字数据传输类型。</p>
<ol>
<li>SOCK_STREAM：流式（stream），面向连接的套接字，收发数据的套接字内部有缓冲（buffer，就是字节数组），用于 <strong>TCP 套接字</strong>。<ul>
<li>可靠的：传输过程中数据不会消失。</li>
<li>按序传递的：按序传输数据。</li>
<li>基于字节的：传输的数据<strong>不存在数据边界</strong>。</li>
</ul>
</li>
<li>SOCK_DGRAM：数据报（datagram），面向消息的套接字，不存在连接的概念，用于 <strong>UDP 套接字</strong>。<ul>
<li>不按序传递的，以数据的高速传输为目的：强调快速传输而非传输顺序。</li>
<li>不可靠的：传输的数据可能丢失也可能损毁。</li>
<li>传输的数据<strong>有数据边界</strong>。</li>
<li>限制每次传输的数据大小。</li>
</ul>
</li>
<li>SOCK_RAW (原始)</li>
</ol>
</li>
<li><p>protocol：计算机间通信使用的协议信息地址簇中的协议号。</p>
<ol>
<li>IPPROTO_TCP (TCP的协议号6) </li>
<li>IPPROTO_UDP (UDP的协议号17) </li>
<li>IPPROTO_ICMP (ICMP的协议号1)</li>
</ol>
</li>
</ol>
<h3 id="connect-函数"><a href="#connect-函数" class="headerlink" title="connect 函数"></a>connect 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：（客户端）建立与TCP服务器的连接</span></span><br><span class="line"><span class="comment">// 返回值：成功时返回0，失败时返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr * servaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>connect 函数导致当前套接字从 CLOSED 状态转移到 SYN_SENT 状态，若成功则再转移到 ESTABLISHED 状态。</p>
<h3 id="bind-函数"><a href="#bind-函数" class="headerlink" title="bind 函数"></a>bind 函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：将初始化后的地址信息绑定到套接字</span></span><br><span class="line"><span class="comment">// 参数：sockfd—套接字文件描述符，myaddr-存有地址信息的结构体变量地址，addrlen-结构体变量的长度</span></span><br><span class="line"><span class="comment">// 返回值：成功时返回0，失败时返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr * myaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>bind 把一个本地协议地址赋予一个套接字。<u>调用 bind 函数可以指定一个端口号，可以指定一个 IP 地址，也可以两者都指定，还可以都不指定</u>。</p>
<ul>
<li><p>如果指定端口号为 0，则内核在 bind 被调用时选择一个临时端口；</p>
</li>
<li><p>如果 IP 地址为通配地址，那么内核将等到套接字已连接（TCP）或已在套接字上发出数据报（UDP）时才选择一个本地 IP 地址。</p>
<p>通配地址由常值 INADDR_ANY 来指定，其值一般为 0，它告知内核去选择 IP 地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IPv4</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IPv6</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> <span class="title">serv</span>;</span></span><br><span class="line">serv.sin6_addr = in6addr_any;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="listen-函数（由-TCP-服务器调用）"><a href="#listen-函数（由-TCP-服务器调用）" class="headerlink" title="listen 函数（由 TCP 服务器调用）"></a>listen 函数（由 TCP 服务器调用）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：服务器进入等待连接请求的状态</span></span><br><span class="line"><span class="comment">// 参数：sock-一个未连接的套接字，将被转换为被动套接字，指示内核应接受指向该套接字的连接请求</span></span><br><span class="line"><span class="comment">//	backlog-连接请求队列的长度</span></span><br><span class="line"><span class="comment">// 返回值：成功时返回0，失败时返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091549617.png" alt="image-20210920142453244" style="zoom: 67%;" />

<p>listen 把一个未连接的套接字转换成被动套接字，指示内核应接受指向该套接字的连接请求。调用 listen 导致套接字从 CLOSED 状态转移到 LISTEN。</p>
<p>对于参数 backlog：</p>
<ol>
<li>backlog 被定义为两队列总和的最大值。</li>
<li>不想接受连接时，关闭套接字，不要把 backlog 定义为 0.</li>
</ol>
<h3 id="accept-函数（由-TCP-服务器调用）"><a href="#accept-函数（由-TCP-服务器调用）" class="headerlink" title="accept 函数（由 TCP 服务器调用）"></a>accept 函数（由 TCP 服务器调用）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：从已完成连接队列队头返回下一个已完成连接。如果已完成连接队列为空，那么进程进入睡眠状态（套接字阻塞方式）</span></span><br><span class="line"><span class="comment">// 参数：sockfd-监听套接字，cliaddr-客户进程的地址，addrlen-该地址的大小</span></span><br><span class="line"><span class="comment">// 返回值：成功时返回已连接套接字，失败时返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *cliaddr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该函数最多返回三个值：</p>
<ul>
<li>一个既可能是新套接字描述符也可能是出错指示的整数</li>
<li>客户进程的协议地址（由 cliaddr 所指）</li>
<li>该地址的大小（由 addrlen 所指的）</li>
</ul>
<p>如果我们对返回客户协议地址不感兴趣，可以把后两个参数都设为空指针。</p>
<h3 id="fork-和-exec-函数（并发编程基础）"><a href="#fork-和-exec-函数（并发编程基础）" class="headerlink" title="fork 和 exec 函数（并发编程基础）"></a>fork 和 exec 函数（并发编程基础）</h3><p>**<u>fork 是 Unix 中派生新进程的唯一方法</u>**。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p><u>fork 的特点是调用它一次，它却返回两次</u>：</p>
<ul>
<li>它在调用进程（父进程）中返回新派生进程（子进程）的 ID。</li>
<li>它在子进程中返回 0。</li>
</ul>
<p>任何子进程只有一个父进程，子进程总是可以通过调用 getppid 取得父进程的进程 ID。</p>
<p>fork 的 2 种典型用法：</p>
<ol>
<li>一个进程创建一个自身的副本：这样每个副本都<u>可以在另一个副本执行其他任务的同时处理各自的操作</u>（网络服务器的典型用法）。</li>
<li>一个进程想要执行另一个程序：先调用 fork 创建出一个自身的副本，<u>然后其中一个副本（通常为子进程）调用 exec 把自身替换成新的程序</u>（shell 之类程序的典型用法）。</li>
</ol>
<p>exec：<u>将当前<strong>进程映像</strong>替换成新的程序文件，而且该新程序通常从 main 函数开始执行</u>。进程 ID 并不改变。我们称调用 exec 的进程为调用进程（calling process），称新执行的程序为新程序（new program）。下面是  6 个 exec 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *arg0, ... <span class="comment">/* (char *)0 */</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *argv[] )</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *arg0, ... <span class="comment">/* (char *)0, char *const envp[]  */</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[] )</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *arg0, ... <span class="comment">/* (char *)0 */</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091549099.png" alt="image-20210920231718927"></p>
<p>这 6 个 exec 函数的区别在于：</p>
<ol>
<li>待执行的程序文件是由文件名（filename）还是由路径名（pathname）指定；</li>
<li>新程序的参数是一一列出还是由一个指针数组来引用；</li>
<li>把调用进程的环境传递给新程序还是给新程序指定新的环境。</li>
</ol>
<h3 id="并发服务器原理（重点）"><a href="#并发服务器原理（重点）" class="headerlink" title="并发服务器原理（重点）"></a>并发服务器原理（重点）</h3><p>Unix 编写并发服务器最简单的方法就是 fork 一个子进程来服务每个客户。下面是一个典型的并发服务器的轮廓。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">int</span>	listenfd, connfd;</span><br><span class="line">listenfd = Socket( ... );</span><br><span class="line"><span class="comment">/* fill in sockaddr_in&#123;&#125; with server&#x27;s well known port */</span></span><br><span class="line">Bind(listenfd, ... );</span><br><span class="line">Listen(listenfd, LISTENQ);</span><br><span class="line"><span class="keyword">for</span>( ; ; )&#123;</span><br><span class="line">    connfd = Accept(listen, ... );		<span class="comment">/* probably blocks*/</span></span><br><span class="line">    <span class="keyword">if</span>( (pid = Fork()) == <span class="number">0</span>)&#123;</span><br><span class="line">        Close(listenfd);	<span class="comment">// 子进程关闭监听套接字</span></span><br><span class="line">        doit(connfd);		<span class="comment">// 处理请求</span></span><br><span class="line">        Close(connfd);		<span class="comment">// 完成客户端的请求后，子进程显式地关闭连接套接字</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);		<span class="comment">// 上一个Close其实不是必须的，因为exit（进程终止）会关闭所有由内核打开的描述符。</span></span><br><span class="line">    &#125;	</span><br><span class="line">    Close(connfd);			<span class="comment">// 父进程关闭已连接套接字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个连接建立时，accept 返回，服务器接着调用 fork，然后由子进程通过已连接套接字 connfd 服务客户，父进程则通过监听套接字 listenfd 等待另一个连接。<u>既然新的客户由子进程提供服务，父进程就关闭已连接套接字</u>。</p>
<blockquote>
<p>为什么父进程对 connfd 调用 close 没有终止它与客户的连接呢？</p>
<p>原因：每个文件或套接字都有一个在文件表项中维护的<strong>引用计数</strong>，它是当前打开着的引用该文件或套接字的描述符的个数。fork 返回后，listenfd 和 connfd 这两个描述符在父进程和子进程间共享，它们各自的访问计数值都为 2。因此，当父进程关闭 connfd 时，只是将引用计数值从 2 减为 1，不会清理和释放该套接字的资源。 </p>
</blockquote>
<img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091549464.jpg" alt="并发服务器原理" style="zoom: 25%;" />

<h3 id="close-函数"><a href="#close-函数" class="headerlink" title="close 函数"></a>close 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：关闭套接字，终止TCP连接，导致相应的文件描述符引用值减1.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果确实想要在某个TCP连接上发送一个FIN，那么可以使用shtdown函数替换close函数。</p>
<h3 id="getsockname-和-getpeername-函数"><a href="#getsockname-和-getpeername-函数" class="headerlink" title="getsockname 和 getpeername 函数"></a>getsockname 和 getpeername 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：返回与某个套接字关联的本地协议地址</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，出错返回-1.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockname</span> <span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *localaddr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：返回与某个套接字关联的外地协议地址（peer）</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，出错返回-1.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpeername</span> <span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *peeraddr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这两个函数的最后一个参数都是<strong>值-结果参数</strong>。</p>
<p>需要这两个函数的理由：</p>
<ul>
<li><p>TCP 客户没有调用 bind 函数，connect 成功返回后，getsockname 用于返回由内核赋予该连接的<strong>本地</strong> IP 地址和本地端口号。</p>
</li>
<li><p>在以端口号 0 调用 bind （告知内核去选择本地端口号）后，getsockname 用于返回由内核赋予的本地端口号。</p>
</li>
<li><p>getsockname 可用于获取某个套接字的地址族。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sockfd_to_family</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">ss</span>;</span>		<span class="comment">// 新的通用套接字地址结构</span></span><br><span class="line">    <span class="keyword">socklen_t</span> len;</span><br><span class="line">    </span><br><span class="line">    len = <span class="keyword">sizeof</span>(ss);</span><br><span class="line">    <span class="keyword">if</span> (getsockname(sockfd, (SA*)&amp;ss, &amp;len) &lt; <span class="number">0</span>) <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> (ss.ss_family);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在一个以通配 IP 地址调用 bind 的 TCP 服务器上，与某个客户的连接一旦连接，getsockname 就可以用于返回由内核赋予的本地 IP 地址。</p>
</li>
<li><p>当一个服务器是由调用过 accept 的某个进程通过调用 exec 执行程序时，<u>它能够获取客户身份的唯一途径时调用 getpeername</u>.（P95）</p>
</li>
</ul>
<img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110091549688.png" alt="image-20210921092948127" style="zoom: 67%;" />





<h2 id="Linux-文件函数"><a href="#Linux-文件函数" class="headerlink" title="Linux 文件函数"></a>Linux 文件函数</h2><p>Linux 系统不区分文件和套接字。</p>
<p>文件描述符 fd：系统分配给文件或套接字的整数。从 3 开始以由小到大的顺序编号（numbering），这是因为0、1、2 分别分配给标准输入、标准输出、标准错误。</p>
<h3 id="open-函数"><a href="#open-函数" class="headerlink" title="open 函数"></a>open 函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：打开文件</span></span><br><span class="line"><span class="comment">// 输入：path——文件名的字符串信息，flag——文件打开模式信息</span></span><br><span class="line"><span class="comment">// 返回值：成功时返回为文件描述符，失败时返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> flag)</span></span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>打开模式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>O_CREAT</td>
<td>必要时创建文件</td>
</tr>
<tr>
<td>O_TRUNC</td>
<td>删除全部现有数据</td>
</tr>
<tr>
<td>O_APPEND</td>
<td>维持现有数据，保存到其后面</td>
</tr>
<tr>
<td>O_RDONLY</td>
<td>只读打开</td>
</tr>
<tr>
<td>O_WRONLY</td>
<td>只写打开</td>
</tr>
<tr>
<td>O_RDWR</td>
<td>读写打开</td>
</tr>
</tbody></table>
<h3 id="close-函数-1"><a href="#close-函数-1" class="headerlink" title="close 函数"></a>close 函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：关闭文件</span></span><br><span class="line"><span class="comment">// 输入：fd-需要关闭的文件或套接字的文件描述符</span></span><br><span class="line"><span class="comment">// 返回值：成功时返回0，失败时返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="write-函数"><a href="#write-函数" class="headerlink" title="write 函数"></a>write 函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：将数据写入文件</span></span><br><span class="line"><span class="comment">// 输入：fd-显示数据传输对象的文件描述符，buf-保存要传输数据的缓冲地址值，nbytes-要传输的数据字节数。ssizet是通过typdef声明的signed int类型。</span></span><br><span class="line"><span class="comment">// 返回值：成功时返回写入的字节数，失败时返回-1</span></span><br><span class="line"><span class="function">ssizet <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> * buf, <span class="keyword">size_t</span> nbytes)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="read-函数"><a href="#read-函数" class="headerlink" title="read 函数"></a>read 函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：读取文件中的数据</span></span><br><span class="line"><span class="comment">// 输入：fd-显示数据接收对象的文件描述符，buf-保存要接收数据的缓冲地址值，nbytes-要接收数据的最大字节数。ssizet是通过typdef声明的signed int类型。</span></span><br><span class="line"><span class="comment">// 返回值：成功时返回写入的字节数，失败时返回-1</span></span><br><span class="line"><span class="function">ssizet <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> * buf, <span class="keyword">size_t</span> nbytes)</span></span></span><br></pre></td></tr></table></figure>



<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zzxiaozhao/article/details/102637708">https://blog.csdn.net/zzxiaozhao/article/details/102637708</a></p>
<p><a target="_blank" rel="noopener" href="https://wuhlan3.gitee.io/wuhlan3/2021/07/29/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89">https://wuhlan3.gitee.io/wuhlan3/2021/07/29/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89</a></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>网络编程笔记(一)-基本TCP套接字编程</p><p><a href="https://tommyplayer-c.github.io/2021/09/30/计算机网络-网络编程笔记-一-基本TCP套接字编程/">https://tommyplayer-c.github.io/2021/09/30/计算机网络-网络编程笔记-一-基本TCP套接字编程/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>TommyPlayer</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-09-30</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-10-24</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"></div><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/linux-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">linux 网络编程 </a></div><div class="bdsharebuttonbox"><a class="bds_more" href="#" data-cmd="more"></a><a class="bds_qzone" href="#" data-cmd="qzone" title="分享到QQ空间"></a><a class="bds_tsina" href="#" data-cmd="tsina" title="分享到新浪微博"></a><a class="bds_tqq" href="#" data-cmd="tqq" title="分享到腾讯微博"></a><a class="bds_renren" href="#" data-cmd="renren" title="分享到人人网"></a><a class="bds_weixin" href="#" data-cmd="weixin" title="分享到微信"></a></div><script>window._bd_share_config = { "common": { "bdSnsKey": {}, "bdText": "", "bdMini": "2", "bdPic": "", "bdStyle": "0", "bdSize": "16" }, "share": {} }; with (document) 0[(getElementsByTagName('head')[0] || body).appendChild(createElement('script')).src = 'http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=' + ~(-new Date() / 36e5)];</script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/10/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-2021-10-06-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%B8%89-IO%E5%A4%8D%E7%94%A8%EF%BC%9Aselect%E5%92%8Cpoll%E5%87%BD%E6%95%B0/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">网络编程笔记(三)-I/O复用：select和poll函数</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/08/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-2021-08-30-Dijkstra%E7%AE%97%E6%B3%95/"><span class="level-item">Dijkstra 算法</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread',
            appId: "JUNkaa2nFLRBW02VRVV6TDlA-gzGzoHsz",
            appKey: "X2utmObXqHKT4G4RpNdh7rEH",
            placeholder: "欢迎探讨评论……",
            avatar: "hide",
            avatarForce: false,
            meta: ["nick","mail","link"],
            pageSize: 10,
            lang: "zh-CN",
            visitor: false,
            highlight: true,
            recordIP: false,
            
            
            
            enableQQ: false,
            requiredFields: [],
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/profile.jpg" alt="TommyPlayer"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">TommyPlayer</p><p class="is-size-6 is-block">Student</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">25</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">7</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">9</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/TommyPlayer-c" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/TommyPlayer-c"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/MySQL/"><span class="level-start"><span class="level-item">MySQL</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Vscode/"><span class="level-start"><span class="level-item">Vscode</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/linux/"><span class="level-start"><span class="level-item">linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">操作系统</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">数据结构与算法</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">计算机网络</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/C%E8%AF%AD%E8%A8%80/"><span class="tag">C语言</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MySQL/"><span class="tag">MySQL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/STL/"><span class="tag">STL</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><span class="tag">linux 网络编程</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux-%E9%85%8D%E7%BD%AE/"><span class="tag">linux 配置</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><span class="tag">动态规划</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE%E8%AE%BA/"><span class="tag">图论</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/"><span class="tag">操作系统理论</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%90%86%E8%AE%BA/"><span class="tag">计算机网络理论</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#网络编程笔记-一-基本TCP套接字编程"><span class="level-left"><span class="level-item">网络编程笔记(一)-基本TCP套接字编程</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#基础知识"><span class="level-left"><span class="level-item">基础知识</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#基本概念"><span class="level-left"><span class="level-item">基本概念</span></span></a></li><li><a class="level is-mobile" href="#相关-linux-指令"><span class="level-left"><span class="level-item">相关 linux 指令</span></span></a></li><li><a class="level is-mobile" href="#计算机网络基础"><span class="level-left"><span class="level-item">计算机网络基础</span></span></a></li></ul></li><li><a class="level is-mobile" href="#网络地址结构"><span class="level-left"><span class="level-item">网络地址结构</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#IPv4-套接字地址结构"><span class="level-left"><span class="level-item">IPv4 套接字地址结构</span></span></a></li><li><a class="level is-mobile" href="#IPv6-套接字地址结构"><span class="level-left"><span class="level-item">IPv6 套接字地址结构</span></span></a></li><li><a class="level is-mobile" href="#网络字节序和主机字节序"><span class="level-left"><span class="level-item">网络字节序和主机字节序</span></span></a></li></ul></li><li><a class="level is-mobile" href="#值-结果参数"><span class="level-left"><span class="level-item">值-结果参数</span></span></a></li><li><a class="level is-mobile" href="#书中自定义的读写函数"><span class="level-left"><span class="level-item">书中自定义的读写函数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#readn-函数："><span class="level-left"><span class="level-item">readn 函数：</span></span></a></li><li><a class="level is-mobile" href="#writen-函数："><span class="level-left"><span class="level-item">writen 函数：</span></span></a></li><li><a class="level is-mobile" href="#readline-函数："><span class="level-left"><span class="level-item">readline 函数：</span></span></a></li></ul></li><li><a class="level is-mobile" href="#基本-TCP-套接字编程"><span class="level-left"><span class="level-item">基本 TCP 套接字编程</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#socket-函数"><span class="level-left"><span class="level-item">socket 函数</span></span></a></li><li><a class="level is-mobile" href="#connect-函数"><span class="level-left"><span class="level-item">connect 函数</span></span></a></li><li><a class="level is-mobile" href="#bind-函数"><span class="level-left"><span class="level-item">bind 函数</span></span></a></li><li><a class="level is-mobile" href="#listen-函数（由-TCP-服务器调用）"><span class="level-left"><span class="level-item">listen 函数（由 TCP 服务器调用）</span></span></a></li><li><a class="level is-mobile" href="#accept-函数（由-TCP-服务器调用）"><span class="level-left"><span class="level-item">accept 函数（由 TCP 服务器调用）</span></span></a></li><li><a class="level is-mobile" href="#fork-和-exec-函数（并发编程基础）"><span class="level-left"><span class="level-item">fork 和 exec 函数（并发编程基础）</span></span></a></li><li><a class="level is-mobile" href="#并发服务器原理（重点）"><span class="level-left"><span class="level-item">并发服务器原理（重点）</span></span></a></li><li><a class="level is-mobile" href="#close-函数"><span class="level-left"><span class="level-item">close 函数</span></span></a></li><li><a class="level is-mobile" href="#getsockname-和-getpeername-函数"><span class="level-left"><span class="level-item">getsockname 和 getpeername 函数</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Linux-文件函数"><span class="level-left"><span class="level-item">Linux 文件函数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#open-函数"><span class="level-left"><span class="level-item">open 函数</span></span></a></li><li><a class="level is-mobile" href="#close-函数-1"><span class="level-left"><span class="level-item">close 函数</span></span></a></li><li><a class="level is-mobile" href="#write-函数"><span class="level-left"><span class="level-item">write 函数</span></span></a></li><li><a class="level is-mobile" href="#read-函数"><span class="level-left"><span class="level-item">read 函数</span></span></a></li></ul></li><li><a class="level is-mobile" href="#参考资料"><span class="level-left"><span class="level-item">参考资料</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">丢掉幻想，准备斗争</a><p class="is-size-7"><span>&copy; 2021 TommyPlayer</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>
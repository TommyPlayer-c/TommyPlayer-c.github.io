<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>网络编程笔记(二)-TCP客户服务器示例 - Keep moving</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="TommyPlayer"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="TommyPlayer"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="网络编程笔记(二)-TCP客户&amp;#x2F;服务器示例 参考《UNIX网络编程》第 5 章，《TCP&amp;#x2F;IP 网络编程》 第 10 章。"><meta property="og:type" content="blog"><meta property="og:title" content="网络编程笔记(二)-TCP客户服务器示例"><meta property="og:url" content="https://tommyplayer-c.github.io/2021/10/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-2021-10-04-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%BA%8C-TCP%E5%AE%A2%E6%88%B7%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A4%BA%E4%BE%8B/"><meta property="og:site_name" content="Keep moving"><meta property="og:description" content="网络编程笔记(二)-TCP客户&amp;#x2F;服务器示例 参考《UNIX网络编程》第 5 章，《TCP&amp;#x2F;IP 网络编程》 第 10 章。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/qin-haonan/my-picture/raw/master/20211004155907.png"><meta property="og:image" content="https://gitee.com/qin-haonan/my-picture/raw/master/20211004155917.png"><meta property="og:image" content="https://gitee.com/qin-haonan/my-picture/raw/master/20211004155944.png"><meta property="og:image" content="https://gitee.com/qin-haonan/my-picture/raw/master/20211004155947.png"><meta property="og:image" content="https://gitee.com/qin-haonan/my-picture/raw/master/20211004155924.png"><meta property="og:image" content="https://gitee.com/qin-haonan/my-picture/raw/master/20211004155927.png"><meta property="og:image" content="https://gitee.com/qin-haonan/my-picture/raw/master/20211004155931.png"><meta property="article:published_time" content="2021-10-04T07:57:03.000Z"><meta property="article:modified_time" content="2021-10-05T06:47:56.185Z"><meta property="article:author" content="TommyPlayer"><meta property="article:tag" content="linux 网络编程"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://gitee.com/qin-haonan/my-picture/raw/master/20211004155907.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://tommyplayer-c.github.io/2021/10/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-2021-10-04-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%BA%8C-TCP%E5%AE%A2%E6%88%B7%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A4%BA%E4%BE%8B/"},"headline":"网络编程笔记(二)-TCP客户服务器示例","image":["https://gitee.com/qin-haonan/my-picture/raw/master/20211004155907.png","https://gitee.com/qin-haonan/my-picture/raw/master/20211004155917.png","https://gitee.com/qin-haonan/my-picture/raw/master/20211004155944.png","https://gitee.com/qin-haonan/my-picture/raw/master/20211004155947.png","https://gitee.com/qin-haonan/my-picture/raw/master/20211004155924.png","https://gitee.com/qin-haonan/my-picture/raw/master/20211004155927.png","https://gitee.com/qin-haonan/my-picture/raw/master/20211004155931.png"],"datePublished":"2021-10-04T07:57:03.000Z","dateModified":"2021-10-05T06:47:56.185Z","author":{"@type":"Person","name":"TommyPlayer"},"publisher":{"@type":"Organization","name":"Keep moving","logo":{"@type":"ImageObject","url":{"text":"丢掉幻想，准备斗争"}}},"description":"网络编程笔记(二)-TCP客户&#x2F;服务器示例 参考《UNIX网络编程》第 5 章，《TCP&#x2F;IP 网络编程》 第 10 章。"}</script><link rel="canonical" href="https://tommyplayer-c.github.io/2021/10/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-2021-10-04-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%BA%8C-TCP%E5%AE%A2%E6%88%B7%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A4%BA%E4%BE%8B/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><meta name="msvalidate.01" content="8091EC0E04BC866B29B8C9F6ACBF07D3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Keep moving" type="application/atom+xml">
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">丢掉幻想，准备斗争</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-10-04T07:57:03.000Z" title="2021/10/4 下午3:57:03">2021-10-04</time>发表</span><span class="level-item"><time dateTime="2021-10-05T06:47:56.185Z" title="2021/10/5 下午2:47:56">2021-10-05</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span><span class="level-item">31 分钟读完 (大约4627个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">网络编程笔记(二)-TCP客户服务器示例</h1><div class="content"><h1 id="网络编程笔记-二-TCP客户-服务器示例"><a href="#网络编程笔记-二-TCP客户-服务器示例" class="headerlink" title="网络编程笔记(二)-TCP客户/服务器示例"></a>网络编程笔记(二)-TCP客户/服务器示例</h1><blockquote>
<p>参考《UNIX网络编程》第 5 章，《TCP/IP 网络编程》 第 10 章。</p>
</blockquote>
<span id="more"></span>

<h2 id="回射（echo）客户-服务器原理概述"><a href="#回射（echo）客户-服务器原理概述" class="headerlink" title="回射（echo）客户/服务器原理概述"></a>回射（echo）客户/服务器原理概述</h2><img src="https://gitee.com/qin-haonan/my-picture/raw/master/20211004155907.png" alt="image-20211003215318752" style="zoom:80%;" />

<p>并发服务器端实现模型和方法：</p>
<ol>
<li>多进程服务器：通过创建多个进程提供服务。</li>
<li>多路复用服务器：通过捆绑并统一管理 I/O 对象提供服务（select 和 epoll）。</li>
<li>多线程服务器：通过生成与客户端等量的线程提供服务。</li>
</ol>
<p>这里学习第一种——多进程服务器。</p>
<p>需要用到的 linux 命令：</p>
<ol>
<li> <code>ps au</code> ：查看进程 ID 和状态。</li>
<li><code>./可执行文件 &amp;</code>：后台运行某个进程。</li>
</ol>
<p>原始并发服务器的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTENQ 5</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_echo</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">	<span class="keyword">pid_t</span> childpid;</span><br><span class="line">	<span class="keyword">socklen_t</span> clilen;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>, <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (listenfd == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		error_handling(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	servaddr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bind(listenfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) == <span class="number">-1</span>)</span><br><span class="line">		error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (listen(listenfd, LISTENQ) == <span class="number">-1</span>)</span><br><span class="line">		error_handling(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;)</span><br><span class="line">	&#123;</span><br><span class="line">		clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">		connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;clilen);</span><br><span class="line">		<span class="keyword">if</span> (connfd == <span class="number">-1</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;new client %d... \n&quot;</span>, connfd);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((childpid = fork()) == <span class="number">0</span>)</span><br><span class="line">		&#123;					  <span class="comment">/* child process */</span></span><br><span class="line">			close(listenfd);  <span class="comment">/* close listening socket */</span></span><br><span class="line">			str_echo(connfd); <span class="comment">/* process the request */</span></span><br><span class="line">			<span class="comment">// close(connfd);</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d client disconnected...&quot;</span>, connfd);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (childpid == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			close(connfd);</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;fail to fork&quot;</span>);</span><br><span class="line">	    	<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		close(connfd); <span class="comment">/* parent closes connected socket */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_echo</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">ssize_t</span> n;</span><br><span class="line">	<span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ((n = read(sockfd, buf, BUF_SIZE)) &gt; <span class="number">0</span>)</span><br><span class="line">		write(sockfd, buf, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);  </span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;\n&quot;</span>,<span class="built_in">stderr</span>);  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *sendline)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_cli</span><span class="params">(FILE *fp, <span class="keyword">int</span> sockfd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sockfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        error_handling(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_addr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connect(sockfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr)) == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;connect() error\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Connected....\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    str_cli(<span class="built_in">stdin</span>, sockfd); <span class="comment">/* do it all */</span></span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_cli</span><span class="params">(FILE *fp, <span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> str_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> sendline[BUF_SIZE], recvline[BUF_SIZE];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Input sendline(Q to quit):\n&quot;</span>);</span><br><span class="line">        fgets(sendline, BUF_SIZE, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(sendline, <span class="string">&quot;q\n&quot;</span>) || !<span class="built_in">strcmp</span>(sendline, <span class="string">&quot;Q\n&quot;</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        write(sockfd, sendline, <span class="built_in">strlen</span>(sendline));</span><br><span class="line">        str_len = read(sockfd, sendline, BUF_SIZE - <span class="number">1</span>);</span><br><span class="line">        sendline[str_len] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sendline from server : %s \n&quot;</span>, sendline);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *sendline)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(sendline, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;\n&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="POSIX-信号处理"><a href="#POSIX-信号处理" class="headerlink" title="POSIX 信号处理"></a>POSIX 信号处理</h2><h3 id="信号的定义"><a href="#信号的定义" class="headerlink" title="信号的定义"></a>信号的定义</h3><p><strong>信号</strong>（signal）就是告知某个进程发生了某个事件的通知；信号通常是<strong>异步</strong>发生的，也就是说接受信号的进程不知道信号的准确发生时刻。</p>
<p>信号可以：</p>
<ol>
<li>一个进程发给另一个进程；</li>
<li>内核发给某个进程。</li>
</ol>
<h3 id="信号的处置"><a href="#信号的处置" class="headerlink" title="信号的处置"></a>信号的处置</h3><p>每个信号都有一个与之关联的<strong>处置</strong>，即收到特定信号时的处理方法；可以通过调用 <code>sigaction</code> 函数来设定一个信号的处置。</p>
<p>处置方法有三种选择：</p>
<ol>
<li><p>提供一个函数，只要有特定信号发生它就被调用。这样的函数称为<strong>信号处理函数</strong>（signal handler），这种行为称为捕获（catching）信号。有两个信号 SIGKILL 和 SIGSTOP 不能被捕获。信号处理函数由信号值这个<strong>单一的整数参数</strong>来调用，且<strong>没有返回值</strong>，其函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> signo)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>可以把某个信号的处置方法设定为 SIG_IGN 来忽略（ignore）它。SIDKILL 和 SIDSTOP 这两个信号不能被忽略；</p>
</li>
<li><p>可以把某个信号的处置方法设定为 SIG_DEF 来启用它的默认（default）处置，默认初值通常是收到信号后终止进程。另有个别信号的默认处置为忽略，如 SIGCHLD 和 SIGURG。</p>
</li>
</ol>
<h4 id="第一种处置方法"><a href="#第一种处置方法" class="headerlink" title="第一种处置方法"></a>第一种处置方法</h4><p><u>建立信号处置的 POSIX 方法就是调用 sigaction 函数</u>，但比较复杂（简单方法是调用自带的 signal 函数）。POSIX 明确规定了调用 sigaction 时的语义定义。解决方法是定义自己 signal——只是调用 sigaction 函数，以所期望的 POSIX 语义提供一个简单的接口。</p>
<p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/20211004155917.png" alt="1249281-20190411173750561-1353468742"></p>
<p>UNIX 系统自带的 signal 函数，历史悠久，不太稳定，也叫<strong>信号注册函数</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能：返回之前注册的函数指针。</span></span><br><span class="line"><span class="comment">// 参数：int signo，void (*func)(int)</span></span><br><span class="line"><span class="comment">// 返回类型：参数为int型，返回为void型函数指针</span></span><br><span class="line"><span class="keyword">void</span> (*signal(<span class="keyword">int</span> signo, <span class="keyword">void</span> (*func)(<span class="keyword">int</span>)))(<span class="keyword">int</span>);  </span><br></pre></td></tr></table></figure>

<p>一些常见的信号值：</p>
<ul>
<li>SIGALARM：已到通过 alarm 函数注册的时间</li>
<li>SIGINT：输入 CTRL + C</li>
<li>SIGCHILID：子进程终止</li>
</ul>
<p>利用 sigaction 函数进行信号处理，可以代替 signal，也更加稳定（POSIX 明确规定了调用 sigaction 时的信号语义）。<u>signal 函数在 UNIX 的不同系列操作系统中可能存在区别，但是 sigaction 完全相同</u>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">	signo：传递的信号  </span></span><br><span class="line"><span class="comment">	act：对应于第一个参数的信号处理函数  </span></span><br><span class="line"><span class="comment">	oldact：获取之前注册的信号处理函数指针，若不需要则传递0</span></span><br><span class="line"><span class="comment">返回值：成功返回0，失败返回-1</span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signo, <span class="keyword">const</span> struct sigaction *act, struct sigaction *oldact)</span></span>;  </span><br></pre></td></tr></table></figure>

<p>声明并初始化结构体以调用上述函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span>  </span><br><span class="line">	<span class="keyword">void</span> (* sa_handler)(<span class="keyword">int</span>);		<span class="comment">// 保存信号处理函数的指针</span></span><br><span class="line">	<span class="keyword">sigset_t</span> sa_mask;  				<span class="comment">// 可初始化为0</span></span><br><span class="line">	<span class="keyword">int</span> sa_flags;  					<span class="comment">// 可初始化为0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="第二种处置方法"><a href="#第二种处置方法" class="headerlink" title="第二种处置方法"></a>第二种处置方法</h4><p>把某个信号的处置方法设定为 SIG_IGN 来忽略（ignore）它。SIDKILL 和 SIDSTOP 这两个信号不能被忽略。</p>
<h4 id="第三种处置方法"><a href="#第三种处置方法" class="headerlink" title="第三种处置方法"></a>第三种处置方法</h4><p>可以把某个信号的处置方法设定为 SIG_DEF 来启用它的默认（default）处置，默认处置通常是收到信号后终止进程。有个别信号的默认处置为忽略，如 SIGCHLD 和 SIGURG。</p>
<h2 id="处理-SIGCHLD-信号（僵死进程）"><a href="#处理-SIGCHLD-信号（僵死进程）" class="headerlink" title="处理 SIGCHLD 信号（僵死进程）"></a>处理 SIGCHLD 信号（僵死进程）</h2><h3 id="僵死进程的概念"><a href="#僵死进程的概念" class="headerlink" title="僵死进程的概念"></a>僵死进程的概念</h3><p>进程 ID：创建时进程都会从操作系统获得进程 ID，其值为大于 2 的整数（1 为分配给操作系统启动后的首个进程）。</p>
<p>通过 fork 函数创建进程：复制正在运行的、调用 fork 函数的进程，父子进程拥有完全独立的内存结构。两个进程都执行 fork 函数以后的语句，<strong>共享同一代码</strong>。</p>
<p>初始服务器的代码存在僵死进程问题。</p>
<p>僵死进程：目的是为了维护子进程的信息（进程ID，终止状态，资源利用信息），以便父进程在以后某个时候存取。<u>如果父进程未主动要求获得子进程的结束状态值，操作系统将让子进程长时间处于僵死状态</u>。僵死进程占用内存中的空间，最终可能导致耗尽内核资源。</p>
<p>启动初始服务器：</p>
<p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/20211004155944.png" alt="image-20210925215239185"></p>
<p>启动初始客户端并连接服务器，可以看到，断开连接后出现僵死进程（Z）：</p>
<p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/20211004155947.png" alt="image-20210925215528420"></p>
<h3 id="销毁僵死进程的方法"><a href="#销毁僵死进程的方法" class="headerlink" title="销毁僵死进程的方法"></a>销毁僵死进程的方法</h3><h4 id="wait-函数"><a href="#wait-函数" class="headerlink" title="wait 函数"></a>wait 函数</h4><p>利用 wait 函数销毁僵死进程的原理：父进程主动请求获取子进程的返回值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值：成功时返回终止的子进程ID，失败返回-1 </span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> * statloc)</span></span>;</span><br></pre></td></tr></table></figure>

<p>wait 和 waitpid 均返回两个值：已终止子进程的进程 ID 号，以及通过 statloc 指针返回的子进程终止状态（一个整数）。子进程终止状态需要通过下列宏分离：</p>
<ul>
<li><p>WIFEXITED：子进程正常终止时返回 TRUE。</p>
</li>
<li><p>WEXITSTATUS：返回子进程的返回值。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wait</span>(&amp;status);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status))&#123;  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Child pass num : %d&quot;</span>, <span class="built_in">WEXITSTATUS</span>(status));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="waitpid-函数"><a href="#waitpid-函数" class="headerlink" title="waitpid 函数"></a>waitpid 函数</h4><p>wait 的局限性：调用 wait 函数时，如果没有已终止的子进程，那么程序将阻塞（Blocking）直到有子进程终止。wait 函数不能处理客户端与服务器同时建立多个连接的情况（《UNIX 网络编程》P109-111）</p>
<p>wait 函数会引起程序阻塞，但 waitpid 函数不会阻塞，而且可以指定等待的目标子进程，options 指定为 WNOHANG 时没有终止子进程也不会阻塞。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">	pid：等待终止的目标子进程ID，若传递-1，则与wait函数相同，等待任意子进程  </span></span><br><span class="line"><span class="comment">	statloc：与wait函数的statloc参数一致</span></span><br><span class="line"><span class="comment">	options：传递头文件sys/wait.h中声明的常量 WNOHANG，即使没有终止子进程也不会阻塞，而是返回0并退出函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 返回值：成功时返回终止子进程ID，失败返回-1 </span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> * statloc, <span class="keyword">int</span> options)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example:</span></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">waitpid</span>(<span class="number">-1</span>, &amp;status, WNOHANG))&#123;  </span><br><span class="line">	<span class="built_in">sleep</span>(<span class="number">1</span>);  </span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;sleep 1sec.&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status))&#123;  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;child send %d \n&quot;</span>,<span class="built_in">WEXITSTATUS</span>(status));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用-signal-消除僵死进程"><a href="#使用-signal-消除僵死进程" class="headerlink" title="使用 signal 消除僵死进程"></a>使用 signal 消除僵死进程</h4><ol>
<li><p>在服务器程序中调用 listen 之后添加信号注册函数 signal：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">signal</span>(SIGCHLD, sig_chld);</span><br></pre></td></tr></table></figure></li>
<li><p>编写信号处理函数 sig_chld：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本1：使用 wait</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_chld</span><span class="params">(<span class="keyword">int</span> signo)</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span>   stat;</span><br><span class="line">    pid = <span class="built_in">wait</span>(&amp;stat);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child %d terminated\n&quot;</span>,pid);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 版本2，使用 waitpid</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_chld</span><span class="params">(<span class="keyword">int</span> signo)</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span>   stat;</span><br><span class="line">    <span class="keyword">while</span>( (pid = <span class="built_in">waitpid</span>(<span class="number">-1</span>, &amp;stat, WHOHANG)) &gt; <span class="number">0</span> )</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;child %d terminated\n&quot;</span>,pid);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>可以看到，没有僵死进程：</p>
<p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/20211004155924.png" alt="image-20210925224832301"></p>
<h4 id="使用-sigaction-消除僵死进程"><a href="#使用-sigaction-消除僵死进程" class="headerlink" title="使用 sigaction 消除僵死进程"></a>使用 sigaction 消除僵死进程</h4><p>类似 signal，在服务器程序中调用 listen 之后添加以下代码，使用同样的信号处理函数 sig_chlid。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理僵死进程</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">	<span class="keyword">int</span> state;</span><br><span class="line">	act.sa_handler = sig_chld;</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    state = <span class="built_in">sigaction</span>(SIGCHLD, &amp;act, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h4 id="使用-waitpid-而不是-wait-的原因——UNIX-信号不排队"><a href="#使用-waitpid-而不是-wait-的原因——UNIX-信号不排队" class="headerlink" title="使用 waitpid 而不是 wait 的原因——UNIX 信号不排队"></a>使用 waitpid 而不是 wait 的原因——UNIX 信号不排队</h4><p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/20211004155927.png" alt="image-20210928220057244"></p>
<p>一个客户与并发服务器建立 5 个连接时，建立一个信号处理函数并在其中调用的 wait 不足以防止出现僵死进程（只能终止一个进程）。原因：所有 5 个信号都在信号处理函数执行之前产生，而信号处理函数只执行了一次，因为 Unix 信号一般是<strong>不排队的</strong>。正确的解决方法是调用 waitpid 而不是 wait：在一个循环内调用 waitpid，以获取所有已终止子进程的状态。WHOHANG 告知 waitpid 没有已终止子进程时也不要阻塞。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_chld</span><span class="params">(<span class="keyword">int</span> signo)</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span>   stat;</span><br><span class="line">    <span class="keyword">while</span>( (pid = waitpid(<span class="number">-1</span>, &amp;stat, WHOHANG)) &gt; <span class="number">0</span> )</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;child %d terminated\n&quot;</span>,pid);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol>
<li>当 fork 子进程时，必须捕获 SIGCHLD 信号。</li>
<li>当捕获信号时，必须处理被中断的系统调用。(P107)</li>
<li>SIGCHLD 的信号处理函数必须正确编写，应使用 waitpid 函数以免留下僵死进程。</li>
</ol>
<h2 id="服务器进程终止"><a href="#服务器进程终止" class="headerlink" title="服务器进程终止"></a>服务器进程终止</h2><p>复习 TCP 四次握手关闭连接的过程：</p>
<p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/20211004155931.png" alt="image-20210930093254244"></p>
<p>模拟服务器进程崩溃时，客户端会发生什么：</p>
<ol>
<li><p>找到服务器子进程的进程 ID，并执行 kill 命令杀死它。此时被杀死的服务器子进程的<u>所有打开着的描述符都将关闭</u>。这就导致服务器向客户端发送一个 FIN，而客户端会向服务器响应一个 ACK。是四次握手关闭连接的前半部分。</p>
</li>
<li><p><strong>SIGCHLD 信号</strong>被发送给服务器父进程，僵死子进程得到正确处理。然而问题是客户进程此时<strong>阻塞在 fgets 函数</strong>上，等待从终端接收一行文本。</p>
</li>
<li><p>此时在另一个窗口运行 netstat 命令，可以看到 TCP 连接终止序列的前半部分已经完成。</p>
<p>服务器终端：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[qhn@Tommy tcpcliserv]$ ps au</span><br><span class="line">USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root       1910  0.1  0.3 341764  7732 tty1     Ssl+ 19:26   0:04 /usr/bin/X :0 -background none -noreset -audit 4 -verbose -auth /run</span><br><span class="line">qhn        3840  0.0  0.1 117096  2772 pts/0    Ss   19:44   0:00 /usr/bin/bash</span><br><span class="line">qhn        6772  0.0  0.0   6388   544 pts/0    S    20:30   0:00 ./tcpserv04</span><br><span class="line">qhn        7240  0.0  0.1 116968  3184 pts/1    Ss   20:32   0:00 /usr/bin/bash</span><br><span class="line">qhn        8104  0.0  0.0   6396   396 pts/1    S+   20:39   0:00 ./tcpcli01 127.0.0.1</span><br><span class="line">qhn        8105  0.0  0.0   6388   104 pts/0    S    20:39   0:00 ./tcpserv04</span><br><span class="line">qhn        8159  0.0  0.0 155448  1872 pts/0    R+   20:39   0:00 ps au</span><br><span class="line">[qhn@Tommy tcpcliserv]$ kill 8105</span><br><span class="line">[qhn@Tommy tcpcliserv]$ child 8105 terminated</span><br><span class="line"></span><br><span class="line">[qhn@Tommy tcpcliserv]$ netstat -a | grep 9877</span><br><span class="line">tcp        0      0 0.0.0.0:9877            0.0.0.0:*               LISTEN     </span><br><span class="line">tcp        0      0 localhost:9877          localhost:51616         FIN_WAIT2  </span><br><span class="line">tcp        1      0 localhost:51616         localhost:9877          CLOSE_WAIT </span><br></pre></td></tr></table></figure></li>
<li><p>此时，在客户端键入一行文本 “another line”，str_cli 调用 written，客户 TCP 将数据发送给服务器（<u>FIN 的接收并没有告知客户 TCP 服务器进程已经终止</u>，但实际上在本例中服务器进程已经被杀死了）。由于服务器先前打开的连接套接字已经终止，于是响应以一个 RST。</p>
</li>
<li><p>客户进程<strong>之前阻塞在 fgets</strong> 上，看不到这个 RST。客户发送 “another line” 后立即调用 readline，直接收到终止符 EOF（因为之前客户端收到了 FIN），这是客户未预期的，所以客户端会提示以出错信息 “server terminated prematurely”（服务器过早终止）退出。</p>
<p>客户端终端：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[qhn@Tommy tcpcliserv]$ ./tcpcli01 127.0.0.1</span><br><span class="line">hello</span><br><span class="line">hello</span><br><span class="line">hi</span><br><span class="line">hi</span><br><span class="line">another line</span><br><span class="line">str_cli: server terminated prematurely</span><br><span class="line">[qhn@Tommy tcpcliserv]$ </span><br></pre></td></tr></table></figure>

<p>本例的问题在于：当 FIN 到达客户套接字时，<u>客户正阻塞在 fgets 调用上，不能够及时处理</u>。客户端实际上在<strong>应对两个描述符——套接字和用户输入</strong>。它不能单纯阻塞在这两个源中某个特定源的输入上，而是应该<strong>同时阻塞</strong>在这两个源的输入上。这正是 <strong>select</strong> 和 <strong>poll</strong> 这两个函数的目的之一。</p>
</li>
</ol>
<h2 id="服务器主机崩溃"><a href="#服务器主机崩溃" class="headerlink" title="服务器主机崩溃"></a>服务器主机崩溃</h2><p>在不同的主机上运行服务器和客户端，先启动服务器，再启动客户端，确定它们正常启动后，从网络上断开服务器主机，并在客户键入一行文本。</p>
<ol>
<li>当服务器主机崩溃后（不是由操作员执行命令关机），已有的网络连接上不再发出任何东西。</li>
<li>此时客户键入一行文本，文本由 writen 写入内核，再由客户 TCP 作为一个数据分节发出。然后客户阻塞在 readline 调用，等待服务器回射应答。</li>
<li>此时用 tcpdump 就会发现，客户 TCP 持续重传数据分节，试图从服务器上接收一个 ACK。</li>
<li>既然客户阻塞在 readline 调用上，该调用会返回一个错误：<ul>
<li>假设服务器已经崩溃，对客户的数据分节根本没有响应，返回错误 <strong>ETIMEDOUT</strong>；</li>
<li>如果某个中间路由器判定服务器已不可达，则该路由器会响应一个 “destination unreachable” （目的地不可达）ICMP 消息，返回错误为 **EHOSTUNREACH **或 <strong>ENETUNREACH</strong>。</li>
</ul>
</li>
</ol>
<p>本例的问题在于：想要知道服务器主机是否崩溃，只能通过客户向服务器主机发送数据来检验。如果想不发送数据就检测出服务器主机是否崩溃，需要使用 <strong>SO_KEEPALIVE</strong> 套接字选项。</p>
<h2 id="服务器主机崩溃并重启"><a href="#服务器主机崩溃并重启" class="headerlink" title="服务器主机崩溃并重启"></a>服务器主机崩溃并重启</h2><p>服务器主机崩溃并重启时，在客户上键入一行文本。重启后，服务器 TCP 丢失了崩溃前所有连接信息，因此 TCP 对客户响应一个 RST（重置连接）。当客户 TCP 收到该 RST 时，客户正阻塞于 readline 调用，导致该调用返回 ECONNRESET 错误。</p>
<h2 id="服务器主机关机"><a href="#服务器主机关机" class="headerlink" title="服务器主机关机"></a>服务器主机关机</h2><p>服务器主机被操作员<strong>关机</strong>将会发生什么：Unix 系统关机时，init 进程会给<strong>所有进程</strong>发送一个 SIGTERM 信号（该信号可被捕获），等待一段固定时间（5~12s），然后给所有仍在运行的程序发送给一个 SIGKILL（该信号不能被捕获）。这么做的目的是，留出一小段时间给所有运行的进程来清除与终止。</p>
<p>如果不捕获 SIGTERM 信号并终止，服务器将由 SIGKILL 信号终止。当服务器子进程终止时，它的所有打开着的描述符都被关闭，这样又回到了<a href="##%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2">服务器进程终止</a>的问题。</p>
<h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><p>在客户与服务器之间传递<strong>二进制值</strong>时，如果字节序不一样或所支持的长整数的大小不一致，将会出错。</p>
<p>3 个问题：</p>
<ol>
<li> 不同的实现以不同的格式存储二进制数——大端字节序与小端字节序。</li>
<li>不同的实现在存储相同的 C 数据类型上可能存在差异——大多数 32 位 Unix 系统使用 32 位表示长整数，而 64 位系统一般使用 64 位表示长整数。</li>
<li><strong>不同的实现给结构打包的方式存在差异</strong>。因此，穿越套接字传送二进制结构绝不是明智的。</li>
</ol>
<p>解决方法：</p>
<ol>
<li><strong>把所有的数值数据作为文本串来传递</strong>。</li>
<li>显式定义所支持数据类型的二进制格式（位数、大端或小端字节序），并以这样的格式在客户与服务器之间传递所有数据。远程过程调用（RPC）通常使用这种技术。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从简单的 echo 服务器开始，解决了以下问题：</p>
<ul>
<li>处理僵死子进程——采用信号处理（signal，sigaction）。</li>
<li>服务器进程终止时，客户进程收到 FIN 但并不知道终止——使用 select、poll。</li>
<li>服务器主机崩溃时，必须通过客户向服务器发送数据才能检验—— SO_KEEPALIVE 套接字选项。</li>
<li>穿越套接字传送二进制结构绝不是明智的——把所有的数值数据作为文本串来传递。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/soldierback/p/10690783.html">https://www.cnblogs.com/soldierback/p/10690783.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zzxiaozhao/article/details/102662861">https://blog.csdn.net/zzxiaozhao/article/details/102662861</a></p>
<p><a target="_blank" rel="noopener" href="https://wuhlan3.gitee.io/wuhlan3/2021/08/03/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%94%EF%BC%89">https://wuhlan3.gitee.io/wuhlan3/2021/08/03/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%94%EF%BC%89</a></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>网络编程笔记(二)-TCP客户服务器示例</p><p><a href="https://tommyplayer-c.github.io/2021/10/04/计算机网络-2021-10-04-网络编程笔记-二-TCP客户服务器示例/">https://tommyplayer-c.github.io/2021/10/04/计算机网络-2021-10-04-网络编程笔记-二-TCP客户服务器示例/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>TommyPlayer</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-10-04</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-10-05</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"></div><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/linux-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">linux 网络编程 </a></div><div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%9B-%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%89%E9%A1%B9%E5%92%8CUDP/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">网络编程笔记(四)-套接字选项和 UDP</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/10/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-2021-10-06-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%B8%89-IO%E5%A4%8D%E7%94%A8%EF%BC%9Aselect%E5%92%8Cpoll%E5%87%BD%E6%95%B0/"><span class="level-item">网络编程笔记(三)-I/O复用：select和poll函数</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread',
            appId: "JUNkaa2nFLRBW02VRVV6TDlA-gzGzoHsz",
            appKey: "X2utmObXqHKT4G4RpNdh7rEH",
            placeholder: "欢迎探讨评论……",
            avatar: "hide",
            avatarForce: false,
            meta: ["nick","mail","link"],
            pageSize: 10,
            lang: "zh-CN",
            visitor: false,
            highlight: true,
            recordIP: false,
            
            
            
            enableQQ: false,
            requiredFields: [],
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/profile.jpg" alt="TommyPlayer"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">TommyPlayer</p><p class="is-size-6 is-block">Student</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">25</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">7</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">9</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/TommyPlayer-c" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/TommyPlayer-c"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/MySQL/"><span class="level-start"><span class="level-item">MySQL</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Vscode/"><span class="level-start"><span class="level-item">Vscode</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/linux/"><span class="level-start"><span class="level-item">linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">操作系统</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">数据结构与算法</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">计算机网络</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/C%E8%AF%AD%E8%A8%80/"><span class="tag">C语言</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MySQL/"><span class="tag">MySQL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/STL/"><span class="tag">STL</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><span class="tag">linux 网络编程</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux-%E9%85%8D%E7%BD%AE/"><span class="tag">linux 配置</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><span class="tag">动态规划</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE%E8%AE%BA/"><span class="tag">图论</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/"><span class="tag">操作系统理论</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%90%86%E8%AE%BA/"><span class="tag">计算机网络理论</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#网络编程笔记-二-TCP客户-服务器示例"><span class="level-left"><span class="level-item">网络编程笔记(二)-TCP客户/服务器示例</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#回射（echo）客户-服务器原理概述"><span class="level-left"><span class="level-item">回射（echo）客户/服务器原理概述</span></span></a></li><li><a class="level is-mobile" href="#POSIX-信号处理"><span class="level-left"><span class="level-item">POSIX 信号处理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#信号的定义"><span class="level-left"><span class="level-item">信号的定义</span></span></a></li><li><a class="level is-mobile" href="#信号的处置"><span class="level-left"><span class="level-item">信号的处置</span></span></a></li></ul></li><li><a class="level is-mobile" href="#处理-SIGCHLD-信号（僵死进程）"><span class="level-left"><span class="level-item">处理 SIGCHLD 信号（僵死进程）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#僵死进程的概念"><span class="level-left"><span class="level-item">僵死进程的概念</span></span></a></li><li><a class="level is-mobile" href="#销毁僵死进程的方法"><span class="level-left"><span class="level-item">销毁僵死进程的方法</span></span></a></li></ul></li><li><a class="level is-mobile" href="#服务器进程终止"><span class="level-left"><span class="level-item">服务器进程终止</span></span></a></li><li><a class="level is-mobile" href="#服务器主机崩溃"><span class="level-left"><span class="level-item">服务器主机崩溃</span></span></a></li><li><a class="level is-mobile" href="#服务器主机崩溃并重启"><span class="level-left"><span class="level-item">服务器主机崩溃并重启</span></span></a></li><li><a class="level is-mobile" href="#服务器主机关机"><span class="level-left"><span class="level-item">服务器主机关机</span></span></a></li><li><a class="level is-mobile" href="#数据格式"><span class="level-left"><span class="level-item">数据格式</span></span></a></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">总结</span></span></a></li><li><a class="level is-mobile" href="#参考资料"><span class="level-left"><span class="level-item">参考资料</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">丢掉幻想，准备斗争</a><p class="is-size-7"><span>&copy; 2021 TommyPlayer</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>
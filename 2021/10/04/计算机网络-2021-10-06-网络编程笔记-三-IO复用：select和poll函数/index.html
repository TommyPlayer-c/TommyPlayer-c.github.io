<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>网络编程笔记(三)-I/O复用：select和poll函数 - Keep moving</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="TommyPlayer"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="TommyPlayer"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="网络编程笔记(三)-I&amp;#x2F;O复用：select和poll函数 参考《UNIX网络编程》第 6 章，《TCP&amp;#x2F;IP 网络编程》 第 7、12 章。"><meta property="og:type" content="blog"><meta property="og:title" content="网络编程笔记(三)-I/O复用：select和poll函数"><meta property="og:url" content="https://tommyplayer-c.github.io/2021/10/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-2021-10-06-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%B8%89-IO%E5%A4%8D%E7%94%A8%EF%BC%9Aselect%E5%92%8Cpoll%E5%87%BD%E6%95%B0/"><meta property="og:site_name" content="Keep moving"><meta property="og:description" content="网络编程笔记(三)-I&amp;#x2F;O复用：select和poll函数 参考《UNIX网络编程》第 6 章，《TCP&amp;#x2F;IP 网络编程》 第 7、12 章。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/qin-haonan/my-picture/raw/master/202110061602905.png"><meta property="og:image" content="https://gitee.com/qin-haonan/my-picture/raw/master/202110061602943.png"><meta property="og:image" content="https://gitee.com/qin-haonan/my-picture/raw/master/202110061602973.png"><meta property="og:image" content="https://gitee.com/qin-haonan/my-picture/raw/master/202110061602003.png"><meta property="og:image" content="https://gitee.com/qin-haonan/my-picture/raw/master/202110061602033.png"><meta property="og:image" content="https://gitee.com/qin-haonan/my-picture/raw/master/202110061602062.png"><meta property="og:image" content="https://gitee.com/qin-haonan/my-picture/raw/master/202110061602092.png"><meta property="og:image" content="https://gitee.com/qin-haonan/my-picture/raw/master/202110061602119.png"><meta property="article:published_time" content="2021-10-04T07:57:03.000Z"><meta property="article:modified_time" content="2021-10-30T01:45:27.369Z"><meta property="article:author" content="TommyPlayer"><meta property="article:tag" content="linux 网络编程"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://gitee.com/qin-haonan/my-picture/raw/master/202110061602905.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://tommyplayer-c.github.io/2021/10/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-2021-10-06-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%B8%89-IO%E5%A4%8D%E7%94%A8%EF%BC%9Aselect%E5%92%8Cpoll%E5%87%BD%E6%95%B0/"},"headline":"网络编程笔记(三)-I/O复用：select和poll函数","image":["https://gitee.com/qin-haonan/my-picture/raw/master/202110061602905.png","https://gitee.com/qin-haonan/my-picture/raw/master/202110061602943.png","https://gitee.com/qin-haonan/my-picture/raw/master/202110061602973.png","https://gitee.com/qin-haonan/my-picture/raw/master/202110061602003.png","https://gitee.com/qin-haonan/my-picture/raw/master/202110061602033.png","https://gitee.com/qin-haonan/my-picture/raw/master/202110061602062.png","https://gitee.com/qin-haonan/my-picture/raw/master/202110061602092.png","https://gitee.com/qin-haonan/my-picture/raw/master/202110061602119.png"],"datePublished":"2021-10-04T07:57:03.000Z","dateModified":"2021-10-30T01:45:27.369Z","author":{"@type":"Person","name":"TommyPlayer"},"publisher":{"@type":"Organization","name":"Keep moving","logo":{"@type":"ImageObject","url":{"text":"丢掉幻想，准备斗争"}}},"description":"网络编程笔记(三)-I&#x2F;O复用：select和poll函数 参考《UNIX网络编程》第 6 章，《TCP&#x2F;IP 网络编程》 第 7、12 章。"}</script><link rel="canonical" href="https://tommyplayer-c.github.io/2021/10/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-2021-10-06-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%B8%89-IO%E5%A4%8D%E7%94%A8%EF%BC%9Aselect%E5%92%8Cpoll%E5%87%BD%E6%95%B0/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><meta name="msvalidate.01" content="8091EC0E04BC866B29B8C9F6ACBF07D3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Keep moving" type="application/atom+xml">
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">丢掉幻想，准备斗争</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-10-04T07:57:03.000Z" title="2021/10/4 下午3:57:03">2021-10-04</time>发表</span><span class="level-item"><time dateTime="2021-10-30T01:45:27.369Z" title="2021/10/30 上午9:45:27">2021-10-30</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span><span class="level-item">26 分钟读完 (大约3929个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">网络编程笔记(三)-I/O复用：select和poll函数</h1><div class="content"><h1 id="网络编程笔记-三-I-O复用：select和poll函数"><a href="#网络编程笔记-三-I-O复用：select和poll函数" class="headerlink" title="网络编程笔记(三)-I/O复用：select和poll函数"></a>网络编程笔记(三)-I/O复用：select和poll函数</h1><blockquote>
<p>参考《UNIX网络编程》第 6 章，《TCP/IP 网络编程》 第 7、12 章。</p>
</blockquote>
<span id="more"></span>

<h1 id="I-O-模型"><a href="#I-O-模型" class="headerlink" title="I/O 模型"></a>I/O 模型</h1><p>I/O 复用的场合：</p>
<ol>
<li><p>当客户处理多个描述符时（一般是交互式输入和网络套接字），必须使用I/O复用。</p>
</li>
<li><p>当客户同时处理多个套接字时，这种情况很少出现。</p>
</li>
<li><p>如果一个 TCP 服务器既要处理监听套接字，又要处理已连接套接字，一般就要使用 I/O 复用。</p>
</li>
<li><p>如果一个服务器既要处理 TCP，又要处理 UDP，一般就要使用 I/O 复用。</p>
</li>
<li><p>如果一个服务器要处理多个服务或多个协议，一般就要使用 I/O 复用。</p>
</li>
</ol>
<p>UNIX 下可用的 5 种 I/O 模型：</p>
<ul>
<li>阻塞式 I/O；</li>
<li>非阻塞式 I/O；</li>
<li>I/O 复用（select 和 poll）；</li>
<li>信号驱动式 I/O（SIGIO）；</li>
<li>异步 I/O（POSIX 的 aio_系列函数）。</li>
</ul>
<p>输入操作的 2 个阶段：</p>
<ol>
<li>等待数据准备好（一般是等待数据从网络中到达，到达时被数据被复制到内核中的缓冲区）；</li>
<li>从内核向进程复制数据（把数据从内核缓冲区复制到应用进程缓冲区）。</li>
</ol>
<img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110061602905.png" alt="image-20211006154807013" style="zoom: 67%;" />

<p>前四种为同步 I/O，因为真正的 I/O 操作将阻塞进程。</p>
<p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110061602943.png" alt="image-20211006154849809"></p>
<h1 id="select-函数"><a href="#select-函数" class="headerlink" title="select 函数"></a>select 函数</h1><h2 id="定义和功能"><a href="#定义和功能" class="headerlink" title="定义和功能"></a>定义和功能</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">	maxfd：监视对象文件描述符数量（最大文件描述符+1）</span></span><br><span class="line"><span class="comment">	readset：是否存在待读取数据的文件描述符  </span></span><br><span class="line"><span class="comment">	writeset：是否可传输无阻塞数据的文件描述符  </span></span><br><span class="line"><span class="comment">	exceptset：是否发生异常的文件描述符  </span></span><br><span class="line"><span class="comment">	timeout：超时信息 （如果select发生了阻塞，那么就通过设置timeout防止这种情况）	</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 返回值：若有就绪描述符则返回其数目，超时返回 0，失败返回 -1  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfd, fd_set *readset, fd_set *writeset, fd_set *exceptset,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">const</span> struct timeval * timeout)</span>  </span></span><br></pre></td></tr></table></figure>

<ol>
<li>可读：是否存在套接字接收数据。</li>
<li>可写：无需阻塞传输数据的套接字有哪些。</li>
<li>异常：哪些套接字发生异常。</li>
</ol>
<p>select 函数调用过程：</p>
<ol>
<li>设置文件描述符，指定监视范围，设置超时。</li>
<li>调用 select 函数。</li>
<li>查看调用结果。</li>
</ol>
<h2 id="fd-set：设置文件描述符"><a href="#fd-set：设置文件描述符" class="headerlink" title="fd_set：设置文件描述符"></a>fd_set：设置文件描述符</h2><p>fd_set 数据类型的操作以<strong>位</strong>为单位进行。注册和更改值得操作由下列宏完成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;			<span class="comment">// 将fd_set变量得所有位初始化为0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;		<span class="comment">// 注册：将文件描述符fd置1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;		<span class="comment">// 清除：将文件描述符fd置0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;	<span class="comment">// 判断文件描述符fd是否被设置为1</span></span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110061602973.png" alt="image-20211005210216231" style="zoom: 67%;" />

<h2 id="maxfd-和中间-3-个描述符集参数"><a href="#maxfd-和中间-3-个描述符集参数" class="headerlink" title="maxfd 和中间 3 个描述符集参数"></a>maxfd 和中间 3 个描述符集参数</h2><p>maxfd：指定待测试的描述符个数（待测试的最大描述符 +1，+1 是因为从 0 开始），描述符 0, 1, 2, … 一直到 maxfd - 1 都将被测试。</p>
<p>如果我们对 readset、writeset、exceptset 中的某一个条件不感兴趣，就可以把它设为空指针。</p>
<p>描述符集参数是<strong>值-结果参数</strong>。原来为 1 的所有位均变为 0，但发生变化的文件描述符对应位除外——值仍为 1 的文件描述符发生了变化。select 返回后使用 FD_ISSET 宏来测试 fd_set 数据类型。因此，每<u>次重新调用 select 函数时，都得再次把所有描述符集内所关心的位置为 1</u>。</p>
<h2 id="struct-timeval：超时时间"><a href="#struct-timeval：超时时间" class="headerlink" title="struct timeval：超时时间"></a>struct timeval：超时时间</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> tv_sec; 	<span class="comment">// sec  </span></span><br><span class="line">    <span class="keyword">long</span> tv_usec;	<span class="comment">// microsec</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个参数有三种选择：</p>
<ol>
<li>永远等待下去：仅在有一个描述符准备好 I/O 时才返回。为此要将该参数设置为空。</li>
<li>等待一段固定时间（等待时间不超过这个固定时间）。为此要设置秒数和微秒数。</li>
<li>根本不等待：检查描述符后立即返回，这称为<strong>轮询</strong>（polling）。为此要设置秒数和微秒数均为 0。</li>
</ol>
<h2 id="描述符就绪条件"><a href="#描述符就绪条件" class="headerlink" title="描述符就绪条件"></a>描述符就绪条件</h2><p>对于每一列满足任何一行，该列的表头就准备好了。</p>
<img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110061602003.png" alt="image-20211005211636197" style="zoom:67%;" />



<h1 id="str-cli-的两次修改"><a href="#str-cli-的两次修改" class="headerlink" title="str_cli 的两次修改"></a>str_cli 的两次修改</h1><p>初始的 str_cli 如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_cli</span><span class="params">(FILE *fp, <span class="keyword">int</span> sockfd)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> sendline[MAXLINE], recvline[MAXLINE];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (Fgets(sendline, MAXLINE, fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    Writen(sockfd, sendline, <span class="built_in">strlen</span>(sendline));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Readline(sockfd, recvline, MAXLINE) == <span class="number">0</span>)</span><br><span class="line">      err_quit(<span class="string">&quot;str_cli: server terminated prematurely&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Fputs(recvline, <span class="built_in">stdout</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第一次修改"><a href="#第一次修改" class="headerlink" title="第一次修改"></a>第一次修改</h2><p>初始的 str_cli 问题是：当套接字发生某些事情时，客户可能阻塞与 fgets 调用。新版本改为阻塞于 select 调用——<strong>或是等待标准输入可读，或是等待套接字可读</strong>。</p>
<img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110061602033.png" alt="image-20211005225618326" style="zoom: 67%;" />

<ol>
<li>如果对端 TCP 发送数据，那么该套接字变为可读，并且 read 返回一个大于 0 的值（即读入数据的字节数）</li>
<li>如果对端 TCP 发送一个 FIN（对端进程终止），那么该套接字变为可读，并且read 返回 0（EOF）</li>
<li>如果对端 TCP 发送一个 RST（对端主机崩溃并重新启动），那么该套接字变为可读，并且 read 返回 -1，errno 含有确切的错误码。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../lib/unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_cli</span><span class="params">(FILE *fp, <span class="keyword">int</span> sockfd)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> maxfdp1;</span><br><span class="line">  fd_set rset;	<span class="comment">// readset: 读描述符集</span></span><br><span class="line">  <span class="keyword">char</span> sendline[MAXLINE], recvline[MAXLINE];</span><br><span class="line"></span><br><span class="line">  FD_ZERO(&amp;rset);</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    FD_SET(fileno(fp), &amp;rset);	<span class="comment">// 打开标准IO文件指针fp</span></span><br><span class="line">    FD_SET(sockfd, &amp;rset);		<span class="comment">// 打开套接字描述符</span></span><br><span class="line">    maxfdp1 = max(fileno(fp), sockfd) + <span class="number">1</span>;</span><br><span class="line">    Select(maxfdp1, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset)) &#123; <span class="comment">/* socket is readable */</span></span><br><span class="line">      <span class="keyword">if</span> (Readline(sockfd, recvline, MAXLINE) == <span class="number">0</span>) <span class="comment">// EOF</span></span><br><span class="line">        err_quit(<span class="string">&quot;str_cli: server terminated prematurely&quot;</span>);</span><br><span class="line">      Fputs(recvline, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FD_ISSET(fileno(fp), &amp;rset)) &#123;                  <span class="comment">/* input is readable */</span></span><br><span class="line">      <span class="keyword">if</span> (Fgets(sendline, MAXLINE, fp) == <span class="literal">NULL</span>) <span class="keyword">return</span>; <span class="comment">/* all done */</span></span><br><span class="line">      Writen(sockfd, sendline, <span class="built_in">strlen</span>(sendline));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个版本的 str_cli 存在两个问题：</p>
<ol>
<li><p>批量输入时，标准输入的 EOF 并不意味着同时也完成了从套接字的读入（套接字上还有数据在传送）。</p>
<img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110061602062.png" alt="image-20211005230804040" style="zoom:67%;" /></li>
<li><p>混合使用 stdio 和 select 导致错误——select 并不知道 stdio 使用了缓冲区。fgets 返回一行写给服务器，随后 select 被调用以等待新的工作，而不管 stdio 缓冲区还有额外的输入待消费。</p>
</li>
</ol>
<h2 id="shutdown-函数"><a href="#shutdown-函数" class="headerlink" title="shutdown 函数"></a>shutdown 函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值：成功返回0，出错返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> howto)</span></span></span><br></pre></td></tr></table></figure>

<p>close 和 shutdown 对比：</p>
<ol>
<li>close 把描述符的引用计数减 1，仅在该计数变为 0 时才关闭套接字。 shutdown 可以不管引用计数，直接激发 TCP 的正常连接终止序列（四次握手）。</li>
<li>close 终止读和写两个方向的数据传输。shutdown 可以告诉对方自己已经完成了数据发送，即使对端仍有数据要发送。shutdown 可以只关闭其中一个流，而非同时断开两个流。</li>
</ol>
<img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110061602092.png" alt="image-20211006144931823" style="zoom:67%;" />

<p>shutdown 的行为依赖于 howto 参数：</p>
<ul>
<li>SHUT_RD：断开输入流，关闭连接的读这一半——套接字中不再有数据可接收，进程不能再对这样的套接字调用任何读函数。可以把第二个参数指定为 SHUT_RD 防止环回复制。<br>关闭SO_USELOOPBACK套接字选项也能防止回环</li>
<li>SHUT_WR：断开输出流：关闭连接的写这一半（半关闭，half-close）进程不能再对这样的套接字调用任何写函数。</li>
<li>SHUT_RDWR：同时断开 I/O 流，连接的读半部和写半部都关闭，等效于调用两次 shutdown。</li>
</ul>
<h2 id="第二次修改"><a href="#第二次修改" class="headerlink" title="第二次修改"></a>第二次修改</h2><ul>
<li>使用 select：服务器关闭它那一段的连接就会通知我们。</li>
<li>使用 shutdown：废弃了以文本行为中心的代码，改而针对缓冲区操作。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../lib/unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_cli</span><span class="params">(FILE *fp, <span class="keyword">int</span> sockfd)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> maxfdp1, stdineof; <span class="comment">// stdineof是一个初始化为0的新标志，只要该标志为0，每次在主循环我们总是select标准输入的可读性。</span></span><br><span class="line">  fd_set rset;</span><br><span class="line">  <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">  stdineof = <span class="number">0</span>;</span><br><span class="line">  FD_ZERO(&amp;rset);</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (stdineof == <span class="number">0</span>) FD_SET(fileno(fp), &amp;rset); <span class="comment">// select标准输入的可读性</span></span><br><span class="line">    FD_SET(sockfd, &amp;rset);</span><br><span class="line">    maxfdp1 = max(fileno(fp), sockfd) + <span class="number">1</span>;</span><br><span class="line">    Select(maxfdp1, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset)) &#123; <span class="comment">/* socket is readable */</span></span><br><span class="line">      <span class="keyword">if</span> ((n = Read(sockfd, buf, MAXLINE)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stdineof == <span class="number">1</span>)  <span class="comment">// 在套接字读到EOF时，如果我们已在标准输入上遇到 EOF，那就是正常的终止</span></span><br><span class="line">          <span class="keyword">return</span>; <span class="comment">/* normal termination */</span></span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">// 如果没有在标准输入上遇到 EOF，那就是服务器进程已经过早终止。</span></span><br><span class="line">          err_quit(<span class="string">&quot;str_cli: server terminated prematurely&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Write(fileno(<span class="built_in">stdout</span>), buf, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FD_ISSET(fileno(fp), &amp;rset)) &#123; <span class="comment">/* input is readable */</span></span><br><span class="line">      <span class="keyword">if</span> ((n = Read(fileno(fp), buf, MAXLINE)) == <span class="number">0</span>) &#123;</span><br><span class="line">        stdineof = <span class="number">1</span>; <span class="comment">// 标准输入上碰到EOF，将新标志置为1</span></span><br><span class="line">        Shutdown(sockfd, SHUT_WR); <span class="comment">/* send FIN */</span></span><br><span class="line">        FD_CLR(fileno(fp), &amp;rset);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Writen(sockfd, buf, n); <span class="comment">// read和write：对缓冲区而不是文本行进行操作。</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="TCP-回射服务器程序（修订版）"><a href="#TCP-回射服务器程序（修订版）" class="headerlink" title="TCP 回射服务器程序（修订版）"></a>TCP 回射服务器程序（修订版）</h1><p>服务器使用 select 的版本，避免了为每个客户创建一个新进程。</p>
<p>《TCP/IP网络编程》P203-P205</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> serv_sock, clnt_sock;</span><br><span class="line">  <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clnt_adr</span>;</span></span><br><span class="line">  <span class="keyword">socklen_t</span> adr_sz;</span><br><span class="line">  fd_set reads, cpy_reads;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">  <span class="keyword">int</span> fd_max, str_len, fd_num, i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (serv_sock == <span class="number">-1</span>) &#123;</span><br><span class="line">    error_handling(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">  serv_adr.sin_family = AF_INET;</span><br><span class="line">  serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">  serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bind(serv_sock, (struct sockaddr *)&amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">    error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (listen(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">    error_handling(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  FD_ZERO(&amp;reads);</span><br><span class="line">  FD_SET(serv_sock, &amp;reads);	<span class="comment">// 初始时，监听套接字是描述集中唯一的非0项</span></span><br><span class="line">  fd_max = serv_sock;	<span class="comment">// 这里不加1，下面select时就要加1，因为从0到fd_max-1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    cpy_reads = reads;</span><br><span class="line">    timeout.tv_sec = <span class="number">5</span>;</span><br><span class="line">    timeout.tv_usec = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd_num = select(fd_max + <span class="number">1</span>, &amp;cpy_reads, <span class="number">0</span>, <span class="number">0</span>, &amp;timeout)) == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (fd_num == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; fd_max + <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (FD_ISSET(i, &amp;cpy_reads)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == serv_sock) &#123;  <span class="comment">// connection request</span></span><br><span class="line">          adr_sz = <span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line">          clnt_sock = accept(serv_sock, (struct sockaddr *)&amp;clnt_adr, &amp;adr_sz);</span><br><span class="line">          FD_SET(clnt_sock, &amp;reads);	<span class="comment">// 注册与客户端连接的套接字文件描述符</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (fd_max &lt; clnt_sock) &#123;</span><br><span class="line">            fd_max = clnt_sock;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;connected client : %d \n&quot;</span>, clnt_sock);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// read message</span></span><br><span class="line">          str_len = read(i, buf, BUF_SIZE);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (str_len == <span class="number">0</span>) &#123;  <span class="comment">// close</span></span><br><span class="line">            FD_CLR(i, &amp;reads);</span><br><span class="line">            close(i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;closed client %d \n&quot;</span>, i);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            write(i, buf, str_len);  <span class="comment">// echo</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  close(serv_sock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">  <span class="built_in">fputs</span>(<span class="string">&quot;\n&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>《UNIX 网络编程》P138 - P142</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* include fig01 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../lib/unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, maxi, maxfd, listenfd, connfd, sockfd;</span><br><span class="line">  <span class="keyword">int</span> nready, client[FD_SETSIZE];	<span class="comment">// client数组，记录客户套接字</span></span><br><span class="line">  <span class="keyword">ssize_t</span> n;</span><br><span class="line">  fd_set rset, allset;</span><br><span class="line">  <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">  <span class="keyword">socklen_t</span> clilen;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>, <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">  listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">  servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">  Bind(listenfd, (SA *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">  Listen(listenfd, LISTENQ);</span><br><span class="line"></span><br><span class="line">  maxfd = listenfd; <span class="comment">/* initialize */</span></span><br><span class="line">  maxi = <span class="number">-1</span>;        <span class="comment">/* index into client[] array */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++)</span><br><span class="line">    client[i] = <span class="number">-1</span>; <span class="comment">/* -1 indicates available entry */</span></span><br><span class="line">  FD_ZERO(&amp;allset);</span><br><span class="line">  FD_SET(listenfd, &amp;allset);</span><br><span class="line">  <span class="comment">/* end fig01 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* include fig02 */</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    rset = allset; <span class="comment">/* structure assignment */</span></span><br><span class="line">    nready = Select(maxfd + <span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FD_ISSET(listenfd, &amp;rset)) &#123; <span class="comment">/* new client connection */</span></span><br><span class="line">      clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">      connfd = Accept(listenfd, (SA *)&amp;cliaddr, &amp;clilen);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++)</span><br><span class="line">        <span class="keyword">if</span> (client[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          client[i] = connfd; <span class="comment">/* save descriptor */</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (i == FD_SETSIZE) err_quit(<span class="string">&quot;too many clients&quot;</span>);</span><br><span class="line"></span><br><span class="line">      FD_SET(connfd, &amp;allset);            <span class="comment">/* add new descriptor to set */</span></span><br><span class="line">      <span class="keyword">if</span> (connfd &gt; maxfd) maxfd = connfd; <span class="comment">/* for select */</span></span><br><span class="line">      <span class="keyword">if</span> (i &gt; maxi) maxi = i;             <span class="comment">/* max index in client[] array */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">/* no more readable descriptors */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= maxi; i++) &#123; <span class="comment">/* check all clients for data */</span></span><br><span class="line">      <span class="keyword">if</span> ((sockfd = client[i]) &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n = Read(sockfd, buf, MAXLINE)) == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">/*connection closed by client */</span></span><br><span class="line">          Close(sockfd);</span><br><span class="line">          FD_CLR(sockfd, &amp;allset);</span><br><span class="line">          client[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">          Writen(sockfd, buf, n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">/* no more readable descriptors */</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* end fig02 */</span></span><br></pre></td></tr></table></figure>



<h1 id="pselect-函数"><a href="#pselect-函数" class="headerlink" title="pselect 函数"></a>pselect 函数</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值：若有就绪描述符则为其数目，若超时则为0，若出错则为-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pselect</span><span class="params">(<span class="keyword">int</span> maxfdpl, fd_set *readset, fd_set *writeset, fd_set *execptset, </span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> struct timespec *timeout, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *sigmask)</span></span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>pselect 使用 timespec 结构，而不使用 timeval 结构.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line">	<span class="keyword">time_t</span> tv_sec; 	<span class="comment">// seconds</span></span><br><span class="line">	<span class="keyword">long</span> tv_nsec; 	<span class="comment">// nanoseconds，指定纳秒而不是微秒</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>pselect 函数增加了第六个参数——一个指向信号掩码的指针。该参数允许先禁止递交某些信号，再测试由这些当前被禁止的信号处理函数设置全局变量，然后调用 pselect，告诉它重新设置信号掩码。</p>
</li>
</ol>
<h1 id="poll-函数"><a href="#poll-函数" class="headerlink" title="poll 函数"></a>poll 函数</h1><p>poll 提供的功能与 select 类似，不过在处理流设备时，它能提供额外信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值：若有就绪描述符则为其数目，若超时则为0，若出错则为-1</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">	fd: 第一个参数是指向一个结构数组第一个元素的指针。每个数组元素都是一个pollfd结构，用于指定测试某个给定描述符fd的条件。</span></span><br><span class="line"><span class="comment">	nfds: 指定结构结构数组中的元素个数。</span></span><br><span class="line"><span class="comment">	timeout: 指定poll函数在返回前等待多长时间。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fd, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>要测试的条件由 events 指定，poll 函数在相应的 revents 成员中返回该描述符的状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">　　<span class="keyword">int</span> fd;          <span class="comment">// 被监视的文件描述符</span></span><br><span class="line">　　<span class="keyword">short</span> events;    <span class="comment">// 请求的事件</span></span><br><span class="line">　　<span class="keyword">short</span> revents;   <span class="comment">// 实际发生的事件</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>events 和 revents 的一些常值：第一部分处理输入，第二部分处理输出，第三部分处理错误（只能在 revents 中设定）。poll 识别三类数据：普通（normal），优先级带（priority band），高优先级（high priority）。</p>
<p><img src="https://gitee.com/qin-haonan/my-picture/raw/master/202110061602119.png" alt="image-20211006152607217"></p>
<p>timeout 值：</p>
<ul>
<li>INFTIM：永远等待；</li>
<li>0：立即返回，不阻塞进程；</li>
<li>＞0：等待指定数目的毫秒数。</li>
</ul>
<p>使用poll()和select()不一样，你不需要显式地请求异常情况报告。</p>
<ul>
<li>POLLIN | POLLPRI等价于select()的读事件.</li>
<li>POLLOUT |POLLWRBAND等价于select()的写事件。</li>
<li>POLLIN等价于POLLRDNORM |POLLRDBAND</li>
<li>而POLLOUT则等价于POLLWRNORM。</li>
</ul>
<p>例如，要同时监视一个文件描述符是否可读和可写，我们可以设置 events为POLLIN |POLLOUT。在poll返回时，我们可以检查revents中的标志，对应于文件描述符请求的events结构体。如果POLLIN事件被设置，则文件描述符可以被读取而不阻塞。如果POLLOUT被设置，则文件描述符可以写入而不导致阻塞。这些标志并不是互斥的：它们可能被同时设置，表示这个文件描述符的读取和写入操作都会正常返回而不阻塞。</p>
<p>使用 poll 函数改写 TCP 回射服务器程序：《UNIX 网络编程》P146-P148</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>5 种 I/O 模型，这里只讨论 I/O 复用模型。</li>
<li>I/O 复用最常用的函数是 select。批量输入时，即使用户输入结束，仍然有可能有数据残留在服务器和客户间的管道上（2个方向），需要使用 shutdown 函数以利用其半关闭特性。</li>
<li>混合使用 stdio 和 read/write 有危险，需要针对缓冲区而不是文本行进行操作。</li>
<li>poll 函数功能类似 select，但它能为流设备提供额外信息</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://wuhlan3.gitee.io/wuhlan3/2021/08/04/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E5%85%AD%EF%BC%89">https://wuhlan3.gitee.io/wuhlan3/2021/08/04/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E5%85%AD%EF%BC%89</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Anker/p/3258674.html">IO多路复用之select总结</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Anker/p/3261006.html">IO多路复用之poll总结</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lixungogogo/article/details/52226434">https://blog.csdn.net/lixungogogo/article/details/52226434</a></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>网络编程笔记(三)-I/O复用：select和poll函数</p><p><a href="https://tommyplayer-c.github.io/2021/10/04/计算机网络-2021-10-06-网络编程笔记-三-IO复用：select和poll函数/">https://tommyplayer-c.github.io/2021/10/04/计算机网络-2021-10-06-网络编程笔记-三-IO复用：select和poll函数/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>TommyPlayer</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-10-04</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-10-30</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"></div><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/linux-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">linux 网络编程 </a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/10/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-2021-10-04-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%BA%8C-TCP%E5%AE%A2%E6%88%B7%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A4%BA%E4%BE%8B/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">网络编程笔记(二)-TCP客户服务器示例</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%B8%80-%E5%9F%BA%E6%9C%ACTCP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/"><span class="level-item">网络编程笔记(一)-基本TCP套接字编程</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread',
            appId: "JUNkaa2nFLRBW02VRVV6TDlA-gzGzoHsz",
            appKey: "X2utmObXqHKT4G4RpNdh7rEH",
            placeholder: "欢迎探讨评论……",
            avatar: "hide",
            avatarForce: false,
            meta: ["nick","mail","link"],
            pageSize: 10,
            lang: "zh-CN",
            visitor: false,
            highlight: true,
            recordIP: false,
            
            
            
            enableQQ: false,
            requiredFields: [],
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/profile.jpg" alt="TommyPlayer"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">TommyPlayer</p><p class="is-size-6 is-block">Student</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">25</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">7</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">9</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/TommyPlayer-c" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/TommyPlayer-c"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/MySQL/"><span class="level-start"><span class="level-item">MySQL</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Vscode/"><span class="level-start"><span class="level-item">Vscode</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/linux/"><span class="level-start"><span class="level-item">linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">操作系统</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">数据结构与算法</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">计算机网络</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/C%E8%AF%AD%E8%A8%80/"><span class="tag">C语言</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MySQL/"><span class="tag">MySQL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/STL/"><span class="tag">STL</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><span class="tag">linux 网络编程</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux-%E9%85%8D%E7%BD%AE/"><span class="tag">linux 配置</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><span class="tag">动态规划</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE%E8%AE%BA/"><span class="tag">图论</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/"><span class="tag">操作系统理论</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%90%86%E8%AE%BA/"><span class="tag">计算机网络理论</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#网络编程笔记-三-I-O复用：select和poll函数"><span class="level-left"><span class="level-item">网络编程笔记(三)-I/O复用：select和poll函数</span></span></a></li><li><a class="level is-mobile" href="#I-O-模型"><span class="level-left"><span class="level-item">I/O 模型</span></span></a></li><li><a class="level is-mobile" href="#select-函数"><span class="level-left"><span class="level-item">select 函数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#定义和功能"><span class="level-left"><span class="level-item">定义和功能</span></span></a></li><li><a class="level is-mobile" href="#fd-set：设置文件描述符"><span class="level-left"><span class="level-item">fd_set：设置文件描述符</span></span></a></li><li><a class="level is-mobile" href="#maxfd-和中间-3-个描述符集参数"><span class="level-left"><span class="level-item">maxfd 和中间 3 个描述符集参数</span></span></a></li><li><a class="level is-mobile" href="#struct-timeval：超时时间"><span class="level-left"><span class="level-item">struct timeval：超时时间</span></span></a></li><li><a class="level is-mobile" href="#描述符就绪条件"><span class="level-left"><span class="level-item">描述符就绪条件</span></span></a></li></ul></li><li><a class="level is-mobile" href="#str-cli-的两次修改"><span class="level-left"><span class="level-item">str_cli 的两次修改</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#第一次修改"><span class="level-left"><span class="level-item">第一次修改</span></span></a></li><li><a class="level is-mobile" href="#shutdown-函数"><span class="level-left"><span class="level-item">shutdown 函数</span></span></a></li><li><a class="level is-mobile" href="#第二次修改"><span class="level-left"><span class="level-item">第二次修改</span></span></a></li></ul></li><li><a class="level is-mobile" href="#TCP-回射服务器程序（修订版）"><span class="level-left"><span class="level-item">TCP 回射服务器程序（修订版）</span></span></a></li><li><a class="level is-mobile" href="#pselect-函数"><span class="level-left"><span class="level-item">pselect 函数</span></span></a></li><li><a class="level is-mobile" href="#poll-函数"><span class="level-left"><span class="level-item">poll 函数</span></span></a></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">总结</span></span></a></li><li><a class="level is-mobile" href="#参考资料"><span class="level-left"><span class="level-item">参考资料</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">丢掉幻想，准备斗争</a><p class="is-size-7"><span>&copy; 2021 TommyPlayer</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>